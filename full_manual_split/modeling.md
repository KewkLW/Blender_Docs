# Index for modeling

- [Empties](#Empties)
- [Index](#Index)
- [Introduction](#Introduction)
- [Point Cloud](#Point-Cloud)
- [Curve Display](#Curve-Display)
- [Index](#Index)
- [Introduction](#Introduction)
- [Primitives](#Primitives)
- [Selecting](#Selecting)
- [Structure](#Structure)
- [Control Points](#Control-Points)
- [Curve](#Curve)
- [Index](#Index)
- [Other](#Other)
- [Segments](#Segments)
- [Transform Panel](#Transform-Panel)
- [Active Spline](#Active-Spline)
- [Geometry](#Geometry)
- [Index](#Index)
- [Path Animation](#Path-Animation)
- [Shape](#Shape)
- [Draw](#Draw)
- [Index](#Index)
- [Pen](#Pen)
- [Toolbar](#Toolbar)
- [Index](#Index)
- [Primitives](#Primitives)
- [Properties](#Properties)
- [Selecting](#Selecting)
- [Control Points](#Control-Points)
- [Curves](#Curves)
- [Index](#Index)
- [Segments](#Segments)
- [Draw](#Draw)
- [Index](#Index)
- [Toolbar](#Toolbar)
- [Attributes Reference](#Attributes-Reference)
- [Baking](#Baking)
- [Fields](#Fields)
- [Group](#Group)
- [Index](#Index)
- [Inspection](#Inspection)
- [Instances](#Instances)
- [Introduction](#Introduction)
- [Tools](#Tools)
- [Attribute Statistic](#Attribute-Statistic)
- [Blur Attribute](#Blur-Attribute)
- [Capture Attribute](#Capture-Attribute)
- [Domain Size](#Domain-Size)
- [Index](#Index)
- [Remove Named Attribute](#Remove-Named-Attribute)
- [Store Named Attribute](#Store-Named-Attribute)
- [Index](#Index)
- [Curve To Mesh](#Curve-To-Mesh)
- [Curve To Points](#Curve-To-Points)
- [Deform Curves On Surface](#Deform-Curves-On-Surface)
- [Fillet Curve](#Fillet-Curve)
- [Fill Curve](#Fill-Curve)
- [Index](#Index)
- [Interpolate Curves](#Interpolate-Curves)
- [Resample Curve](#Resample-Curve)
- [Reverse Curve](#Reverse-Curve)
- [Subdivide Curve](#Subdivide-Curve)
- [Trim Curve](#Trim-Curve)
- [Arc](#Arc)
- [Bezier Segment](#Bezier-Segment)
- [Curve Circle](#Curve-Circle)
- [Curve Line](#Curve-Line)
- [Curve Spiral](#Curve-Spiral)
- [Index](#Index)
- [Quadratic Bezier](#Quadratic-Bezier)
- [Quadrilateral](#Quadrilateral)
- [Star](#Star)
- [Curve Handle Position](#Curve-Handle-Position)
- [Curve Length](#Curve-Length)
- [Curve Tangent](#Curve-Tangent)
- [Curve Tilt](#Curve-Tilt)
- [Endpoint Selection](#Endpoint-Selection)
- [Handle Type Selection](#Handle-Type-Selection)
- [Index](#Index)
- [Is Spline Cyclic](#Is-Spline-Cyclic)
- [Spline Length](#Spline-Length)
- [Spline Parameter](#Spline-Parameter)
- [Spline Resolution](#Spline-Resolution)
- [Index](#Index)
- [Sample Curve](#Sample-Curve)
- [Curve Of Point](#Curve-Of-Point)
- [Index](#Index)
- [Offset Point In Curve](#Offset-Point-In-Curve)
- [Points Of Curve](#Points-Of-Curve)
- [Index](#Index)
- [Set Curve Normal](#Set-Curve-Normal)
- [Set Curve Radius](#Set-Curve-Radius)
- [Set Curve Tilt](#Set-Curve-Tilt)
- [Set Handle Positions](#Set-Handle-Positions)
- [Set Handle Type](#Set-Handle-Type)
- [Set Spline Cyclic](#Set-Spline-Cyclic)
- [Set Spline Resolution](#Set-Spline-Resolution)
- [Set Spline Type](#Set-Spline-Type)
- [Geometry To Instance](#Geometry-To-Instance)
- [Index](#Index)
- [Join Geometry](#Join-Geometry)
- [Bake](#Bake)
- [Bounding Box](#Bounding-Box)
- [Convex Hull](#Convex-Hull)
- [Delete Geometry](#Delete-Geometry)
- [Duplicate Elements](#Duplicate-Elements)
- [Index](#Index)
- [Merge By Distance](#Merge-By-Distance)
- [Separate Components](#Separate-Components)
- [Separate Geometry](#Separate-Geometry)
- [Sort Elements](#Sort-Elements)
- [Split To Instances](#Split-To-Instances)
- [Transform Geometry](#Transform-Geometry)
- [Id](#Id)
- [Index](#Index)
- [Input Index](#Input-Index)
- [Named Attribute](#Named-Attribute)
- [Normal](#Normal)
- [Position](#Position)
- [Radius](#Radius)
- [Selection](#Selection)
- [Geometry Proximity](#Geometry-Proximity)
- [Index](#Index)
- [Index Of Nearest](#Index-Of-Nearest)
- [Raycast](#Raycast)
- [Sample Index](#Sample-Index)
- [Sample Nearest](#Sample-Nearest)
- [Index](#Index)
- [Set Id](#Set-Id)
- [Set Position](#Set-Position)
- [Set Selection](#Set-Selection)
- [Index](#Index)
- [Blend Hair Curves](#Blend-Hair-Curves)
- [Displace Hair Curves](#Displace-Hair-Curves)
- [Frizz Hair Curves](#Frizz-Hair-Curves)
- [Hair Curves Noise](#Hair-Curves-Noise)
- [Index](#Index)
- [Roll Hair Curves](#Roll-Hair-Curves)
- [Rotate Hair Curves](#Rotate-Hair-Curves)
- [Shrinkwrap Hair Curves](#Shrinkwrap-Hair-Curves)
- [Smooth Hair Curves](#Smooth-Hair-Curves)
- [Straighten Hair Curves](#Straighten-Hair-Curves)
- [Trim Hair Curves](#Trim-Hair-Curves)
- [Duplicate Hair Curves](#Duplicate-Hair-Curves)
- [Generate Hair Curves](#Generate-Hair-Curves)
- [Index](#Index)
- [Interpolate Hair Curves](#Interpolate-Hair-Curves)
- [Braid Hair Curves](#Braid-Hair-Curves)
- [Clump Hair Curves](#Clump-Hair-Curves)
- [Create Guide Index Map](#Create-Guide-Index-Map)
- [Curl Hair Curves](#Curl-Hair-Curves)
- [Index](#Index)
- [Curve Info](#Curve-Info)
- [Curve Root](#Curve-Root)
- [Curve Segment](#Curve-Segment)
- [Curve Tip](#Curve-Tip)
- [Hair Attachment Info](#Hair-Attachment-Info)
- [Index](#Index)
- [Attach Hair Curves To Surface](#Attach-Hair-Curves-To-Surface)
- [Index](#Index)
- [Redistribute Curve Points](#Redistribute-Curve-Points)
- [Restore Curve Segment Length](#Restore-Curve-Segment-Length)
- [Index](#Index)
- [Set Hair Curve Profile](#Set-Hair-Curve-Profile)
- [Index](#Index)
- [Boolean](#Boolean)
- [Color](#Color)
- [Image](#Image)
- [Index](#Index)
- [Integer](#Integer)
- [Material](#Material)
- [String](#String)
- [Value](#Value)
- [Vector](#Vector)
- [3D Cursor](#3D-Cursor)
- [Active Camera](#Active-Camera)
- [Collection Info](#Collection-Info)
- [Image Info](#Image-Info)
- [Index](#Index)
- [Is Viewport](#Is-Viewport)
- [Object Info](#Object-Info)
- [Scene Time](#Scene-Time)
- [Self Object](#Self-Object)
- [Index](#Index)
- [Instances To Points](#Instances-To-Points)
- [Instance On Points](#Instance-On-Points)
- [Instance Rotation](#Instance-Rotation)
- [Instance Scale](#Instance-Scale)
- [Realize Instances](#Realize-Instances)
- [Rotate Instances](#Rotate-Instances)
- [Scale Instances](#Scale-Instances)
- [Translate Instances](#Translate-Instances)
- [Index](#Index)
- [Material Index](#Material-Index)
- [Material Selection](#Material-Selection)
- [Replace Material](#Replace-Material)
- [Set Material](#Set-Material)
- [Set Material Index](#Set-Material-Index)
- [Index](#Index)
- [Dual Mesh](#Dual-Mesh)
- [Edge Paths To Curves](#Edge-Paths-To-Curves)
- [Edge Paths To Selection](#Edge-Paths-To-Selection)
- [Extrude Mesh](#Extrude-Mesh)
- [Flip Faces](#Flip-Faces)
- [Index](#Index)
- [Mesh Boolean](#Mesh-Boolean)
- [Mesh To Curve](#Mesh-To-Curve)
- [Mesh To Points](#Mesh-To-Points)
- [Mesh To Volume](#Mesh-To-Volume)
- [Scale Elements](#Scale-Elements)
- [Split Edges](#Split-Edges)
- [Subdivide Mesh](#Subdivide-Mesh)
- [Subdivision Surface](#Subdivision-Surface)
- [Triangulate](#Triangulate)
- [Cone](#Cone)
- [Cube](#Cube)
- [Cylinder](#Cylinder)
- [Grid](#Grid)
- [Icosphere](#Icosphere)
- [Index](#Index)
- [Mesh Circle](#Mesh-Circle)
- [Mesh Line](#Mesh-Line)
- [Uv Sphere](#Uv-Sphere)
- [Edges To Face Groups](#Edges-To-Face-Groups)
- [Edge Angle](#Edge-Angle)
- [Edge Neighbors](#Edge-Neighbors)
- [Edge Vertices](#Edge-Vertices)
- [Face Area](#Face-Area)
- [Face Group Boundaries](#Face-Group-Boundaries)
- [Face Is Planar](#Face-Is-Planar)
- [Face Neighbors](#Face-Neighbors)
- [Face Set](#Face-Set)
- [Index](#Index)
- [Is Edge Smooth](#Is-Edge-Smooth)
- [Is Face Smooth](#Is-Face-Smooth)
- [Mesh Island](#Mesh-Island)
- [Shortest Edge Paths](#Shortest-Edge-Paths)
- [Vertex Neighbors](#Vertex-Neighbors)
- [Index](#Index)
- [Sample Nearest Surface](#Sample-Nearest-Surface)
- [Sample Uv Surface](#Sample-Uv-Surface)
- [Corners Of Edge](#Corners-Of-Edge)
- [Corners Of Face](#Corners-Of-Face)
- [Corners Of Vertex](#Corners-Of-Vertex)
- [Edges Of Corner](#Edges-Of-Corner)
- [Edges Of Vertex](#Edges-Of-Vertex)
- [Face Of Corner](#Face-Of-Corner)
- [Index](#Index)
- [Offset Corner In Face](#Offset-Corner-In-Face)
- [Vertex Of Corner](#Vertex-Of-Corner)
- [Index](#Index)
- [Pack Uv Islands](#Pack-Uv-Islands)
- [Uv Unwrap](#Uv-Unwrap)
- [Index](#Index)
- [Set Face Set](#Set-Face-Set)
- [Set Shade Smooth](#Set-Shade-Smooth)
- [Index](#Index)
- [Smooth By Angle](#Smooth-By-Angle)
- [Index](#Index)
- [Viewer](#Viewer)
- [Distribute Points In Volume](#Distribute-Points-In-Volume)
- [Distribute Points On Faces](#Distribute-Points-On-Faces)
- [Index](#Index)
- [Points](#Points)
- [Points To Curves](#Points-To-Curves)
- [Points To Vertices](#Points-To-Vertices)
- [Points To Volume](#Points-To-Volume)
- [Set Point Radius](#Set-Point-Radius)
- [Simulation Zone](#Simulation-Zone)
- [Brick](#Brick)
- [Checker](#Checker)
- [Gradient](#Gradient)
- [Image](#Image)
- [Index](#Index)
- [Magic](#Magic)
- [Musgrave](#Musgrave)
- [Noise](#Noise)
- [Voronoi](#Voronoi)
- [Wave](#Wave)
- [White Noise](#White-Noise)
- [Index](#Index)
- [Index Switch](#Index-Switch)
- [Menu Switch](#Menu-Switch)
- [Random Value](#Random-Value)
- [Repeat Zone](#Repeat-Zone)
- [Switch](#Switch)
- [Blackbody](#Blackbody)
- [Color Ramp](#Color-Ramp)
- [Combine Color](#Combine-Color)
- [Index](#Index)
- [Mix Rgb](#Mix-Rgb)
- [Rgb Curves](#Rgb-Curves)
- [Separate Color](#Separate-Color)
- [Accumulate Field](#Accumulate-Field)
- [Evaluate At Index](#Evaluate-At-Index)
- [Evaluate On Domain](#Evaluate-On-Domain)
- [Index](#Index)
- [Boolean Math](#Boolean-Math)
- [Clamp](#Clamp)
- [Compare](#Compare)
- [Float Curve](#Float-Curve)
- [Float To Integer](#Float-To-Integer)
- [Index](#Index)
- [Map Range](#Map-Range)
- [Math](#Math)
- [Mix](#Mix)
- [Align Euler To Vector](#Align-Euler-To-Vector)
- [Axis Angle To Rotation](#Axis-Angle-To-Rotation)
- [Euler To Rotation](#Euler-To-Rotation)
- [Index](#Index)
- [Invert Rotation](#Invert-Rotation)
- [Quaternion To Rotation](#Quaternion-To-Rotation)
- [Rotate Rotation](#Rotate-Rotation)
- [Rotate Vector](#Rotate-Vector)
- [Rotation To Euler](#Rotation-To-Euler)
- [Rotation To Quaternion](#Rotation-To-Quaternion)
- [Index](#Index)
- [Join Strings](#Join-Strings)
- [Replace String](#Replace-String)
- [Slice String](#Slice-String)
- [Special Characters](#Special-Characters)
- [String Length](#String-Length)
- [String To Curves](#String-To-Curves)
- [Value To String](#Value-To-String)
- [Combine Xyz](#Combine-Xyz)
- [Index](#Index)
- [Separate Xyz](#Separate-Xyz)
- [Vector Curves](#Vector-Curves)
- [Vector Math](#Vector-Math)
- [Vector Rotate](#Vector-Rotate)
- [Index](#Index)
- [Index](#Index)
- [Volume To Mesh](#Volume-To-Mesh)
- [Index](#Index)
- [Volume Cube](#Volume-Cube)
- [Import Images As Planes](#Import-Images-As-Planes)
- [Index](#Index)
- [Introduction](#Introduction)
- [Mesh Analysis](#Mesh-Analysis)
- [Primitives](#Primitives)
- [Retopology](#Retopology)
- [Structure](#Structure)
- [Index](#Index)
- [Introduction](#Introduction)
- [Uv](#Uv)
- [Bevel](#Bevel)
- [Bridge Edge Loops](#Bridge-Edge-Loops)
- [Edge Data](#Edge-Data)
- [Edge Slide](#Edge-Slide)
- [Extrude Edges](#Extrude-Edges)
- [Index](#Index)
- [Loopcut Slide](#Loopcut-Slide)
- [Offset Edge Slide](#Offset-Edge-Slide)
- [Rotate Edge](#Rotate-Edge)
- [Screw](#Screw)
- [Subdivide](#Subdivide)
- [Subdivide Edge Ring](#Subdivide-Edge-Ring)
- [Unsubdivide](#Unsubdivide)
- [Beautify Faces](#Beautify-Faces)
- [Extrude Faces](#Extrude-Faces)
- [Extrude Faces Normal](#Extrude-Faces-Normal)
- [Extrude Individual Faces](#Extrude-Individual-Faces)
- [Face Data](#Face-Data)
- [Fill](#Fill)
- [Grid Fill](#Grid-Fill)
- [Index](#Index)
- [Inset Faces](#Inset-Faces)
- [Intersect Boolean](#Intersect-Boolean)
- [Intersect Knife](#Intersect-Knife)
- [Poke Faces](#Poke-Faces)
- [Shading](#Shading)
- [Solidify Faces](#Solidify-Faces)
- [Triangles Quads](#Triangles-Quads)
- [Triangulate Faces](#Triangulate-Faces)
- [Weld Edges Faces](#Weld-Edges-Faces)
- [Wireframe](#Wireframe)
- [Bisect](#Bisect)
- [Cleanup](#Cleanup)
- [Convex Hull](#Convex-Hull)
- [Delete](#Delete)
- [Duplicate](#Duplicate)
- [Extrude](#Extrude)
- [Index](#Index)
- [Knife Project](#Knife-Project)
- [Knife Topology Tool](#Knife-Topology-Tool)
- [Merge](#Merge)
- [Mirror](#Mirror)
- [Normals](#Normals)
- [Separate](#Separate)
- [Set Attribute](#Set-Attribute)
- [Shading](#Shading)
- [Snap Symmetry](#Snap-Symmetry)
- [Sort Elements](#Sort-Elements)
- [Split](#Split)
- [Symmetrize](#Symmetrize)
- [Basic](#Basic)
- [Bend](#Bend)
- [Index](#Index)
- [Push Pull](#Push-Pull)
- [Randomize](#Randomize)
- [Shear](#Shear)
- [Shrink-Fatten](#Shrink-Fatten)
- [Skin Resize](#Skin-Resize)
- [To Sphere](#To-Sphere)
- [Warp](#Warp)
- [Bevel Vertices](#Bevel-Vertices)
- [Blend Shape](#Blend-Shape)
- [Connect Vertex Pairs](#Connect-Vertex-Pairs)
- [Connect Vertex Path](#Connect-Vertex-Path)
- [Extrude Cursor](#Extrude-Cursor)
- [Extrude Vertices](#Extrude-Vertices)
- [Hooks](#Hooks)
- [Index](#Index)
- [Laplacian Smooth](#Laplacian-Smooth)
- [Make Face Edge](#Make-Face-Edge)
- [Make Vertex Parent](#Make-Vertex-Parent)
- [Propagate Shapes](#Propagate-Shapes)
- [Rip Vertices](#Rip-Vertices)
- [Rip Vertices Extend](#Rip-Vertices-Extend)
- [Rip Vertices Fill](#Rip-Vertices-Fill)
- [Slide Vertices](#Slide-Vertices)
- [Smooth Vertices](#Smooth-Vertices)
- [Vertex Groups](#Vertex-Groups)
- [Custom Data](#Custom-Data)
- [Index](#Index)
- [Object Data](#Object-Data)
- [Assigning Vertex Group](#Assigning-Vertex-Group)
- [Index](#Index)
- [Introduction](#Introduction)
- [Vertex Groups](#Vertex-Groups)
- [Vertex Weights](#Vertex-Weights)
- [All By Trait](#All-By-Trait)
- [By Attribute](#By-Attribute)
- [Checker Deselect](#Checker-Deselect)
- [Index](#Index)
- [Introduction](#Introduction)
- [Linked](#Linked)
- [Loops](#Loops)
- [Mirror](#Mirror)
- [More Less](#More-Less)
- [Random](#Random)
- [Sharp Edges](#Sharp-Edges)
- [Side Of Active](#Side-Of-Active)
- [Similar](#Similar)
- [Extrude Cursor](#Extrude-Cursor)
- [Extrude Manifold](#Extrude-Manifold)
- [Extrude Region](#Extrude-Region)
- [Index](#Index)
- [Loop](#Loop)
- [Poly Build](#Poly-Build)
- [Spin](#Spin)
- [Toolbar](#Toolbar)
- [Tool Settings](#Tool-Settings)
- [Applying Image](#Applying-Image)
- [Editing](#Editing)
- [Index](#Index)
- [Uv Texture Spaces](#Uv-Texture-Spaces)
- [Grab](#Grab)
- [Index](#Index)
- [Pinch](#Pinch)
- [Relax](#Relax)
- [Rip](#Rip)
- [Toolbar](#Toolbar)
- [Index](#Index)
- [Introduction](#Introduction)
- [Seams](#Seams)
- [Index](#Index)
- [Layout](#Layout)
- [Udims](#Udims)
- [Editing](#Editing)
- [Index](#Index)
- [Introduction](#Introduction)
- [Primitives](#Primitives)
- [Properties](#Properties)
- [Structure](#Structure)
- [Index](#Index)
- [Common Options](#Common-Options)
- [Index](#Index)
- [Introduction](#Introduction)
- [Armature](#Armature)
- [Cast](#Cast)
- [Corrective Smooth](#Corrective-Smooth)
- [Curve](#Curve)
- [Displace](#Displace)
- [Hooks](#Hooks)
- [Index](#Index)
- [Laplacian Deform](#Laplacian-Deform)
- [Laplacian Smooth](#Laplacian-Smooth)
- [Lattice](#Lattice)
- [Mesh Deform](#Mesh-Deform)
- [Shrinkwrap](#Shrinkwrap)
- [Simple Deform](#Simple-Deform)
- [Smooth](#Smooth)
- [Surface Deform](#Surface-Deform)
- [Volume Displace](#Volume-Displace)
- [Warp](#Warp)
- [Wave](#Wave)
- [Array](#Array)
- [Bevel](#Bevel)
- [Booleans](#Booleans)
- [Build](#Build)
- [Decimate](#Decimate)
- [Edge Split](#Edge-Split)
- [Geometry Nodes](#Geometry-Nodes)
- [Index](#Index)
- [Mask](#Mask)
- [Mesh To Volume](#Mesh-To-Volume)
- [Mirror](#Mirror)
- [Multiresolution](#Multiresolution)
- [Remesh](#Remesh)
- [Screw](#Screw)
- [Skin](#Skin)
- [Solidify](#Solidify)
- [Subdivision Surface](#Subdivision-Surface)
- [Triangulate](#Triangulate)
- [Volume To Mesh](#Volume-To-Mesh)
- [Weld](#Weld)
- [Wireframe](#Wireframe)
- [Data Transfer](#Data-Transfer)
- [Index](#Index)
- [Mesh Cache](#Mesh-Cache)
- [Mesh Sequence Cache](#Mesh-Sequence-Cache)
- [Normal Edit](#Normal-Edit)
- [Uv Project](#Uv-Project)
- [Uv Warp](#Uv-Warp)
- [Weighted Normal](#Weighted-Normal)
- [Weight Edit](#Weight-Edit)
- [Weight Mix](#Weight-Mix)
- [Weight Proximity](#Weight-Proximity)
- [Cloth](#Cloth)
- [Collision](#Collision)
- [Dynamic Paint](#Dynamic-Paint)
- [Explode](#Explode)
- [Fluid](#Fluid)
- [Index](#Index)
- [Ocean](#Ocean)
- [Particle Instance](#Particle-Instance)
- [Particle System](#Particle-System)
- [Soft Body](#Soft-Body)
- [Index](#Index)
- [Introduction](#Introduction)
- [Primitives](#Primitives)
- [Selecting](#Selecting)
- [Structure](#Structure)
- [Control Points](#Control-Points)
- [Index](#Index)
- [Segments](#Segments)
- [Surface](#Surface)
- [Transform Panel](#Transform-Panel)
- [Active Spline](#Active-Spline)
- [Index](#Index)
- [Shape](#Shape)
- [Index](#Index)
- [Editing](#Editing)
- [Index](#Index)
- [Introduction](#Introduction)
- [Properties](#Properties)
- [Selecting](#Selecting)
- [Index](#Index)
- [Introduction](#Introduction)
- [Modal Map](#Modal-Map)
- [Index](#Index)
- [Introduction](#Introduction)
- [Properties](#Properties)


## Empties

.. _bpy.types.Object.empty:
.. _bpy.ops.object.empty:
.. (todo add) Needs more detailed use cases.

*******
Empties
*******

The "empty" is a single coordinate point with no additional geometry.
Because an empty has no volume and surface, it cannot be rendered.
Still it can be used as a handle for many purposes.


Primitives
==========

.. figure:: /images/modeling_empties_draw-types.png
   :align: right

   Empty Display Types.


Plain Axes
----------

Displays as six lines, initially with one pointing in each of the +X, -X, +Y, -Y, +Z, and -Z axis directions.


Arrows
------

Displays as arrows, initially pointing in the positive X, Y, and Z axis directions, each with a label.


Single Arrow
------------

Displays as a single arrow, initially pointing in the +Z axis direction.


Circle
------

Displays as a circle initially in the XZ plane.


Cube
----

Displays as a cube, initially aligned to the XYZ axes.


Sphere
------

Displays as an implied sphere defined by three circles.
Initially, the circles are aligned, one each, to the X, Y, and Z axes.


Cone
----

Displays as a cone, initially pointing in the +Y axis direction.


.. _bpy.types.Object.empty_image:

Image
-----

Empties can display images. This can be used to create reference images,
including blueprints or character sheets to model from.
The image is displayed regardless of the 3D display mode.

Empty Displays settings can be accessed from :menuselection:`Properties --> Object Data --> Empty` panel.

Offset X, Y
   Offset the image origin
   (where 1.0 represents the width/height of the image).

   :X=0.5, Y=0.5: Object origin at image center.
   :X=0.0, Y=0.0: Object origin at image bottom, left.
   :X=1.0, Y=1.0: Object origin at image top, right.

Depth
   :Default: Use normal depth behavior.
   :Front: Always display on top of other objects.
   :Back: Always display behind of other objects.

   .. tip::

      When using the image as a reference for modeling,
      it can be useful to set the depth to *Front*, with a low *Opacity*.

Side
   :Both: Display both the front and back of the empty.
   :Front: Only display the front of the image.
   :Back: Only display the back of the image.

   .. tip::

      This is useful if you are using an image as a reference where you have photos from
      both the front and back,
      so two empty images can be set only to show when viewed from the correct side.

Show in
   Orthographic
      Show in orthographic view.
   Perspective
      Show in perspective view.

      .. hint::

         It's often useful to disable this so reference images don't
         *get in the way* when viewing a model.
   Only Axis Aligned
      Only displays the image contents when the view is aligned with the object's local axis.

.. _bpy.types.Object.use_empty_image_alpha:

Opacity
   Blends the image with the background. The value slider adjusts the opacity of the image,
   changing how much of the image is blended with the background.


Editing
=======

An empty can only be edited in Object Mode, which includes its transformation and parenting properties.
For other tools see the :doc:`Object section </scene_layout/object/index>`.

Apply Scale :kbd:`Ctrl-A`
   While empties don't exactly have any object data attached to them which can be used for supporting
   "true" apply scale (i.e. with non-uniform scaling), they do have *Display Size* which controls how
   large the empties are displayed (before scaling). This works by taking the scale factor on the most-scaled axis,
   and combines this with the existing empty *Display Size* to maintain the correct dimensions on that axis.


Properties
==========

.. _bpy.types.Object.empty_display_type:

Display As
   The `Primitives`_ empty type to display in the 3D Viewport.

.. _bpy.types.Object.empty_display_size:

Size
   Controls the size of the empties visualization. This does not change its scale, but functions as an offset.


Usage
=====

Empties can serve as transform handles. Some examples of ways to use them include:


.. rubric:: Parent object for a group of objects

An empty can be parented to any number of other objects.
This gives the user the ability to control a group of objects easily, and without affecting a render.


.. rubric:: Target for constraints

An empty can also be used as a target for normal, or bone constraints.
This gives the user far more control; for instance,
a rig can easily be set up to enable a camera to point towards an empty using the *Track to* constraint.


.. rubric:: Array offset

An empty can be used to offset an Array Modifier,
meaning complex deformations can be achieved by only moving a single object.

.. list-table::

   * - .. figure:: /images/modeling_modifiers_generate_array_example-fractal-1.jpg
          :width: 320px

          An example of an empty being used to control an array.

     - .. figure:: /images/modeling_empties_example-track-to-simple.png
          :width: 320px

          An example of an empty being used to control the Track To constraint.


.. rubric:: Other common uses:

- Placeholders
- Rigging controls
- DOF distances
- Reference Images


## Index

.. index:: Modeling
.. _bpy.ops.geometry:

############
  Modeling
############

.. toctree::
   :maxdepth: 2

   introduction.rst
   meshes/index.rst
   curves/index.rst
   curves_new/index.rst
   surfaces/index.rst
   metas/index.rst
   texts/index.rst
   volumes/index.rst
   empties.rst
   modifiers/index.rst
   geometry_nodes/index.rst
   transform/index.rst


## Introduction


************
Introduction
************

The creation of a 3D scene needs at least three key components: Models, materials and lights.
In this part, the first of these is covered, that being modeling.
Modeling is simply the art and science of creating a surface that either mimics the shape
of a real-world object or expresses your imagination of abstract objects.


Modes
=====

Depending on the type of object you are trying to model, there are different types
of modeling :doc:`modes </editors/3dview/modes>`.
Since modes are not specific to modeling they are covered in different parts of the manual.

Switching between modes while modeling is common.
Some tools may be available in more than one mode while others may be unique to a particular mode.


Edit Mode
---------

Edit Mode is the main mode where modeling takes place.
Edit Mode is used to edit the following types of objects:

- Meshes
- Curves
- Surfaces
- Metaballs
- Text objects
- Lattice

You can only modify the mesh of the objects you are editing.
To modify other objects you can leave Edit Mode, select another object and enter Edit Mode,
or use :ref:`3dview-multi-object-mode`.


## Point Cloud

:orphan:

.. important::

   This feature is currently :doc:`experimental </editors/preferences/experimental>`
   and not available in current releases.

.. _bpy.ops.object.pointcloud:

***********
Point Cloud
***********

:term:`Point clouds <Point Cloud>` can be used to represent 3D scans and
in the future can represent particles. Each point can store data in a set of `Attributes`_.

.. figure:: /images/modeling_point-cloud_example.png

   Example of a monkey object represented as a point cloud.


Properties
==========

Attributes
----------

The *Attributes* panel contains different point cloud characteristics such as the position and size of points.
Use the :ref:`List View <ui-list-view>` to manage attributes.


Attribute Types
^^^^^^^^^^^^^^^

.. seealso::

   See :ref:`geometry-nodes_builtin-attributes` for information about common attributes.

.. list-table::
   :widths: 10 10 10 50
   :header-rows: 1

   * - Name
     - Type
     - Domain
     - Notes

   * - ``position``
     - *Vector*
     - *Point*
     - Built-in attribute describing vertex or point locations, in the modifier object's transform space.

   * - ``radius``
     - *Float*
     - *Point*
     - The radius of each point.

   * - ``color``
     - *Color*
     - *Point*
     - The color of each point.

   * - ``id``
     - *Integer*
     - *Point*
     - A unique identifier given to each particle.

   * - ``velocity``
     - *Vector*
     - *Point*
     - The speed and direction that the particle is traveling.

Custom Attributes
   Custom attribute can be given to particles to hold a custom characteristic.

   Name
      The name of the attribute.
   Data Type
      The type of data to store in the attribute.

      :Float: Floating-point value
      :Integer: 32-bit integer
      :Vector: 3D vector with floating-point values
      :Color: RGBA color with floating-point precision
      :Byte Color: RGBA color with 8-bit precision
      :String: Text string

   Domain
      The type of element the attribute is stored in.
      Currently, attributes can only be stored per *Point*.


Custom Properties
-----------------

See the :ref:`Custom Properties <files-data_blocks-custom-properties>` page for more information.


Editing
=======

Currently, not much can be done with point clouds; however,
they can be :doc:`converted to/from meshes </scene_layout/object/editing/convert>`.


## Curve Display


*************
Curve Display
*************

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`3D Viewport --> Viewport Overlays --> Curve Edit Mode`

When in Edit Mode, curves have special :doc:`overlays </editors/3dview/display/overlays>`
to control how curves are displayed in the 3D Viewport.

Handles
   Toggles the option to display the Bézier handles.
Normals
   Toggles the display of the curve normals.

   Normal Size
      Length of the axis that points the direction of the normal.


## Index

.. _modeling-curves-index:
.. _bpy.types.Curve:
.. _bpy.ops.curve:

##########
  Curves
##########

.. toctree::
   :maxdepth: 2

   introduction.rst
   tools/index.rst
   structure.rst
   primitives.rst
   selecting.rst
   editing/index.rst
   properties/index.rst
   curve_display.rst


## Introduction


************
Introduction
************

Curves and :doc:`Surfaces </modeling/surfaces/introduction>` are particular types of Blender objects.
They are expressed by mathematical functions (interpolation)
rather than linear interpolation between a series of points.

Blender offers both :ref:`curve-bezier` and :ref:`curve-nurbs`.
Both Bézier curves and NURBS curves and surfaces are defined in terms of a set of "control points"
(or "control vertices") which define a "control polygon".

.. figure:: /images/modeling_curves_introduction_logo.png
   :align: center

   Blender logo made from Bézier curves.

Both Bézier and NURBS curves are named after their mathematical definitions, and
choosing between them is often more a matter of how they are computed behind the scenes
than how they appear from a modeler's perspective.
Bézier curves are generally more intuitive because they start and end at the control points that you set,
but NURBS curves are more efficient for the computer to calculate when there are many twists and turns in a curve.

The main advantage to using curves instead of polygonal meshes is that curves are defined by
less data and so can produce results using less memory and storage space at modeling time.
However, this procedural approach to surfaces can increase demands at render time.

Certain modeling techniques, such as
:doc:`extruding a profile along a path </modeling/curves/properties/geometry>`,
are possible only using curves. On the other hand, when using curves,
vertex-level control is more difficult and if fine control is necessary,
:doc:`mesh editing </modeling/meshes/editing/introduction>` may be a better modeling option.

Bézier curves are the most commonly used curves for designing letters or logos.

They are also widely used in animation, both as for objects to move along (see constraints below)
and as :doc:`F-Curves </editors/graph_editor/fcurves/introduction>`
to change the properties of objects as a function of time.

.. seealso:: Modifiers & Constraints

   - :doc:`Curve Modifier </modeling/modifiers/deform/curve>`
   - :doc:`Follow Path Constraint </animation/constraints/relationship/follow_path>`
   - :doc:`Clamp To Constraint </animation/constraints/tracking/clamp_to>`


## Primitives

.. _bpy.ops.curve.primitive*add:

**********
Primitives
**********

.. reference::

   :Mode:      Object Mode and Edit Mode
   :Menu:      :menuselection:`Add --> Curve`
   :Shortcut:  :kbd:`Shift-A`

.. seealso::

   When adding curves there are some common options like other :ref:`Objects <object-common-options>`.

.. note::

   Eventually all the primitive curves will be replaced to use the same curve system used for hair curves.
   Until this is done, their features will diverge.

   They can be converted interchangeably to access the full range of edit and sculpting functionalities.

In Object/Edit Mode, the *Add Curve* menu, provides a few different curve primitives:


Bézier Curve
============

Adds an open 2D Bézier curve with two control points.


Bézier Circle
=============

Adds a closed, circle-shaped 2D Bézier curve (made of four control points).


NURBS Curve
===========

Adds an open 2D :term:`NURBS` curve, with four control points, with *Uniform* knots.


NURBS Circle
============

Adds a closed, circle-shaped 2D :term:`NURBS` curve (made of eight control points).


Path
====

Adds a :term:`NURBS` open 3D curve made of five aligned control points,
with *Endpoint* knots and the *Curve Path* setting enabled.


## Selecting


*********
Selecting
*********

This page discusses specific selecting tools for curve objects in Edit Mode.
The Curve Edit more also uses the general select tools used which are described
in the :doc:`interface section </interface/selecting>`.

Curve selection in *Edit Mode* has fewer options than with meshes.
Mainly this is, because there is only one selectable element type, the control points
(no select mode needed here...). These points are a bit more complex than simple vertices,
however, especially for Bézier curves, as there is the central vertex, and its two handles...

The basic tools are the same as with :doc:`meshes </modeling/meshes/selecting/index>`,
so you can select a simple control point with the :kbd:`LMB`,
add to current selection with :kbd:`Shift-LMB`, Box Select :kbd:`B`, and so on.

One word about the Bézier control points: when you select the main central vertex,
the two handles are automatically selected too, so you can move it as a whole,
without creating an angle in the curve. However, when you select a handle,
only this vertex is selected, allowing you to modify this control vector...

Note that, unlike mesh edges, you cannot directly select a segment. Instead,
select all of the control points that make up the segment you want to edit.


Select Menu
===========

With curves, all "advanced" selection options are grouped
in the *Select* menu of the 3D Viewport header.


.. _bpy.ops.curve.select_all:

All
===

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> All`
   :Shortcut:  :kbd:`A`

Select all selectable elements.


None
====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> None`
   :Shortcut:  :kbd:`Alt-A`

Deselect all elements, but the active element stays the same.


Invert
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Invert`
   :Shortcut:  :kbd:`Ctrl-I`

Selects all the geometry that are not selected, and deselect currently selected components.


Box Select
==========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Box Select`
   :Shortcut:  :kbd:`B`

Interactive :ref:`box selection <tool-select-box>`.


Circle Select
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Circle Select`
   :Shortcut:  :kbd:`C`

Interactive :ref:`circle selection <tool-select-circle>`.


Lasso Select
============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Lasso Select`
   :Shortcut:  :kbd:`Ctrl-Alt-LMB`

See :ref:`tool-select-lasso`.


.. _bpy.ops.curve.select_random:

Select Random
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Random`

Select Random control points.

Percent
   Selects the defined percentage of control points.
Random Seed
   :term:`Seed` used by the pseudo-random number generator.
Action
   Controls whether the operator *Selects* or *Deselects* control points.


.. _bpy.ops.curve.select_nth:

Checker Deselect
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Checker Deselect`

This tool applies an alternating selected/deselected checker pattern.
This only works if you already have more than one control point selected.

It works by changing the current selection so that only every Nth
control points will remain selected, starting from the active one.

Deselected
   The number of deselected elements in each pattern repetition.
Selected
   The number of selected elements in each pattern repetition.
Offset
   Offset from the starting point.


.. _bpy.ops.curve.select_more:
.. _bpy.ops.curve.select_less:

Select More/Less
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> More/Less`
   :Shortcut:  :kbd:`Ctrl-NumpadPlus`, :kbd:`Ctrl-NumpadMinus`

Their purpose, based on the currently selected control points, is to reduce or enlarge this selection.

More
   For each selected control point, select *all* its linked points (i.e. one or two...).
Less
   For each selected control point, if *all* points linked to this point are selected, keep this one selected.
   Otherwise, deselect it.

This implies two points:

#. When *all* control points of a curve are selected, nothing will happen
   (as for *Less*, all linked points are always selected, and of course, *More* cannot add any).
   Conversely, the same goes when no control points are selected.
#. Second, these tools will never "go outside" of a curve
   (they will never "jump" to another curve in the same object).


.. _bpy.ops.curve.select_linked:

Select Linked
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Linked`
   :Shortcut:  :kbd:`L`, :kbd:`Ctrl-L`, :kbd:`Shift-L`

:kbd:`L` (or :kbd:`Ctrl-L` for all) will add to the selection the cursor's nearest control point,
and all the linked ones, i.e. all points belonging to the same curve. Note that for Bézier,
using :kbd:`L` with a handle selected will select the whole control point and all the linked ones.


.. _bpy.ops.curve.select_similar:

Select Similar
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Similar`
   :Shortcut:  :kbd:`Shift-G`

Selects control points that have certain similar properties to the active one.
The :ref:`bpy.ops.screen.redo_last` panel provides several selection options:

Type
   Type
      Selects splines that have the same spline Type i.e. Bézier, NURBS or Poly.
   Radius
      Selects control points that have a similar Radius value.
   Weight
      Selects all points that have a similar Weight value.
   Direction
      Selects control points that have a similar handles direction.

Compare
   For quantitative properties, this property selects the type of comparison to between the two numerical values.

   :Equal: Select items with the same value as the active item's chosen property.
   :Greater: Select items with a larger value as the active item's chosen property.
   :Less: Select items with a smaller value as the active item's chosen property.
Threshold
   For quantitative properties, this property controls how
   close the property's values have to be in the comparison.


.. _bpy.ops.curve.de_select_first:
.. _bpy.ops.curve.de_select_last:

(De)select First/Last
=====================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> (De)select First`,
               :menuselection:`Select --> (De)select Last`

These operators will toggle the selection of the first or last control point(s) of the curve(s)
in the object. This is useful to quickly find the start of a curve
(e.g. when using it as path...).


.. _bpy.ops.curve.select_next:
.. _bpy.ops.curve.select_previous:

Select Next/Previous
====================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Next`, :menuselection:`Select --> Select Previous`

These operators will select the next or previous control point(s),
based on the current selection
(i.e. the control points following or preceding the selected ones along the curve).
In case of a cyclic curve, the first and last points are not considered as neighbors.


Pick Shortest Path
==================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Menu Search --> Pick Shortest Path`
   :Shortcut:  :kbd:`Ctrl-LMB`

Selects the curve segments between two control points: the active and the one under the cursor.
In the case of a closed curve, the shortest path will be selected.


## Structure


*********
Structure
*********

Splines
=======

Splines are a substructure of curves and are the individual elements that make curve objects.
A curve object can be composed of several different splines,
just like mesh objects can have different discontinuous meshes under the same object.
A spline defines the shape of the curve and can be transformed by altering its `Control Points`_.
Splines come in three distinct types, which are described in `Spline Types`_.
Each spline type has a slightly different algorithm for computing how bends in the spline are represented.

Splines have their own separate properties from curves and can be altered
by selecting the spline in Edit Mode and using
the :doc:`Active Spline </modeling/curves/properties/active_spline>` panel.


Control Points
--------------

Similar to meshes splines have control points or vertices.
Control points connect to other control points to form splines.
Control points can be :doc:`selected </modeling/curves/selecting>`
and transformed to alter the resulting shape of the spline.

.. seealso::

   :doc:`Curve Editing </modeling/curves/editing/index>`


.. _curve-spline-types:

Spline Types
============

Poly
----

Poly splines are the most simple spline type as they do not
interpolate the shape of the curve between control points.

Poly Curves are used when :ref:`converting meshes to curves <bpy.ops.object.convert>`.
Because they do not interpolate the shape,
Poly splines are able to give an accurate representation of the original mesh object.

This is the primary use case of splines, most of the time `Bézier`_ or `NURBS`_
splines are used instead; both of which interpolate the shape and give smooth results.


.. _curve-bezier:

Bézier
------

The main elements used in editing Bézier curves are the control points and handles.
A segment (the actual curve) is found between two control points.
The handles define the curvature of the segment.

In the image below,
the control points can be found in the middle of the pink line,
while the handles comprise the extensions from the control point.
The arrows visualize the normals of the curve, which indicate i.e.
the direction and the tilt.

.. figure:: /images/modeling_curves_structure_control-points-handles.png
   :align: center

   Bézier Curve in Edit Mode.


.. _curve-bezier-handle-type:

Handle Types
^^^^^^^^^^^^

There are four Bézier curve handle types.
They can be accessed by pressing :kbd:`V` and selecting from the list that appears.

.. figure:: /images/modeling_curves_structure_bezier-handle-types.png
   :align: right

   Bézier Curve Handle Types.

.. _curve-handle-type-auto:

Automatic (yellow handles)
   This handle has a completely automatic length and direction
   which is set by Blender to ensure the smoothest result.
   These handles convert to *Aligned* handles when moved.
Vector (green handles)
   Both parts of a handle always point to the previous handle or the next handle which allows
   you to create curves or sections thereof made of straight lines or with sharp corners.
   Vector handles convert to *Free* handles when moved.
Aligned (purple handles)
   These handles always lie in a straight line,
   and give a continuous curve without sharp angles.
Free (black handles)
   The handles are independent of each other.

.. note::
   When a control point is selected, its handles are overlaid with a red hilight
   that changes their color. For example, Vector handles that are normally green
   will look yellow when selected, which can make it difficult to distinguish
   them from unselected Automatic handles.

   If you prefer not to have this color change, you can disable it by opening the Theme
   preferences, finding the entry :menuselection:`3D Viewport --> Active Spline`,
   and changing it to black. From then on, selected curve handles will simply look
   a bit brighter than unselected ones.

.. _curve-nurbs:

NURBS
-----

N.U.R.B.S. is the abbreviation for Non-Uniform Rational B-Splines.
One of the major differences between Bézier objects and NURBS objects is that Bézier curves
are approximations. For example, a Bézier circle is an *approximation* of a circle,
whereas a NURBS circle is an *exact* circle.
NURBS theory can be a *very* complicated topic. For an introduction,
please consult the `Wikipedia page <https://en.wikipedia.org/wiki/NURBS>`__.

.. _curves_structure_nurbs_weight:

NURBS spline control points are different than other spline types because they have a special weight property.
This weight property controls how much influence the control point has on the surface.
This weight should not be confused with the :ref:`Goal Weight <curves-weight>`,
which is used only for soft body simulations.
The NURBS control point weight can be adjusted in the *W* number field of
the :doc:`Transform panel </modeling/curves/editing/transform_panel>`.

.. note::

   If all the control points have the same *Weight* then each effectively cancels each other out.
   It is the difference in the weights that cause the curve to move
   towards or away from a control point.


## Control Points


**************
Control Points
**************

.. _bpy.ops.curve.extrude_move:
.. _modeling-curves-extrude:

Extrude Curve and Move
======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Extrude Curve and Move`
   :Shortcut:  :kbd:`E`

Extrudes points by duplicating the selected points, which then can be moved,
and connecting those points back to the original curve creating a continuous curve.


.. _bpy.ops.curve.make_segment:
.. _modeling-curves-make-segment:

Make Segment
============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Make Segment`
   :Shortcut:  :kbd:`F`

Connects two disconnected control points.
The selection must be loose points, or the first/last point of a curve, then press :kbd:`F`.
If the points belong to different curves, these are joined by a segment to become a single curve.

.. list-table::

   * - .. figure:: /images/modeling_curves_editing_control-points_two-curves.png

          Two curves before.

     - .. figure:: /images/modeling_curves_editing_curve_make-segment.png

          Curve after joining.

Note that you can only join curves of the same type (i.e. Bézier with Bézier, NURBS with NURBS).
Additionally, you can close a curve by toggling cyclic.


.. _bpy.ops.transform.tilt:
.. _modeling-curve-tilt:

Tilt
====

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Tilt`
   :Menu:      :menuselection:`Control Points --> Tilt`
   :Shortcut:  :kbd:`Ctrl-T`

This setting controls how the normals (visualized as arrows)
twist around each control point -- so it is only relevant with 3D curves!
The tilt will be interpolated from point to point (you can check it with the normals).

.. figure:: /images/modeling_curves_editing_control-points_extrude-mean-tilt.png
   :align: center
   :width: 50%

   30 degree Mean Tilt of all control points.


.. _bpy.ops.curve.tilt_clear:

Clear Tilt
==========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Clear Tilt`
   :Shortcut:  :kbd:`Alt-T`

You can also reset the tilt to its default value (i.e. perpendicular to the original curve plane).
With NURBS, the tilt is always smoothly interpolated. However, with Bézier,
you can choose the :ref:`interpolation algorithm <bpy.types.Spline.tilt_interpolation>`.


.. _bpy.ops.curve.handle_type_set:

Set Handle Type
===============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Set Handle Type`
   :Shortcut:  :kbd:`V`

Handle types are a property of :ref:`Bézier curves <curve-bezier>` and
can be used to alter features of the curve.
For example, switching to *Vector handles* can be used to create curves with sharp corners.
Read the :ref:`Bézier curves <curve-bezier-handle-type>` page for more details.

Toggle Free/Align
   Additionally, this operator can be used to toggle between Free and Aligned handle types.


.. _bpy.ops.curve.normals_make_consistent:

Recalculate Handles
===================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Recalculate Handles`
   :Shortcut:  :kbd:`Shift-N`

The *Recalculate Handles* operator rotates the selected control point's handle to be tangential to the curve.
This can be used to make curves smoother and more consistent looking.

Length
   Recalculates the length of the handles so they are all the same length.


.. _bpy.ops.curve.smooth:

Smooth
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Smooth`

For Bézier curves, this smoothing operation reduces the distance between
the selected control point(s) and their neighbors,
while keeping the neighbors anchored. Does not effect control point tangents.

.. figure:: /images/modeling_curves_editing_control-points_smoothing-1.png

   Original, unsmoothed Curve.

.. figure:: /images/modeling_curves_editing_control-points_smoothing-2.png

   Entire curve smoothed over 20 times by holding :kbd:`Shift-R` to repeat last step.

.. figure:: /images/modeling_curves_editing_control-points_smoothing-3.png

   Only three control points in the center smoothed over 20 times.


.. _bpy.ops.curve.smooth_tilt:

Smooth Curve Tilt
=================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Smooth Curve Tilt`

The *Smooth Curve Tilt* operator interpolates the *Tilt* value for the selected control points.
This will reduce sharp changes in the curve's *Tilt* and give a smooth transition between points.


.. _bpy.ops.curve.smooth_radius:

Smooth Curve Radius
===================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Smooth Curve Radius`

The *Smooth Curve Radius* operator interpolates the *Radius* value for the selected control points.
This will reduce sharp changes in the curve's *Radius* and give a smooth transition between points.


.. _bpy.ops.curve.smooth_weight:

Smooth Curve Weight
===================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Smooth Curve Weight`

The *Smooth Curve Weight* operator interpolates the *Weight* value for the selected control points.
This will reduce sharp changes in the curve's *Weight* and give a smooth transition between points.


Hooks
=====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Hooks`
   :Shortcut:  :kbd:`Ctrl-H`

:doc:`Hooks </modeling/modifiers/deform/hooks>` can be added to control one or more points with other objects.


Make Vertex Parent
==================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Make Vertex Parent`
   :Shortcut:  :kbd:`Ctrl-P`

You can make other selected objects :ref:`children <object-parenting>`
of one or three control points, as with mesh objects.

To select a mesh (that is in view) while editing a curve, :kbd:`Ctrl-P` click on it.
Select either one or three control points,
then :kbd:`Ctrl-LMB` the object and use :kbd:`Ctrl-P` to make a vertex parent.
Selecting three control points will make the child follow
the median point between the three vertices. An alternative would be to use
a :doc:`Child Of constraint </animation/constraints/relationship/child_of>`.
See also the :doc:`Curve modifier </modeling/modifiers/deform/curve>`.


## Curve


*****
Curve
*****

This page covers the basics of curve editing.


.. _modeling-curves-transform:

Transform
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Transform`

A Bézier curve can be edited by transforming the locations of both control points and handles.
NURBS curve on the other hand have only control points.

Move, Rotate, Scale
   Like other elements in Blender, curve control points and handles can be
   moved, rotated, or scaled as described in
   :doc:`Basic Transformations </scene_layout/object/editing/transform/introduction>`.
To Sphere, Shear, Bend, Push/Pull, Warp, Randomize
   The transform tools are described in
   the :doc:`Transformations </modeling/meshes/editing/mesh/transform/index>` sections.
Move/Scale Texture Space
   Like other objects, curves have textures spaces which can be
   :ref:`edited <properties-texture-space-editing>`.


.. _modeling-curve-radius:

Radius
------

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Radius`
   :Menu:      :menuselection:`Curve --> Transform --> Radius`
   :Shortcut:  :kbd:`Alt-S`

Controls the width of the extrusion along the "spinal" curve.
The radius will be interpolated from point to point (you can check it with the normals).
The *Radius* of the points is set using the *Radius* transform tool. Or in the Sidebar *Transform* panel.

.. figure:: /images/modeling_curves_editing_curve_extrude-radius.png
   :align: center
   :width: 50%

   One control point radius set to zero.


Mirror
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Mirror`
   :Shortcut:  :kbd:`Ctrl-M`

The *Mirror* tool is also available, behaving exactly as with
:doc:`mesh vertices </modeling/meshes/editing/mesh/mirror>`.


Snap
====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Snap`
   :Shortcut:  :kbd:`Shift-S`

:doc:`Mesh snapping </editors/3dview/controls/snapping>` also works with curve components.
Both control points and their handles will be affected by snapping,
except for within itself (other components of the active curve).
Snapping works with 2D curves but points will be constrained to the local XY axes.


Spin
====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Spin`

The *Spin* operator only works for one dimensional :doc:`surface </modeling/surfaces/index>` objects.
Its use for curves is currently not possible,
the full feature is documented in :ref:`Surface editing <bpy.ops.curve.spin>`.


.. _bpy.ops.curve.duplicate_move:

Add Duplicate
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Add Duplicate`
   :Shortcut:  :kbd:`Shift-D`

Duplicates the selected control points, along with the curve segments implicitly selected (if any).
If only a handle is selected, the full point will be duplicated too.
The copy is selected so you can move it to another place.


.. _bpy.ops.curve.split:

Split
=====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Split`
   :Shortcut:  :kbd:`Y`

Splits a selected segment of a curve from the rest of the curve.
This curve can then be moved or altered without affecting the other curve.
If a single control point is selected the *Split* operator will create a new singular loose control point;
leaving the previously selected control point attached to the rest of the curve.


.. _bpy.ops.curve.separate:

Separate
========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Separate`
   :Shortcut:  :kbd:`P`

Separates curve objects that are made of multiple distinct curves into their own objects.

Note, if there is only one curve in a Curve object,
This operation will create a new Curve object with no control points.


.. _bpy.ops.curve.cyclic_toggle:

Toggle Cyclic
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Toggle Cyclic`
   :Shortcut:  :kbd:`Alt-C`

Toggles between an open curve and closed curve (Cyclic).
Only curves with at least one selected control point will be closed/open.
The shape of the closing segment is based on the start and end handles for Bézier curves,
and as usual on adjacent control points for NURBS.
The only time a handle is adjusted after closing is if the handle is an *Auto* one.
Fig. :ref:`fig-curve-editing-open-close` is the same Bézier curve open and closed.

This action only works on the original starting control point or the last control point added.
Deleting a segment(s) does not change how the action applies;
it still operates only on the starting and last control points. This means that
:kbd:`Alt-C` may actually join two curves instead of closing a single curve!
Remember that when a 2D curve is closed, it creates a renderable flat face.

.. _fig-curve-editing-open-close:

.. figure:: /images/modeling_curves_editing_curve_open-closed-cyclic.png

   Open and Closed curves.


.. _bpy.ops.curve.spline_type_set:

Set Spline Type
===============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Set Spline Type`

Converts splines in a curve object between Bézier, NURBS, and Poly curves.
Note, this is not a "smart" conversion, i.e. Blender does not try to keep the same shape,
nor the same number of control points. For example, when converting a NURBS to a Bézier,
each group of three NURBS control points become a unique Bézier one (center point and two handles).

.. seealso::

   :ref:`object-convert-to`/from Mesh.


.. _bpy.ops.curve.reveal:
.. _bpy.ops.curve.hide:
.. _curves-show-hide:

Show/Hide
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Show/Hide`
   :Shortcut:  :kbd:`Alt-H`, :kbd:`H`, :kbd:`Shift-H`

When in *Edit Mode*, you can hide and reveal elements from the display.
You can only show or hide control points, as segments are always shown,
unless all control points of the connected curve are hidden,
in which case the curve is fully hidden.

See :ref:`object-show-hide` in *Object Mode*.
See also the :doc:`/modeling/curves/curve_display` panel.


Cleanup
=======

.. _bpy.ops.curve.decimate:

Decimate Curve
--------------

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Clean Up --> Decimate Curve`

The *Decimate Curve* operator reduces the number of control points
while trying to maintain the curves original shape.
This operator works similar to its :ref:`mesh counterpart <bpy.ops.mesh.decimate>`.

Ratio
   The percentage of control points to remove.

.. note::

   This tool can only decimate Bézier curves.


.. _bpy.ops.curve.delete:

Delete
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Delete`
   :Shortcut:  :kbd:`X`, :kbd:`Delete`

Options for the *Delete* pop-up menu:

Vertices
   This will delete the selected control points, *without* breaking the curve
   (i.e. the adjacent points will be directly linked, joined, once the intermediary ones are deleted).
   Remember that NURBS order cannot be higher than its number of control points,
   so it might decrease when you delete some control point.
   Of course, when only one point remains, there is no more visible curve,
   and when all points are deleted, the curve itself is deleted.
Segment
   Deletes the segment that connects the selected control points and disconnecting them.


.. _bpy.ops.curve.dissolve_verts:

Dissolve Vertices
-----------------

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Delete --> Dissolve Vertices`
   :Shortcut:  :kbd:`Ctrl-X`

Deletes the selected control points, while the remaining segment
is fitted to the deleted curve by adjusting its handles.

.. list-table::

   * - .. figure:: /images/modeling_curves_editing_curve_make-segment.png

          Before deleting.

     - .. figure:: /images/modeling_curves_editing_curve_delete-vertices.png

          Deleting vertices.

   * - .. figure:: /images/modeling_curves_editing_curve_delete-segment.png

          Deleting segment.

     - .. figure:: /images/modeling_curves_editing_curve_dissolve-vertices.png

          Dissolve vertices.


## Index

.. _modeling-curves-editing-index:

###########
  Editing
###########

.. toctree::
   :maxdepth: 2

   transform_panel.rst
   curve.rst
   control_points.rst
   segments.rst
   other.rst


## Other


*****
Other
*****

This page describes other curve editing tools that are not accessible via the edit menus.


.. _bpy.ops.curve.spline_weight_set:
.. _modeling-curve-weight:

Set Goal Weight
===============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Context Menu --> Set Goal Weight`

Sets the curve's :ref:`Weight <curves-weight>` for the selected control point to the specified value.
If more than one control point is selected this will set the *Mean Weight*.


.. _bpy.ops.curve.vertex_add:

Add Vertex
==========

.. reference::

   :Mode:      Edit Mode
   :Shortcut:  :kbd:`Ctrl-RMB`

Interactively places new points with :kbd:`Ctrl-RMB` at the cursor position.
With the selection it deals in same manner as the *Extrude Curve and Move* tool.


## Segments


********
Segments
********

.. _bpy.ops.curve.subdivide:

Subdivide
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Segments --> Subdivide`

Curve subdivision simply subdivides all selected segments by adding one or
more control points between the selected segments.

Number of Cuts
   The number of subdivisions to perform.


.. _bpy.ops.curve.switch_direction:

Switch Direction
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Segments --> Switch Direction`

This tool will "reverse" the direction of any curve with at least one selected element
(i.e. the start point will become the end one, and *vice versa*).
This is mainly useful when using a curve as path, or using the bevel and taper options.


## Transform Panel

.. _modeling-curves-transform-panel:

***************
Transform Panel
***************

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Sidebar --> Transform`

When nothing is selected, the panel is empty.
When more than one vertex is selected, the median values are edited
and "Median" is added in front of the labels.

Control Point, Vertex
   The first controls (X, Y, Z) show the coordinates of the selected point or handle (vertex).
   In case of a NURBS curve, there is a fourth component available (W),
   which defines the :ref:`weight <curves_structure_nurbs_weight>`
   of the selected control point or the median weight.
Space
   The Space radio buttons let you choose if those coordinates are relative
   to the object origin (local) or the global origin (global).

   Global, Local

.. _curves-weight:

Weight
   Controls the "goal weight" of selected control points,
   which is used when a curve has :doc:`Soft Body </physics/soft_body/index>` physics,
   forcing the curve to "stick" to their original positions, based on the weight.
Radius
   Controls the width of the extrusion/bevel along the "spinal" curve.
   The radius will be interpolated from point to point (you can check it with the normals).
Tilt
   Controls how the normals (visualized as arrows)
   twist around each control point -- so it is only relevant with 3D curves!
   The tilt will be interpolated from point to point (you can check it with the normals).


## Active Spline

.. _bpy.types.Spline:

*************
Active Spline
*************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Properties --> Curve --> Active Spline`

The *Active Spline* panel is used in Edit Mode to control properties of the currently selected spline.


.. _spline-common-options:
.. _bpy.types.Spline.use_cyclic_u:
.. _bpy.types.Spline.resolution_u:
.. _bpy.types.Spline.use_smooth:

.. rubric:: Common Options

Cyclic U
   Closes the active spline.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_active-spline_nurbs-default.png

             Default NURBS curve.

        - .. figure:: /images/modeling_curves_properties_active-spline_nurbs-cyclic.png

             A NURBS curve with Cyclic applied.

Resolution U
   Alters the :ref:`resolution <bpy.types.Curve.resolution_u>`
   of each segment by changing the number of subdivisions.
Smooth
   Use :ref:`Smooth Shading <modeling-meshes-editing-normals-shading>` for any 3D geometry.


Poly
====

.. figure:: /images/modeling_curves_properties_active-spline_panel-poly.png

   Active Spline panel: Poly Spline.

Cyclic U
   See :ref:`Common Options <spline-common-options>`.
Smooth
   See :ref:`Common Options <spline-common-options>`.


.. _bpy.types.Spline.tilt_interpolation:
.. _bpy.types.Spline.radius_interpolation:

Bézier
======

.. figure:: /images/modeling_curves_properties_active-spline_panel-bezier.png
   :align: center

   Active Spline panel: Bézier Spline.

Cyclic U
   See :ref:`Common Options <spline-common-options>`.
Resolution U
   See :ref:`Common Options <spline-common-options>`.
Interpolation Tilt
   Alters how the tilt of a segment is calculated.
Radius
   Alters how the radius of a beveled curve is calculated.
   The effects are easier to see after :ref:`increasing the radius <modeling-curve-radius>`.
Smooth
   See :ref:`Common Options <spline-common-options>`.


.. _bpy.types.Spline.use_bezier_u:
.. _bpy.types.Spline.use_endpoint_u:
.. _bpy.types.Spline.order_u:

NURBS
=====

One of the characteristics of a NURBS object is the *knot vector*.
This is a sequence of numbers used to determine the influence of the control points on the curve.
While you cannot edit the knot vectors directly,
you can influence them through the *Endpoint* and *Bézier* options in the Active Spline panel.
Note that, the *Endpoint* and *Bézier* settings only apply to open NURBS curves.

.. figure:: /images/modeling_curves_properties_active-spline_panel-nurbs.png
   :align: center

   Active Spline: NURBS Spline.

.. _modeling-curve-knot:

Cyclic U
   See :ref:`Common Options <spline-common-options>`.
Bézier U
   Makes the NURBS curve act like a Bézier curve.
   The NURBS control points act like *Free* handles of Bézier curve.
Endpoint U
   Makes the curve contact the end control points.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_active-spline_nurbs-default.png

             Default NURBS curve.

        - .. figure:: /images/modeling_curves_properties_active-spline_nurbs-endpoint.png

             A NURBS curve with Endpoint enabled.

.. _modeling-curve-order:

Order U
   The order of the NURBS curve determines the area of influence of the control points over the curve.
   Higher order values means that a single control point has a greater
   influence over a greater relative proportion of the curve.
   The valid range of *Order* values is 2-6 depending on the number of control points present in the curve.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_active-spline_nurbs-default.png

             NURBS curves with orders of 4.

        - .. figure:: /images/modeling_curves_properties_active-spline_nurbs-order.png

             NURBS curves with orders of 2.

Resolution U
   See :ref:`Common Options <spline-common-options>`.
Smooth
   See :ref:`Common Options <spline-common-options>`.


## Geometry


********
Geometry
********

.. figure:: /images/modeling_curves_properties_geometry_panel.png
   :align: center

   Geometry panel.

.. _bpy.types.Curve.offset:

Offset
   Moves the extrusion parallel to the curve normals.

   .. figure:: /images/modeling_curves_properties_geometry_extrude-offset.png
      :width: 50%

      Bézier Circle -1 offset, 0.5 extrusion, 0.25 Bevel Depth, 10 Bevel resolution.

.. _bpy.types.Curve.extrude:

Extrude
   Will extrude the curve along both the positive and negative local Z axes.
   Turns a one-dimensional curve into a two-dimensional curve by giving it height.
   With a scale is the sum of both directions, perpendicular to the curve's normals.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_geometry_extrude-bezier-circle.png
             :width: 320px

             Bézier Circle 0.0 extrude (Edit Mode).

        - .. figure:: /images/modeling_curves_properties_geometry_extrude-after.png
             :width: 320px

             Extruded by 0.5 (Object Mode).

.. _bpy.types.Curve.taper_object:

Taper Object
   Tapering a curve causes it to get thinner towards one end.
   You can also alter the proportions of the Taper throughout the tapered object
   by moving/scaling/rotating the control points of the Taper Object.
   The taper curve is evaluated along the local X axis, using the local Y axis for width control.
   In order for this to work the Taper Object can only be another *open curve*.

   The details are:

   - The taper is applied independently to all curves of the extruded object.
   - Only the first curve in a *Taper Object* is evaluated, even if you have several separated segments.
   - The scaling starts at the first control point on the left
     and moves along the curve to the last control point on the right.
   - Negative scaling, (e.g. negative local Y on the taper curve) is possible as well.
     However, rendering artifacts may appear.
   - You may need to increase the curve resolution to see more detail of the taper.
   - The Taper Object is distributed by control points.
     Therefor unevenly spaced control points may likelier to stretch the shape of the taper.
     Subdividing segments causes those points to use a larger fraction of the overall taper shape.
   - With closed curves, the taper curve in *Taper Object* acts along the whole curve (perimeter of the object),
     not just the length of the object, and varies the extrusion depth. In these cases,
     you want the relative height of the *Taper Object*
     Taper curve at both ends to be the same, so that the cyclic point
     (the place where the endpoint of the curve connects to the beginning) is a smooth transition.

   .. hint::

      Editing the handles and control points of the Taper Object
      will instantly change the shape of the original object.

.. _bpy.types.Curve.taper_mode:

Taper Mode
   For curves using a *Taper Object*, this option defines
   how the effective curve radius is computed from the Taper Object.

   :Override: The curve radius is ignored and the effective radius is equal to the taper radius.
   :Multiply: The effective radius is computed by multiplying the taper radius with the curve radius.
   :Add: The effective radius is computed by adding the taper radius to the curve radius.

   .. list-table::
      Examples of a curve with a radius of zero on one end and a radius of one on the other end.

      * - .. figure:: /images/modeling_curves_properties_geometry_taper-mode-override.png

             Override mode.

        - .. figure:: /images/modeling_curves_properties_geometry_taper-mode-multiply.png

             Multiply mode.

        - .. figure:: /images/modeling_curves_properties_geometry_taper-mode-add.png

             Add mode.

.. _bpy.types.Curve.use_map_taper:

Map Taper
   For curves using a Taper Object and with modifications to the *Start/End Bevel Factor*
   the *Map Taper* option will apply the taper to the beveled part of the curve (not the whole curve).


.. _bpy.types.Curve.bevel:

Bevel
=====

Round
-----

.. _bpy.types.Curve.bevel_depth:

Depth
   Changes the size of the bevel.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_geometry_bevel-depth.png
             :width: 320px

             A curve with different Bevel depths applied (Depth of 0.05).

        - .. figure:: /images/modeling_curves_properties_geometry_bevel.png
             :width: 320px

             A curve with different Bevel depths applied (Depth of 0.25).

.. _bpy.types.Curve.bevel_resolution:

Resolution
   Alters the smoothness of the bevel.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_geometry_bevel-resolution.png
             :width: 320px

             A curve with different resolutions applied (Resolution of 1).

        - .. figure:: /images/modeling_curves_properties_geometry_bevel.png
             :width: 320px

             A curve with different resolutions applied (Resolution of 12).

.. _bpy.types.Curve.use_fill_caps:

Fill Caps
   Seals the ends of a beveled curve.


Object
------

.. _bpy.types.Curve.bevel_object:

Object
   Here you can specify a profile curve object (opened or closed) which will be extruded along the path curve.
   If the profile curve's :ref:`shape <bpy.types.Curve.dimensions>` is 3D,
   it will be projected to its local XY plane before the extrusion.
   You can check what the projected object looks like by switching its shape to 2D.

   .. important::

      Make sure the shape you want to extrude is in the Object's local XY plane.
      If it is in the local XZ or YZ plane, it will be reduced to a line when it is projected to the local XY plane.
      Because of this, the extruded shape will be a flat plane.

   .. note::
      If the selected curve has modifiers, these will not be taken into account.
      The extrusion will use the original curve shape. The reason for this behavior
      is that curves turn into meshes internally when they have modifiers on them,
      at which point they can't be used as bevel objects anymore.

      To work around this, you can disable beveling on the path curve, and instead
      add geometry nodes to it: retrieve the profile curve using an
      :doc:`/modeling/geometry_nodes/input/scene/object_info`, convert it from
      a mesh back into a curve using a
      :doc:`/modeling/geometry_nodes/mesh/operations/mesh_to_curve`,
      and finally pass both the path curve and the profile curve to a
      :doc:`/modeling/geometry_nodes/curve/operations/curve_to_mesh`.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_geometry_bevel-object.png
             :width: 320px

             A curve with a Bézier curve as the Bevel Object.

        - .. figure:: /images/modeling_curves_properties_geometry_extrude-bevel-object.png
             :width: 320px

             A curve with a Bézier circle as the Bevel Object.


Profile
-------

.. figure:: /images/modeling_modifiers_generate_bevel_profile-widget.png
   :align: right
   :width: 300px

   The custom profile widget.

This :ref:`ui-curve-widget` allows the creation of a user-defined profile with more complexity than
with the single profile parameter. The modal tool allows toggling the custom profile,
but the shape of the profile is only editable in the options panel after the operation is confirmed.

The profile starts at the bottom right of the widget and ends at the top left, as if it
were between two edges intersecting at a right angle. Control points are created in the widget and
then the path is sampled with the number of segments from the Bevel modifier.

.. note::

   The *Profile* curve widget stays active when miters are enabled
   because it still controls the shape of the miter profiles.

Presets
   The *Support Loops* and *Steps* presets are built dynamically depending on
   the number of segments in the bevel. If the number of segments is changed,
   the preset will have to be re-applied.

Sampling
   Samples will first be added to each control point, then if there are enough samples,
   they will be divided evenly between the edges. The *Sample Straight Edges* option toggles whether
   the samples are added to edges with sharp control points on either side. If there aren't enough samples
   to give each edge the same number of samples, they will just be added to the most curved edges.
   So it is recommended to use at least as many segments as there are control points.


Start & End Mapping
===================

.. _bpy.types.Curve.bevel_factor_start:
.. _bpy.types.Curve.bevel_factor_end:

Factor Start, End
   These options determine where to start/end the geometry of the curve.
   This allows to make a curve which is not fully covered with geometry.

   A Start value to 0.5 will start the geometry at 50%
   of the distance from the start of the curve (in effect shortening the curve).
   An End value of 0.75 will start the geometry at 25%
   of the distance from the end of the curve (again, shortening the curve).

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_geometry_bevel.png
             :width: 320px

             A curve with no *Factor Start, End*.

        - .. figure:: /images/modeling_curves_properties_geometry_bevel-start-end-factor.png
             :width: 320px

             A curve with a 0.6 End factor.

.. _bpy.types.Curve.bevel_factor_mapping_start:
.. _bpy.types.Curve.bevel_factor_mapping_end:

Mapping Start, End
   Allows to control the relation between the *Factor Start, End* (number between 0 and 1)
   and the rendered start and end point of the spline's geometry.

   :Resolution:
      Maps the start and end factor to the number of subdivisions of a spline (U resolution).
   :Segments:
      Maps the start and end factor to the length of its segments.
      Mapping to segments treats the subdivisions in each segment
      of a curve as if they would have all the same length.
   :Spline:
      Maps the start and end factor to the length of a spline.


Examples
========

.. TODO Add some "simple" extrusion examples.
        Add some "bevel" extrusion with *Radius* examples.

Open 2D Curve
-------------

The extrusion will create a "wall" or "ribbon" following the curve shape. If using a *Bevel Depth*,
the wall becomes a sort of slide or gutter.
If your normals are facing the wrong way you can switch their direction as shown
:ref:`here <bpy.ops.curve.switch_direction>`.

.. figure:: /images/modeling_curves_properties_geometry_extrude-open-curve.png
   :width: 320px

   Open 2D Curve with :kbd:`Alt-C`, fill set to none,
   zero offset, 0.5 extrusion, 0.25 Bevel Depth, 10 Bevel resolution.


Closed 2D Curve
---------------

This is probably the most useful situation, as it will quickly create a volume, with (by default)
two flat and parallel surfaces filling the two sides of the extruded "wall". You can remove one or both of these
faces by choosing the fill mode: both, front, back, or none.

The optional bevel depth will always create a 90 degree bevels here.

.. figure:: /images/modeling_curves_properties_geometry_extrude-closed-curve.png
   :width: 320px

   Closed 2D Curve, 0.5 extrude, 0.25 Bevel Depth, 10 Bevel resolution, Fill: Both.


3D Curve
--------

Here the fact that the curve is closed or not has no importance --
you will never get a volume with an extruded 3D curve, only a wall or ribbon, like with open 2D curves.

However, there is one more feature with 3D curves: the *Tilt* of the control points (see above).
It will make the ribbon twist around the curve to create a Möbius strip, for example.


Taper
-----

Let us taper a simple curve circle extruded object using a taper curve. Add a curve,
then exit *Edit Mode*. Add another one (a closed one, like a circle); call it "BevelCurve",
and enter its name in the *Bevel Object* field of the first curve
(*Curve* tab). We now have a pipe.
Add a third curve while in *Object Mode* and call it "TaperCurve".
Adjust the left control point by raising it up about 5 units.

Now return to the Object tab,
and edit the first curve's *Taper Object* field in the Geometry panel to reference the new taper curve
which we called "TaperCurve".
When you hit enter the taper curve is applied immediately,
with the results shown in Fig. :ref:`fig-curves-extrude-taper-curve`.

.. list-table::

   * - .. _fig-curves-extrude-taper-curve:

       .. figure:: /images/modeling_curves_properties_geometry_extrude-bevel-object.png
          :width: 320px

          Circle curve set as Bevel Object.

     - .. figure:: /images/modeling_curves_properties_geometry_extrude-taper-object.png
          :width: 320px

          Taper extruded curve.

You can see the *taper curve* being applied to the *extruded object*.
Notice how the pipe's volume shrinks to nothing as the taper curve goes from left to right.
If the taper curve went below the local Y axis the pipe's inside would become the outside,
which would lead to rendering artifacts.
Of course as an artist that may be what you are looking for!

.. _fig-curves-extrude-taper1:

.. figure:: /images/modeling_curves_properties_geometry_extrude-taper-curve-closer.png

   Taper example 1.

In Fig. :ref:`fig-curves-extrude-taper1`
you can clearly see the effect the left taper curve has on the right curve object.
Here the left taper curve is closer to the object origin and
that results in a smaller curve object to the right.

.. _fig-curves-extrude-taper2:

.. figure:: /images/modeling_curves_properties_geometry_extrude-taper-curve-away.png

   Taper example 2.

In Fig. :ref:`fig-curves-extrude-taper2` a control point in the taper curve to the left is moved away from
the origin and that gives a wider result to the curve object on the right.

.. _fig-curves-extrude-taper3:

.. figure:: /images/modeling_curves_properties_geometry_extrude-taper-curve-irregular.png

   Taper example 3.

In Fig. :ref:`fig-curves-extrude-taper3` we see the use of a more irregular taper curve applied to a curve circle.

.. figure:: /images/modeling_curves_properties_geometry_extrude-bevel-curve-tilt.png

   Bevel extrusion with Tilt example.


## Index


##############
  Properties
##############

.. toctree::
   :maxdepth: 2

   shape.rst
   geometry.rst
   path_animation.rst
   active_spline.rst


## Path Animation

.. _curve-path-animation:

**************
Path Animation
**************

The *Path Animation* settings can be used to determine how child objects move along a certain path.

.. note::

   This feature is deprecated, but still available.
   A more future-proof method is the :doc:`/animation/constraints/relationship/follow_path`.

.. figure:: /images/modeling_curves_properties_path-animation_panel.png
   :align: center

   Path Animation panel.

.. _bpy.types.Curve.path_duration:

Frames
   The number of frames that are needed to traverse the path,
   defining the maximum value for the *Evaluation Time* setting.

.. _bpy.types.Curve.eval_time:

Evaluation Time
   Parametric position along the length of the curve that object following it should be at
   (the position is evaluated by dividing by the *Frames* value).
   By default, it is linked to the global frame number,
   but could be keyframed to give more control over the path animation.

.. _bpy.types.Curve.use_path_clamp:

Clamp
   Clamp the curve path children so they can't travel past the start/end point of the curve.

.. _bpy.types.Curve.use_path_follow:

Follow
   Make the curve path children rotate along the curvature of the path.


Example
=======

This example shows you how setup a *Path Animation*.

#. Add an object you want to animate and a path along which this object will move.
   In this example it's the *Monkey* and the *Bézier Circle*.
#. To parent the monkey to the Bézier circle, first select the monkey then the curve
   (so that the curve is the active object), press :kbd:`Ctrl-P` and select *Follow Path*.
   It will automatically animate *Evaluation Time* and activate *Follow* option
   in the *Path Animation* panel.
#. Select the monkey and
   :doc:`Clear Origin </scene_layout/object/editing/clear>` to reset its offset.
#. You can change the orientation of the monkey by changing
   the :doc:`Tracking Axis </scene_layout/object/properties/relations>`.

.. list-table::

   * - .. figure:: /images/modeling_curves_properties_path-animation_example-1.png

          Monkey parented to the Bézier Circle.

     - .. figure:: /images/modeling_curves_properties_path-animation_example-2.png

          The final result.


## Shape


*****
Shape
*****

.. figure:: /images/modeling_curves_properties_shape_curves-shape-panel.png
   :align: center

   Shape panel.

.. _bpy.types.Curve.dimensions:

Dimensions
   By default, new curves are set to be 3D, which means that control points can be placed anywhere in 3D space.
   Curves can also be set to 2D which constrain the control points to the curve's local XY axis.

.. _bpy.types.Curve.resolution_u:
.. _bpy.types.Curve.render_resolution_u:

Resolution Preview/Render U
   The *resolution* property defines the number of points that are computed between every pair of control points.
   Curves can be made more or less smooth by increasing and decreasing the resolution respectively.
   The *Preview U* setting determines the resolution in the 3D Viewport while the *Render U* setting
   determines the curve's render resolution. If *Render U* is set to zero (0),
   then the *Preview U* setting is used for both the 3D Viewport and render resolution.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_shape_resolution-3.png

             Curves with a resolution of 3.

        - .. figure:: /images/modeling_curves_properties_shape_resolution-12.png

             Curves with a resolution of 12.

.. _bpy.types.Curve.twist_mode:

Twist Method
   A 3D curve has control points that are not located on the curve's local XY plane.
   This gives the curve a twist which can affect the curve normals.
   You can alter how the twist of the curve is calculated by choosing from
   *Minimum, Tangent* and *Z-Up* options from the select menu.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_shape_resolution-12.png

             Curves with a twist of Minimum.

        - .. figure:: /images/modeling_curves_properties_shape_twisting.png

             Curves with a twist of Tangent.

.. _bpy.types.Curve.twist_smooth:

Smooth
   Interactively removes twists from the curve. This is useful if a curve has noticeable "kinks"
   from over twisting; which can be possible when converting meshes to curves.

.. _bpy.types.Curve.fill_mode:

Fill Mode
   Fill determines the way a curve is displayed when it is beveled (see below for details on Beveling).
   When set to *Half* the curve is displayed as half a cylinder.

   .. list-table::

      * - .. figure:: /images/modeling_curves_properties_shape_fill-half.png

             Curves with a fill of Half.

        - .. figure:: /images/modeling_curves_properties_shape_fill-full.png

             Curves with a fill of Full.

.. _bpy.types.Curve.use_fill_deform:

Fill Deformed
   Fills the curve after applying all modifications that might deform the curve (i.e. shape keys and modifiers).

.. _curve-shape-path-curve-deform:

Curve Deform
   .. _bpy.types.Curve.use_radius:

   Radius
      Causes the deformed object to be scaled by the set curve radius.
      Utilized when using a curve as a path or when using the :doc:`/modeling/modifiers/deform/curve`.

   .. _bpy.types.Curve.use_stretch:

   Stretch
      The *Stretch* curve option allows you to let the mesh object stretch, or squeeze, over the entire curve.
      To get the expected result, use this together with the *Bounds Clamp* option.
      Utilized when using the :doc:`/modeling/modifiers/deform/curve`.

   .. _bpy.types.Curve.use_deform_bounds:

   Bounds Clamp
      When this option is enabled, the object and mesh offset along the deformation axis is ignored.
      This can be useful with the *Stretch* option or when using a negative axis.
      Utilized when using the :doc:`/modeling/modifiers/deform/curve`.


## Draw

.. _bpy.ops.curve.draw:

****
Draw
****

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Draw`

The Curve draw tool allows you to free-hand draw curves.


Tool Settings
=============

.. figure:: /images/modeling_curves_tools_draw_curve-stroke-panel.png
   :align: right

   Curve Stroke panel.

Type
   Type of curve to use for drawing.

   :Poly:
      Bézier Curve with straight line segments (auto handles).
   :Bézier:
      Tolerance
         Lower values give a result that is closer to the drawing stroke,
         while higher values give more smoothed results.

      Method
         :Refit: Incrementally refits the curve (gives best results).
         :Split: Splits the curve until the tolerance is met (gives a better drawing performance).

      Detect Corners
         Detects corners while drawing based on a specified angle;
         Any angles above the specified value are considered corners.
         If a corner is detected, the curve uses non-aligned handles
         for the corner resulting in a more crisp corner.

Taper Start, End
   Taper factor for the radius of the start and end points along the curve.

Radius Min
   Minimum radius when the minimum pressure is applied (also the minimum when tapering).
Max
   Radius to use when the maximum pressure is applied (or when a tablet is not used).

Use Pressure
   Uses stylus pressure to control the radius of the curve.

Depth
   Controls where and how the curves are drawn.

   :Cursor:
      Uses the depth under the cursor to draw curves.
   :Surface:
      Used to draw on top of other objects.

      Offset
         Distance to offset the curve from the surface.
      Absolute Offset
         Applies a fixed offset (does not scale by the curve radius).
      Only First
         Only uses the start of the stroke for the depth.
      Plane
         The orientation plane to draw on, available when *Only First* is enabled.

         :Normal to Surface: Draws aligned to the surface.
         :Tangent to Surface: Draws perpendicular to the surface.
         :View: Draws aligned to the viewport.


Options
=======

After the tool is run, these options are available in the :ref:`bpy.ops.screen.redo_last` panel.

Error
   Error distance in object units. This can be seen similar to a subdivision rate for the curve.
   Lower values give a result that is closer to the drawing stroke while higher values give more smoothed results.
Fit Method
   :Refit: Incrementally refits the curve (gives best results).
   :Split: Splits the curve until the tolerance is met (gives a better drawing performance).
Corner Angle
   Any angles above this are considered corners.
Cyclic
   Toggles whether or not the curve is :term:`Cyclic`.


## Index


#########
  Tools
#########

.. toctree::
   :maxdepth: 2

   toolbar.rst


Types
=====

.. toctree::
   :maxdepth: 1

   draw.rst
   pen.rst


## Pen

.. _bpy.ops.curve.pen:

*********
Curve Pen
*********

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Curve Pen`

The Curve Pen tool allows you to construct and edit curves rapidly.


Usage
=====

.. figure:: /images/modeling_curves_tools_pen_curve-properties.jpg
   :align: right

   Curve Pen Preferences

The following preferences can be configured from:
:menuselection:`Preferences --> Keymap --> 3D View --> Curve --> 3D View Tool: Edit Curve, Curve Pen`.

Extrude Point
   :kbd:`LMB` click to add a new point connected to an existing point.

Extrude Handle Type
   The :ref:`handle type <curve-bezier-handle-type>` of the extruded points.
   Can be either *Vector* or *Auto*.
   However, the handle type switches to *Align* when handles are moved (See *Move Point*).

Delete Point
   :kbd:`Ctrl-LMB` click on an existing point to delete it.

Insert Point
   :kbd:`Ctrl-LMB` click on a :term:`Curve Segment` to insert a new control point between the two
   adjacent control points. :kbd:`Ctrl-LMB` click and drag to control the handles of the inserted points.

Move Segment
   :kbd:`LMB` drag on a segment in between two control points to adjust the handles, changing the shape of the
   curve without affecting the location of any control points.

Select Point
   :kbd:`LMB` click to select a single point or handle at a time.

Move point
   :kbd:`LMB` drag to move existing points or handles. With an endpoint of a spline selected,
   click and drag on empty space to *Extrude Point* and move the handle at the same time.

Close Spline
   Make the spline :term:`Cyclic` by clicking the endpoints consecutively.

Close Spline Method
   The condition for *Close Spline* to activate.

   :None: Turn off the Close Spline functionality.
   :On Press:
      Close the spline on mouse down. With this option, you may click and drag to adjust the handles of the endpoint.
   :On Click:
      Activate on mouse release. With this option, the *Close Spline* functionality will not be
      triggered on click and drag.

Toggle Vector
   Double :kbd:`LMB` click on a handle to switch handle between *Vector* and *Auto* handle types.
   Can be used to easily switch between sharp corners and smooth curves.

Cycle Handle Type
   Double :kbd:`LMB` click on the control point to cycle through all handle types.


Hotkeys
=======

Free-Align Toggle
   Hold :kbd:`LeftShift` while dragging a handle to switch between ``Free`` and ``Align`` handle types.
   Can be used to create sharp corners along the curve.

Move Adjacent Handle
   Hold :kbd:`LeftCtrl` while dragging a handle to move the closer handle of the adjacent control point.
   Can be helpful to make adjustments to newly created curve segments.

Move Entire
   Hold :kbd:`Spacebar` while dragging a handle to move the entire point.

Link Handles
   Press :kbd:`RightCtrl` while dragging a handle to mirror its movement on the opposite handle of the same point.

Lock Handle Angle
   Hold :kbd:`LeftAlt` while dragging a handle to limit the movement of the handle to its current direction,
   so only its length can be adjusted.


## Toolbar

.. _curve-toolbar-index:

*******
Toolbar
*******

Curve Edit Mode tools:

:ref:`Select <tool-select-tweak>`
   Select or move.

   :ref:`Select Box <tool-select-box>`
      Select objects by dragging a box.

      All objects that intersect the box will be selected.
   :ref:`Select Circle <tool-select-circle>`
      Select objects by dragging a circle. All objects that intersect the path of
      the circle will be selected.
   :ref:`Select Lasso <tool-select-lasso>`
      Select objects by drawing a lasso.

Cursor
   Change the location of the 3D Cursor.
Move
   Translation tool.
Rotate
   Rotation tool.
Scale
   Scale tool.

   :ref:`Scale Cage <tool-scale-cage>`
      Change the scale of an object by controlling its cage.

Transform
   Tool to adjust the objects translation, rotations and scale.

:ref:`Annotate <tool-annotate-freehand>`
   Draw free-hand annotation.

   :ref:`Annotate Line <tool-annotate-line>`
      Draw straight line annotation.
   :ref:`Annotate Polygon <tool-annotate-polygon>`
      Draw a polygon annotation.
   :ref:`Annotate Eraser <tool-annotate-eraser>`
      Erase previous drawn annotations.

:ref:`Measure <tool-measure>`
   Measure distances in the scene.

:ref:`Draw <bpy.ops.curve.draw>`
   Free-hand drawing of new curves.

:ref:`Curve Pen <bpy.ops.curve.pen>`
   Construct and edit splines.

:ref:`Extrude <modeling-curves-extrude>`
   Extrude the curve by adding new control points.

:ref:`Radius <modeling-curve-radius>`
   Control the radius value of the control points.

:ref:`Tilt <modeling-curve-tilt>`
   Control the rotation value of the control points around the curve's axis.

Randomize
   Move selected control points in pseudo-random directions.


## Index


################
  Curves (New)
################

.. toctree::
   :maxdepth: 2

   tools/index.rst
   primitives.rst
   selecting.rst
   editing/index.rst
   properties.rst


## Primitives


**********
Primitives
**********

.. _bpy.ops.object.curves_empty_hair_add:

Empty Hair
==========

Adds an empty high-performance curves object and automatically:

* Assigns the active object as the :doc:`Surface </sculpt_paint/curves_sculpting/introduction>`.
* Set the surface object as the parent of the new object.
* Adds a Geometry Nodes modifier to deform the curves on the surface.

Fur
===

Adds a fur setup to the selected objects.
The fur setup is based on :doc:`/modeling/geometry_nodes/index` and built with
:doc:`Hair Node Groups </modeling/geometry_nodes/hair/index>` that come with Blender as bundled assets.

See :ref:`bpy.ops.object.quick_fur` for more information.


## Properties


**********
Properties
**********

Hair Curves have different properties than regular Curve objects;
these properties are documented below.


Attributes
==========

The *Attributes* panel contains different hair characteristics such as the position and color of hair strands.

Use the :ref:`List View <ui-list-view>` to manage attributes.

.. seealso::

   See the :doc:`Attribute Reference </modeling/geometry_nodes/attributes_reference>` for details on attributes.


Surface
=======

.. _bpy.types.Curves.surface:

Surface
   The curve surface is an optional mesh that is used to anchor the curves, and behave as a scalp for hair grooming.
   When adding a new Curves object via the **Add Menu** the active object is automatically set as the surface.

   To set a new surface press :kbd:`Ctrl-P` and select *Object (Attach Curves to Surface)*
   in the *Set Parent To* pop-up menu. This option can be seen as part of the Curves settings in the Properties
   Editor.

   .. figure:: /images/sculpt-paint_sculpting_curves-surface.png

.. _bpy.types.Curves.surface_uv_map:

Surface UV Map
   The name of the attribute on the surface mesh used to define the attachment of each curve.

   .. note::

      If the UV from the surface changed,
      run :ref:`Snap to Nearest Surfaces <bpy.ops.curves.snap_curves_to_surface>` to re-attach the curves.


## Selecting


*********
Selecting
*********

Hair curves, while similar to regular curves are a bit different and have their own selection tools.
Many of these match their regular curve tools but are implemented differently
All hair curve selection operators are documented below for completeness.

These selection operators work in both Sculpt and Edit modes.


.. _bpy.ops.curves.set_selection_domain:

Selection Modes
===============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`3D Viewport Header --> Select Mode`
   :Shortcut:  :kbd:`1`, :kbd:`2`

   Note, this is only supported for "Hair Curves".

Selection modes limits selection operators to certain curve domains.
This feature is makes it easy to select whole segments at once, or to give more granular control over editing.

:Control Points:
   Allows selection of individual control points.
:Curve:
   Limits selection to whole curve segments.


.. _bpy.ops.curves.select_all:

All
===

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> All`
   :Shortcut:  :kbd:`A`

Select all selectable elements.


None
====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> None`
   :Shortcut:  :kbd:`Alt-A`

Deselect all elements, but the active element stays the same.


Invert
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Invert`
   :Shortcut:  :kbd:`Ctrl-I`

Selects all the geometry that are not selected, and deselect currently selected components.


.. _bpy.ops.curves.select_random:

Select Random
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Random`

Select Random control points.

Seed
   :term:`Seed` used by the pseudo-random number generator.
Probability
   Selects the defined percentage of control points.


.. _bpy.ops.curves.select_more:
.. _bpy.ops.curves.select_less:

Select More/Less
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> More/Less`
   :Shortcut:  :kbd:`Ctrl-NumpadPlus`, :kbd:`Ctrl-NumpadMinus`

Their purpose, based on the currently selected control points, is to reduce or enlarge this selection.

More
   For each selected control point, select *all* its linked points (i.e. one or two...).
Less
   For each selected control point, if *all* points linked to this point are selected, keep this one selected.
   Otherwise, deselect it.

This implies two points:

#. When *all* control points of a curve are selected, nothing will happen
   (as for *Less*, all linked points are always selected, and of course, *More* cannot add any).
   Conversely, the same goes when no control points are selected.
#. Second, these tools will never "go outside" of a curve
   (they will never "jump" to another curve in the same object).


.. _bpy.ops.curves.select_linked:

Select Linked
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Linked`
   :Shortcut:  :kbd:`L`, :kbd:`Ctrl-L`, :kbd:`Shift-L`

:kbd:`L` (or :kbd:`Ctrl-L` for all) will add to the selection the cursor's nearest control point,
and all the linked ones, i.e. all points belonging to the same curve. Note that for Bézier,
using :kbd:`L` with a handle selected will select the whole control point and all the linked ones.


Select Endpoints
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Endpoints`

Select endpoints of curves.
Only supported in the Control Point selection mode.


## Control Points


**************
Control Points
**************

.. _bpy.ops.curves.extrude_move:

Extrude Curve and Move
======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Extrude Curve and Move`
   :Shortcut:  :kbd:`E`

Extrudes points by duplicating the selected points, which then can be moved,
and connecting those points back to the original curve creating a continuous curve.


.. _modeling-curves-tilt:

Tilt
====

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Tilt`
   :Shortcut:  :kbd:`Ctrl-T`

This setting controls how the normals twist around each control point.
The tilt will be interpolated from point to point (you can check it with the normals).


.. _bpy.ops.curves.tilt_clear:

Clear Tilt
==========

.. reference::

   :Mode:      Edit Mode
   :Shortcut:  :kbd:`Alt-T`

You can also reset the tilt to its default value (i.e. perpendicular to the original curve plane).


.. _bpy.ops.curves.handle_type_set:

Set Handle Type
===============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Control Points --> Set Handle Type`
   :Shortcut:  :kbd:`V`

Handle types are a property of :ref:`Bézier curves <curve-bezier>` and
can be used to alter features of the curve.
For example, switching to *Vector handles* can be used to create curves with sharp corners.
Read the :ref:`Bézier curves <curve-bezier-handle-type>` page for more details.


## Curves


******
Curves
******

Transform
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curves --> Transform`

A curves objects can be edited by transforming the locations of control points.

Move, Rotate, Scale
   Like other elements in Blender, control points can be moved, rotated, or scaled as described in
   :doc:`Basic Transformations </scene_layout/object/editing/transform/introduction>`.
To Sphere, Shear, Bend, Push/Pull
   The transform tools are described in
   the :doc:`Transformations </modeling/meshes/editing/mesh/transform/index>` sections.


.. _modeling-curves-radius:

Radius
------

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Radius`
   :Menu:      :menuselection:`Curves --> Transform --> Radius`
   :Shortcut:  :kbd:`Alt-S`

The Radius allows you to directly control the width of the extrusion along the "spinal" curve.
The radius will be interpolated from point to point (you can check it with the normals).
The *Radius* of the points is set using the *Radius* transform tool. Or in the Sidebar *Transform* panel.

.. figure:: /images/modeling_curves_editing_curve_extrude-radius.png
   :align: center
   :width: 50%

   One control point radius set to zero.


.. _bpy.ops.curves.duplicate_move:

Duplicate
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curves --> Duplicate`
   :Shortcut:  :kbd:`Shift-D`

This operator duplicates the selected control points,
along with the curve segments implicitly selected (if any).
.. If only a handle is selected, the full point will be duplicated too.
The copy is selected so you can move it to another place.


.. _bpy.ops.curves.delete:

Delete
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curves --> Delete`
   :Shortcut:  :kbd:`X`

The Delete operator can remove Control Points or Segments.
Deleting can be used to make curves shorter or simplify
segments by deleting control points in the mid section of a segment.


Toggle Cyclic
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Toggle Cyclic`
   :Shortcut:  :kbd:`Alt-C`

Toggles between an open curve and closed curve (Cyclic).
Only curves with at least one selected control point will be closed/open.
The shape of the closing segment is based on the start and end handles for Bézier curves,
and as usual on adjacent control points for NURBS.
The only time a handle is adjusted after closing is if the handle is an *Auto* one.
Fig. :ref:`fig-curves-editing-open-close` is the same Bézier curve open and closed.

This action only works on the original starting control point or the last control point added.
Deleting a segment(s) does not change how the action applies;
it still operates only on the starting and last control points. This means that
:kbd:`Alt-C` may actually join two curves instead of closing a single curve!
Remember that when a 2D curve is closed, it creates a renderable flat face.

.. _fig-curves-editing-open-close:

.. figure:: /images/modeling_curves_editing_curve_open-closed-cyclic.png

   Open and Closed curves.


.. _bpy.ops.curves.spline_type_set:

Set Curve Type
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curves --> Set Curve Type`

Converts splines in a curve object between Bézier, NURBS, and Poly curves.
Note, this is not a "smart" conversion, i.e. Blender does not try to keep the same shape,
nor the same number of control points. For example, when converting a NURBS to a Bézier,
each group of three NURBS control points become a unique Bézier one (center point and two handles).

Handles
   Take handle information into account in the conversion


## Index


###########
  Editing
###########

The curves can be edited via :doc:`sculpting </sculpt_paint/curves_sculpting/introduction>`.

Curves objects also have basic editing support in "Edit Mode".

.. toctree::
   :maxdepth: 2

   curves.rst
   control_points.rst
   segments.rst


## Segments


********
Segments
********

.. _bpy.ops.curves.subdivide:

Subdivide
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curves --> Segments --> Subdivide`

Curve subdivision simply subdivides all selected segments by adding one or
more control points between the selected segments.

Number of Cuts
   The number of subdivisions to perform.


.. _bpy.ops.curves.switch_direction:

Switch Direction
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curves --> Segments --> Switch Direction`

This tool will "reverse" the direction of any curve with at least one selected element
(i.e. the start point will become the end one, and *vice versa*).
This is mainly useful when using a curve as path, or using the bevel and taper options.


## Draw

.. _modeling-curves-draw:

****
Draw
****

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Draw`

The Curve draw tool allows you to free-hand draw curves.


.. _bpy.types.CurvePaintSettings:

Tool Settings
=============

.. figure:: /images/modeling_curves_tools_draw_curve-stroke-panel.png
   :align: right

   Curve Stroke panel.

Type
   Type of curve to use for drawing.

   :Poly:
      Bézier Curve with straight line segments (auto handles).
   :Bézier:
      Tolerance
         Lower values give a result that is closer to the drawing stroke,
         while higher values give more smoothed results.

      Method
         :Refit: Incrementally refits the curve (gives best results).
         :Split: Splits the curve until the tolerance is met (gives a better drawing performance).

      Detect Corners
         Detects corners while drawing based on a specified angle;
         Any angles above the specified value are considered corners.
         If a corner is detected, the curve uses non-aligned handles
         for the corner resulting in a more crisp corner.

Taper Start, End
   Taper factor for the radius of the start and end points along the curve.

Radius Min
   Minimum radius when the minimum pressure is applied (also the minimum when tapering).
Max
   Radius to use when the maximum pressure is applied (or when a tablet is not used).

Use Pressure
   Uses stylus pressure to control the radius of the curve.

Depth
   Controls where and how the curves are drawn.

   :Cursor:
      Uses the depth under the cursor to draw curves.
   :Surface:
      Used to draw on top of other objects.

      Offset
         Distance to offset the curve from the surface.
      Absolute Offset
         Applies a fixed offset (does not scale by the curve radius).
      Only First
         Only uses the start of the stroke for the depth.
      Plane
         The orientation plane to draw on, available when *Only First* is enabled.

         :Normal to Surface: Draws aligned to the surface.
         :Tangent to Surface: Draws perpendicular to the surface.
         :View: Draws aligned to the viewport.

Curve 2D
   Project the curve on the Z axis.

As NURBS
   Draw curves as a NURBS curve with Bézier knot mode, instead of a Bézier curve.


Options
=======

After the tool is run, these options are available in the :ref:`bpy.ops.screen.redo_last` panel.

Error
   Error distance in object units. This can be seen similar to a subdivision rate for the curve.
   Lower values give a result that is closer to the drawing stroke while higher values give more smoothed results.
Fit Method
   :Refit: Incrementally refits the curve (gives best results).
   :Split: Splits the curve until the tolerance is met (gives a better drawing performance).
Corner Angle
   Any angles above this are considered corners.
Cyclic
   Toggles whether or not the curve is :term:`Cyclic`.


## Index


#########
  Tools
#########

.. toctree::
   :maxdepth: 2

   toolbar.rst


Types
=====

.. toctree::
   :maxdepth: 1

   draw.rst


## Toolbar


*******
Toolbar
*******

Curves Edit Mode tools:

:ref:`Select <tool-select-tweak>`
   Select or move.

   :ref:`Select Box <tool-select-box>`
      Select objects by dragging a box.

      All objects that intersect the box will be selected.
   :ref:`Select Circle <tool-select-circle>`
      Select objects by dragging a circle. All objects that intersect the path of
      the circle will be selected.
   :ref:`Select Lasso <tool-select-lasso>`
      Select objects by drawing a lasso.

Cursor
   Change the location of the 3D Cursor.
Move
   Translation tool.
Rotate
   Rotation tool.
Scale
   Scale tool.

   :ref:`Scale Cage <tool-scale-cage>`
      Change the scale of an object by controlling its cage.

Transform
   Tool to adjust the objects translation, rotations and scale.

:ref:`Annotate <tool-annotate-freehand>`
   Draw free-hand annotation.

   :ref:`Annotate Line <tool-annotate-line>`
      Draw straight line annotation.
   :ref:`Annotate Polygon <tool-annotate-polygon>`
      Draw a polygon annotation.
   :ref:`Annotate Eraser <tool-annotate-eraser>`
      Erase previous drawn annotations.

:ref:`Measure <tool-measure>`
   Measure distances in the scene.

:ref:`Draw <modeling-curves-draw>`
   Free-hand drawing of new curves.

:ref:`Radius <modeling-curves-radius>`
   Control the radius value of the control points.

:ref:`Tilt <modeling-curves-tilt>`
   Control the rotation value of the control points around the curve's axis.


## Attributes Reference

.. index:: Geometry Nodes; Attribute Reference

.. _bpy.ops.object.attribute_add:
.. _bpy.ops.object.attribute_remove:
.. _bpy.ops.geometry.attribute_add:
.. _bpy.ops.geometry.attribute_remove:

**********
Attributes
**********

An *attribute* is a generic term to describe data stored per-element in a geometry data-block.
For example, every vertex can have an associated number or vector.
Attributes can be altered by connecting a value to the *Group Output* node,
but also many nodes can change the values of specific attributes.

.. note::

   Attribute data types and domains are converted implicitly where possible, just like node sockets.


Named Attributes
================

Named attributes are created and used in other areas of Blender like shaders, painting, and UV mapping.
In the :doc:`modifier panel </modeling/modifiers/generate/geometry_nodes>`, a named attribute can
be used for input by clicking the icon to the right of the value button. The string input input
allows you to search and choose existing attributes from the modifier's input geometry.

.. figure:: /images/modeling_geometry-nodes_attribute-reference_search.png
   :align: center

   Attribute Search.

The attribute search gives a bit of context about each attribute.
To the left of the menu, the attribute domain is shown followed by the attribute name.
To the right of the menu, the attribute data type is shown.


.. _anonymous-attributes:

Anonymous Attributes
====================

.. figure:: /images/modeling_geometry-nodes_attribute-reference_attribute-field.png
   :align: center

   The *Normal* and *Rotation* outputs are examples of attribute fields,
   which refer to an attribute stored on a geometry.

An anonymous attribute is a set of generic data stored on a geometry that doesn't have a name.
Usually, attributes exposed in Blender's interface all have names. However,
in geometry nodes, attributes can be passed around with node sockets.
In these cases, an *Attribute Field* output is created, which is used by
nodes to find attribute data in an input geometry.

Anonymous attributes are still stored on the geometry like other attributes, and they are even
automatically interpolated when the geometry changes with other nodes, except for a few cases.
So generally, if the node link is still accessible, the attribute it references will be available
too. However, anonymous attributes cannot be connected to a completely separate geometry
that was created from a different source. To transfer attributes between separate geometries,
the :doc:`/modeling/geometry_nodes/geometry/sample/sample_index` or other similar nodes like the
:doc:`/modeling/geometry_nodes/mesh/sample/sample_nearest_surface` can be used.


.. _attribute-data-types:

Attribute Data Types
====================

The type of an attribute is the kind of data stored at each element.

:Boolean: True or false value.
:Integer: 32-bit integer.
:8-Bit Integer: Smaller integer with a range from -128 to 127.
:Float: Floating-point value.
:Vector: 3D vector with floating-point values.
:2D Vector: 2D vector with floating-point values.
:Color: RGBA color with 32-bit floating-point values.
:Byte Color: RGBA color with 8-bit positive integer values.
:Quaternion: Floating point :term:`Quaternion` rotation.

The above list is in the order of least to most "complex" (An integer can contain more data than a
boolean, so it is more complicated). When joining separate geometries together, the more complex data
type is preferred when there are matching names. This is particularly important when joining geometry
with named attributes with the :doc:`/modeling/geometry_nodes/geometry/join_geometry`

To store 2D Vectors (UV maps) and Byte Colors the
:doc:`/modeling/geometry_nodes/attribute/store_named_attribute` must be
used because there are no sockets for those types.


Data Conversion
---------------

Through the use of Geometry Nodes, data can be converted between types.

Valid conversions:

- Between color and vector -- mapping between color channels and vector components.
- Between color and float -- the color data is converted to its grayscale equivalent.
- Between float and integer -- integers simply become floats, floats are truncated.
- Between float and vector --  when a float becomes a vector the value is used for each component.
  When a vector becomes a float the average of the components is taken.
- Between float and boolean -- values greater than 0 are true, true maps to 1, and false maps to 0.


.. _attribute-domains:

Attribute Domains
=================

The domain of an attribute refers to what type of geometry element the attribute corresponds to.
Knowing the domain of an attribute is important because it defines how it may be interpolated and
used in nodes and shading. You can use the :doc:`Spreadsheet Editor </editors/spreadsheet>`
to determine the domains of attributes.

- **Point** domain attributes are associated with single locations in space with a position:
   - Vertices of a mesh
   - Points of a point cloud
   - Curve control points
- **Edge** domain attributes are associated with the edges of a mesh.
- **Face** domain attributes are associated with the faces of a mesh.
- **Face Corner** domain attributes are associated with the corners of the faces of the mesh.
  An example is a UV map attribute.
- **Spline** domain attributes are associated with a group of connected
  curve control points.
- **Instance** domain attributes exist on the :doc:`/modeling/geometry_nodes/instances` in a geometry.
  They can be used to store different values on copies of geometry data. Instance domain attributes are
  only supported in geometry nodes.

Attributes are automatically interpolated to other domains. For example, when the
:doc:`/modeling/geometry_nodes/geometry/read/position` is connected to the selection input of
the :doc:`/modeling/geometry_nodes/material/set_material` node, the values are interpolated
from the *Point* domain to the *Face* domain. Normally, domain conversions use simple averages
for values, but *Boolean* data type attributes have special rules for interpolation:


Boolean Domain Interpolation
----------------------------

.. list-table::
   :header-rows: 1
   :widths: 10 10 50

   * - From
     - To
     - Conversion

   * - Point
     - Edge
     - An edge is selected if both of its vertices were selected.

   * - Point
     - Face
     - A face is selected if all of its vertices were selected too.

   * - Point
     - Corner
     - Each corner's value is simply a copy of the value at its vertex.

   * - Point
     - Spline
     - A spline is selected if all of its control points were selected.

   * - ..
     - ..
     - ..

   * - Edge
     - Point
     - A vertex is selected if any connected edge was selected.

   * - Edge
     - Face
     - A face is selected if all of its edges are selected

   * - Edge
     - Corner
     - A corner is selected if its two adjacent edges were selected.

   * - ..
     - ..
     - ..

   * - Face
     - Point
     - A vertex is selected if any of the connected faces were selected.

   * - Face
     - Edge
     - An edge is selected if any connected face was selected.

   * - Face
     - Corner
     - Each corner's value is simply a copy of the value at its face.

   * - ..
     - ..
     - ..

   * - Corner
     - Point
     - A vertex is selected if all connected face corners were selected and it is not a loose vertex.

   * - Corner
     - Edge
     - An edge is selected if all corners on adjacent faces were selected.

   * - Corner
     - Face
     - A face is selected if all of its corners were selected.

   * - ..
     - ..
     - ..

   * - Spline
     - Point
     - Each point's value is simply a copy of the corresponding value of the spline.


.. _geometry-nodes_builtin-attributes:

Built-In Attributes
===================

Built-in attributes always exist, and cannot be removed. Their data type and domain cannot be changed.

.. list-table::
   :widths: 10 10 10 50
   :header-rows: 1

   * - Name
     - Type
     - Domain
     - Notes

   * - ``position``
     - *Vector*
     - *Point*
     - Built-in attribute describing vertex or point locations, in the local space of a geometry.
       Any node that changes the location of points will adjust this attribute,
       like the :doc:`/modeling/geometry_nodes/geometry/operations/transform_geometry`
       and the :doc:`/modeling/geometry_nodes/geometry/write/set_position`.

   * - ``radius``
     - *Float*
     - *Point*
     - A built-in attribute on point clouds used to set the size for the points in the viewport.
       Also built-in on curves, where it controls the size of each curve control point when
       converted to a mesh, or for other operations.

   * - ``id``
     - *Integer*
     - *Point*
     - Created by the :doc:`/modeling/geometry_nodes/point/distribute_points_on_faces`
       to provide stability when the shape of the input mesh changes,
       and used on instances to create motion blur.
       Values are expected to be large, with no order. This attribute is used by nodes
       that generate randomness, like the :doc:`/modeling/geometry_nodes/utilities/random_value`.
       Unlike other built-in attributes, this attribute is not required, and can be removed.

   * - ``material_index``
     - *Integer*
     - *Face*
     - Used to specify the material slot for every face in a mesh.

   * - ``sharp_edge``
     - *Boolean*
     - *Edge*
     - Attribute determining if an edge should have flat (rather than smooth) shading enabled
       in the viewport or a render.

   * - ``sharp_face``
     - *Boolean*
     - *Face*
     - Attribute determining if a face should have flat (rather than smooth) shading enabled
       in the viewport or a render.

   * - ``resolution``
     - *Integer*
     - *Spline*
     - Determines the number of evaluated points between two control points of a spline.
       Only NURBS and Bézier splines have this attribute, for poly splines, the value is always one.

   * - ``cyclic``
     - *Boolean*
     - *Spline*
     - Determines whether the spline has a segment that connects its first and last control points.

   * - ``handle_left``
     - *Vector*
     - *Point*
     - Describes the location of the left handle of a curve control point, on the side
       of the curve's start. Only exists when the curve contains a Bézier spline.

   * - ``handle_right``
     - *Vector*
     - *Point*
     - Describes the location of the right handle of a curve control point, on the side
       of the curve's end. Only exists when the curve contains a Bézier spline.


Naming Conventions
==================

These attributes do not exist by default, but are used implicitly by certain parts of Blender.
The data type of these attributes can be changed, just like any attribute besides the built-in attributes.
However, the attributes might be expected by Blender to have a certain type.

.. list-table::
   :widths: 10 10 10 50
   :header-rows: 1

   * - Name
     - Type
     - Domain
     - Notes

   * - ``velocity``
     - *Vector*
     - *Point*
     - Used to create motion blur when rendering animations.

   * - ``rest_position``
     - *Vector*
     - *Point*
     - Holds the position of points or vertices from before a geometry is deformed procedurally.
       Can be created automatically before :doc:`Shape Keys </animation/shape_keys/index>` and
       :doc:`Modifiers </modeling/modifiers/introduction>` are evaluated with the
       :ref:`Add Rest Position <bpy.types.Object.add_rest_position_attribute>` option.

   * - ``surface_uv_coordinate``
     - *2D Vector*
     - *Curve*
     - Used to describe curve attachment locations on a mesh surface, typically used for the hair system.

   * - ``crease_vert``
     - *Float*
     - *Point*
     - Vertex attribute used by the Subdivision Surface modifier.
       The values are expected to be in a range of 0 and 1.

   * - ``crease_edge``
     - *Float*
     - *Edge*
     - Edge attribute used by the Subdivision Surface modifier.
       The values are expected to be in a range of 0 and 1.

   * - ``uv_seam``
     - *Boolean*
     - *Edge*
     - True if an edge is considered a boundary between UV islands when unwrapping.

   * - ``bevel_weight_vert``
     - *Float*
     - *Point*
     - Used as vertex control for the bevel modifier.

   * - ``bevel_weight_edge``
     - *Float*
     - *Edge*
     - Used as edge control for the bevel modifier.

   * - ``sculpt_face_set``
     - *Integer*
     - *Face*
     - Used by the :ref:`Sculpt Face Sets Feature <face_sets>`.

   * - ``sculpt_mask``
     - *Float*
     - *Point*
     - Used by the :ref:`Sculpt Masking Feature <sculpt-masks>`.

   * - ``sculpt_face_set``
     - *Integer*
     - *Face*
     - Used by the :ref:`Sculpt Face Sets Feature <face_sets>`.


Custom Attributes
=================

Vertex groups, UV maps and Color Attributes are available as attributes in geometry nodes.
They are referred to by their name.
Naming collisions (e.g. a vertex group and a UV map with the same name) should be avoided.
If there is a naming collision, only one of the attributes is accessible in geometry nodes.

Attributes with any other name can also be created by nodes, when the name is used for the first time.

Note that geometry nodes does not always produce e.g. vertex groups if a node like
:doc:`Join Geometry </modeling/geometry_nodes/geometry/join_geometry>` is used.
Similarly, if the data type of a vertex group attribute is changed from the initial "Float" type,
the attribute will no longer be a vertex group.


.. _bpy.ops.geometry.attribute_convert:

Attribute Conversion Operator
=============================

.. figure:: /images/modeling_geometry-nodes_attribute-reference_convert.png
   :align: center

This operator found in the *Attributes* panel of the property editor can change the
domain or data type of an attribute.

Due to ongoing development in the area of attributes, many areas of Blender can not yet work with
the generic (identified with a name, stored on any domain with any data type) attributes used by
geometry nodes. That makes this operator an essential workaround in some cases where existing
tools must be used with data generated from geometry nodes.

Mode
   :Generic:
      Interpolate and convert the attribute between the domains and data types described on this page.
   :Vertex Group:
      Create a :doc:`Vertex Group </modeling/meshes/properties/vertex_groups/index>`
      from the attribute, which corresponds to a float attribute on the point domain.

.. note::

   This operator only works on *original* object data, not including the results of modifiers,
   so any attributes added or changed by geometry nodes will not be affected. To change the type
   of an attribute generated procedurally, modifiers must be applied.


## Baking


******
Baking
******

Baking allows saving and loading intermediate geometries.
Baking parts of the node tree can be used for better performance.

The data format used to store geometry data is not considered to be an import/export format.
Volume objects, however, are saved using the OpenVDB file format which can be used interoperably.

Data can be baked using two methods:

- :doc:`/modeling/geometry_nodes/geometry/operations/bake` -- used to bake any portion of the node tree.
- :ref:`Simulation Zone Baking <geometry_nodes-simulation-baking>` --
  used to bake animations where the result of one geometry state can influence the next state.


.. _bpy.types.NodesModifierDataBlock:

Data-Block References
=====================

.. reference::

   :Editor:    Geometry Node Editor
   :Panel:     :menuselection:`Sidebar --> Node --> Data-Block References`

Baked geometries that reference other data-blocks such as materials are listed here.

This panel allows changing these references after the data has been baked.

.. note::

   Currently only material data-blocks are supported.


## Fields

.. index:: Geometry Nodes; Fields

******
Fields
******

Fundamentally, a field is a function: a set of instructions that can transform an arbitrary number
of inputs into a single output. A field's result can then be calculated many times with different input data.
They are used all over geometry nodes to allow calculations that have different results
for every element (mesh vertices, faces, etc.).

.. figure:: /images/modeling_geometry-nodes_fields_title.png
   :align: center

   A field input to a node.

For example, in the figure above, the field connected to the "Set Position" node
depends on two inputs, :doc:`Position </modeling/geometry_nodes/geometry/read/position>` and
:doc:`Index </modeling/geometry_nodes/geometry/read/input_index>`, and transforms them into
a vector using a single instruction.


Field Visualization
===================

Socket shapes are used to convey which sockets are fields and which are regular data.
There are three possible socket shapes, each visualizing its "field status":

:Circle:
   The socket requires a single real value, it cannot accept a field input.
   For output sockets, this means the node always outputs a single value.
:Diamond:
   The socket can accept a field input, or it outputs a field. A constant single
   value can be connected to these sockets, but then the output will often not
   vary per element.
:Diamond with Dot:
   The socket can be a field, but it is currently a single value. This is helpful
   because it allows tracking where single values are calculated, instead of a field
   with many different results. It also means that :ref:`socket-inspection` will show
   the value instead of field input names.

.. figure:: /images/modeling_geometry-nodes_fields_constant.png
   :align: center

   The socket shape is a diamond with a dot, meaning the field has the same value
   for every element. Every point will be moved up by 5 m.

.. figure:: /images/modeling_geometry-nodes_fields_varying.png
   :align: center

   The socket shape is a diamond and the field input now has a varying input. In other words,
   the value can be different for every element. In this case, the position will be doubled,
   since the offset for every point is the point's position.

.. tip::

   Often it is desired to extract a single value from a field. While it doesn't
   make sense conceptually to simply change a field into a single value,
   the :doc:`/modeling/geometry_nodes/geometry/sample/sample_index` or the
   :doc:`/modeling/geometry_nodes/attribute/attribute_statistic` can
   be used to retrieve a single value from a field evaluated on a geometry.

When a connection is made between two node sockets that support
fields the node connection will be drawn as a dashed line.
If you make the mistake of connecting a non-field socket to a field socket,
the connection will be drawn as a solid red line indicating that there is an error.


.. _field-node-types:

Node Types
==========

Nodes can be separated into two categories: data flow nodes that usually pass geometry,
and field nodes that operate on data per-element. Field nodes can be input nodes that
bring geometry data into the node tree, or function nodes that operate on that data.


Data Flow Nodes
---------------

Nodes with a geometry input and a geometry output will almost always be data flow nodes.
Meaning that they actually change geometry data that will be outputted from the Geometry Nodes modifier.


Function Nodes
--------------

Nodes with diamond socket inputs and outputs are field nodes, and resemble the instructions
that will be evaluated by data flow nodes. Examples of function nodes are the math nodes
and also more complex nodes like the :doc:`/modeling/geometry_nodes/geometry/sample/geometry_proximity`.


Input Nodes
-----------

Input nodes provide data to the field evaluation process. By themselves, they mean nothing; they
must be evaluated within the context of a data flow node (geometry) to actually output a value.
Examples of input nodes are the built-in attribute input nodes like
:doc:`Position </modeling/geometry_nodes/geometry/read/position>` and
:doc:`ID </modeling/geometry_nodes/geometry/read/id>`, but also selection nodes like
:doc:`Endpoint Selection </modeling/geometry_nodes/curve/read/endpoint_selection>`.

Field inputs may also come from other nodes that process geometry like
the :doc:`/modeling/geometry_nodes/point/distribute_points_on_faces`,
in the form of :ref:`anonymous-attributes`.


.. _field-context:

Field Context
=============

All field nodes work in the context of the data flow node they are connected to.
The context usually consists of a geometry component type and an attribute domain,
so it determines what data is retrieved from input nodes.

One common misunderstanding is that the same field node tree used in multiple places will
output the same data. This is not necessarily true, because the field node tree will be evaluated
for every data flow node, potentially retrieving data from a different or changed geometry.

.. figure:: /images/modeling_geometry-nodes_fields_flow-1.png
   :align: center

Here, the :doc:`Set Position </modeling/geometry_nodes/geometry/write/set_position>` node's
input field is evaluated once. To evaluate the field, the node traverses
backwards to retrieve the inputs from the field input nodes.

.. figure:: /images/modeling_geometry-nodes_fields_flow-2.png
   :align: center

When a second Set Position node is added, the same field node tree is evaluated twice, once for each data flow node.
At the second Set Position node, the results will be different since its geometry input will already have
the changed position from the first node.

.. figure:: /images/modeling_geometry-nodes_fields_flow-3.png
   :align: center

However, often it's necessary to use the same field values even after changing the geometry.
The :doc:`/modeling/geometry_nodes/attribute/capture_attribute` evaluates a field, copying
the result to an :ref:`anonymous attribute <anonymous-attributes>` on the geometry.

Here, a Capture Attribute node stores a copy of the initial position.
Notice that evaluating the field input of the Capture Attribute node is an entirely
different step. Later on, the input fields to the Set Position nodes don't use
the actual position, but the anonymous attribute copy of it.


## Group

.. _bpy.types.GeometryNodeGroup:
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /compositing/types/groups.rst
   :start-after: .. --- copy below this line ---


## Index

.. index:: Nodes; Geometry Nodes
.. index:: Geometry Nodes
.. _bpy.types.GeometryNode:

##################
  Geometry Nodes
##################

.. toctree::
   :maxdepth: 3
   :titlesonly:

   introduction.rst
   inspection.rst
   attributes_reference.rst
   fields.rst
   instances.rst
   baking.rst
   tools.rst


Node Types
==========

.. toctree::
   :maxdepth: 3
   :titlesonly:

   attribute/index.rst
   input/index.rst
   output/index.rst

-----

.. toctree::
   :maxdepth: 3
   :titlesonly:

   geometry/index.rst

-----

.. toctree::
   :maxdepth: 3
   :titlesonly:

   curve/index.rst
   instances/index.rst
   mesh/index.rst
   point/index.rst
   volume/index.rst

-----

.. toctree::
   :maxdepth: 3
   :titlesonly:

   simulation/simulation_zone.rst

-----

.. toctree::
   :maxdepth: 3
   :titlesonly:

   material/index.rst
   texture/index.rst
   utilities/index.rst

----

.. toctree::
   :maxdepth: 3
   :titlesonly:

   group.rst

----

.. toctree::
   :maxdepth: 3
   :titlesonly:

   hair/index.rst
   normals/index.rst


.. tip::

   :doc:`Asset Catalogs </files/asset_libraries/catalogs>`
   that contain geometry node groups will also appear in the add menu.


## Inspection

.. index:: Geometry Nodes; Inspection

**********
Inspection
**********

Inspecting intermediate values in a geometry node tree is useful while
building/understanding one or when trying to figure out why something is not working.
Blender provides multiple tools to understand how a node tree is working
or why it is not working.

.. note::

   Generally, the inspection tools display data from the last time the node tree has been evaluated.
   If it has not been evaluated, no information is available.


.. _socket-inspection:

Socket Inspection
=================

.. figure:: /images/modeling_geometry-nodes_inspection_socket-inspection.png
   :align: center

   Socket Inspection.

Socket inspection shows information about the value in a socket during the last evaluation.
For primitive data types such as integers, vectors, and strings the actual value is shown.
For geometry sockets only some data about the geometry is stored, including the set of
data types the geometry contains, and a count of their elements.

Socket values are only logged from when the node tree was executed, so a node must be
connected to the *Group Output* to have a value for inspection. Values are not logged during
rendering, to improve performance.


.. _geometry-nodes-attribute-search:

Attribute Search
================

.. figure:: /images/modeling_geometry-nodes_attribute-reference_search.png
   :align: center

   Attribute Search.

The attribute search is shown when clicking on an attribute input in the modifier.
It contains a list of all the attributes that were available at that point in
the modifier or node execution.


Viewer Node
===========

The Viewer node is used to display intermediate geometry in the :doc:`Spreadsheet Editor </editors/spreadsheet>`
and the Viewport. For more information see :doc:`/modeling/geometry_nodes/output/viewer`.


Node Warnings
=============

.. figure:: /images/modeling_geometry-nodes_inspection_node-warning.png
   :align: center

   Node Warning.

When the inputs to a node are invalid, it displays a warning in the title.
Hovering over the warning icon shows the error message. These warnings are only
generated when the node is executed, so a node must be connected to the *Group Output*
to have a warning.


.. _modeling-geometry_nodes-inspection-timings:

Node Timings Overlay
====================

.. figure:: /images/modeling_geometry-nodes_inspection_node-timings.png
   :align: center

   The node timings overlay.

Node timings show how long a node took to execute the last time the node group was evaluated.
They can be turned on in the overlays popover on the top right of the node editor.
When a node group is used in multiple places, the timings depend on the context of
the node editor, which is displayed in the path on the top left.

Frame nodes display the total time from all of the contained nodes
and the *Group Output* node displays the total time for the entire node group.

The displayed timings should only be considered an approximation, since they can
also take into account actions like copying or deleting a geometry input that aren't
part of the node's operation. Also, when a node uses multiple CPU cores, the evaluation
system might work on other nodes at the same time. It's also important to remember
that :ref:`field nodes <field-node-types>` generally don't do work by themselves,
so their execution time is only added to the data-flow nodes they are connected to.


.. _bpy.types.SpaceNodeOverlay.show_named_attributes:

Named Attributes Overlay
========================

The "Named Attributes" overlay allows displaying when a custom named attribute is used
by a node or a node group. Named attributes can be used by the
:doc:`/modeling/geometry_nodes/attribute/capture_attribute`, the
:doc:`/modeling/geometry_nodes/geometry/read/named_attribute`, and the
:doc:`/modeling/geometry_nodes/attribute/remove_named_attribute`,
and can be written to, read, or removed.

Using named attributes (as opposed to :ref:`anonymous-attributes`) can be problematic
when the original geometry already has attributes with the specified names. In that case
a geometry node group might mistakenly overwrite some essential data. The overlay helps
to make detecting that situation easy.

The same data is also available in the :ref:`modifiers-geometry-nodes-named-attributes` panel
in the modifier's UI.


Geometry Randomization
======================

Many nodes don't guarantee the order of elements in which they output things. For example, the order of edges coming
out of the **Triangulate** node is deterministic but not well defined. The order may change between Blender versions.
Therefor, if node setups depend on a specific order, they may break when the Blender implementation changes. Changing
the order can often be necessary in order to fix bugs or improve performance.

"Geometry randomization" can be temporarily enabled to see if a blend-file depends on the indices in unstable ways.
When enabled, various internal algorithms shuffle the result geometry elements so that any dependence on it would not
work anymore. When building setups that are supposed to last a long time, it is recommended to check if they still
work with randomization enabled.

To enable it, first enable **Developer Extras** in the :doc:`preferences </editors/preferences/interface>`.
Then :doc:`search </interface/controls/templates/operator_search>` for **Set Geometry Randomization**.
The popup allows enabling and disabling the randomization.


## Instances

.. index:: Geometry Nodes; Instances

*********
Instances
*********

.. figure:: /images/modeling_geometry-nodes_instances.png
   :align: center

   The three types of instances.

In addition to storing real data like a mesh or a curve, objects can store instances,
which themselves can reference more geometry, an object, or a collection. The purpose
of instancing is to allow duplicating geometry and storing it in an object, without duplicating
the actual data. This optimization allows render engines  like :doc:`Cycles </render/cycles/index>`
to handle the same geometry data in many different locations better than when the data is duplicated.

Each instance keeps track of which geometry it corresponds to
and how the instanced is transformed compared to it's source geometry.
Instances can also store the ``id`` attribute,
which is used to correct motion blur when instances move in an animation.

Instances can be created with geometry nodes using the :doc:`/modeling/geometry_nodes/instances/instance_on_points`.

.. warning::

   Currently instancing from geometry nodes cannot be mixed with instancing from the
   :doc:`/scene_layout/object/properties/instancing/index` panel in the property editor.


.. _geometry-nodes_nested-instancing:

Nested Instancing
=================

Since instances can store a geometry, and a geometry can contain instances, nested instancing is possible.
In other words, it is possible to instance an instance, or even a collection of instances.
For example, by default, the :doc:`/modeling/geometry_nodes/instances/instance_on_points` will create
nested instances by instancing instances on the points of real geometry.

.. figure:: /images/modeling_geometry-nodes_instances-nested.png
   :align: center

   A node group that creates nested instancing by chaining
   :doc:`Instance on Points </modeling/geometry_nodes/instances/instance_on_points>` nodes.

Here, nested instancing is used to distribute geometry that contains both a mesh
and instances. The output geometry contains a "real" mesh and a group of instances.
Each instance contains a sphere mesh and many instances of a cone geometry.

.. figure:: /images/modeling_geometry-nodes_instances-nested-tree.png
   :align: center
   :width: 50%

   The tree of instanced geometry for the example above.

What makes this method helpful is the output geometry only contains three unique meshes:
the plane, the sphere, and the cone. This would make the performance much better if the meshes
were more complicated.

.. warning::

   Only eight levels of nested instancing are supported for rendering and viewing in the viewport.
   Though deeper trees of instances can be made inside geometry nodes, they must be realized at the
   end of the node tree.


Realizing Instances
===================

The term "realizing" instances referes to converting the instances into unique geometry.
When instances are realized they will take up more memory and manipulation to geometry
will have to be processed individually rather the once per instancing geometry.

To realize instance use the :doc:`/modeling/geometry_nodes/instances/realize_instances`.


.. _geometry-nodes_instance-processing:

Instance Processing
===================

Almost all nodes that process geometry do so by processing each unique
geometry separately rather than realized geometry. For example,
if a :doc:`/modeling/geometry_nodes/mesh/operations/subdivision_surface` was placed at
the end of the example above, it would only have to subdivide three meshes,
rather than each instance of a mesh. Another important example is processing with
the output of the :doc:`/modeling/geometry_nodes/utilities/text/string_to_curves`,
where each unique character only has to be processed once.

This method can improve performance a lot, but it means that the result of an operation
will be the same for every instance of a certain geometry. In order to have unique results
for every instance, the :doc:`/modeling/geometry_nodes/instances/realize_instances`
node can be used.


## Introduction


************
Introduction
************

Geometry Nodes is a system for modifying the geometry of an object with node-based operations.
It can be accessed by adding a :doc:`Geometry Nodes Modifier </modeling/modifiers/generate/geometry_nodes>`.

.. figure:: /images/modeling_geometry-nodes_introduction_properties.png

   The properties of a Geometry Nodes modifier in the modifier stack.

The geometry node tree connected to a modifier is a :doc:`Node Group </interface/controls/nodes/groups>`.
The geometry from the state before the modifier (the original geometry or the result of the previous
modifier) will be passed to the *Group Input* node. Then the node group can operate on the geometry
and pass an output to the *Group Output* node, where it will be passed to the next modifier.

Geometry nodes can modify different types of geometry:

* :doc:`Meshes </modeling/meshes/introduction>`
* :doc:`Curves </modeling/curves/introduction>`
* :doc:`Point Clouds </modeling/point_cloud>`
* :doc:`Volumes </modeling/volumes/introduction>`
* :doc:`Instances </modeling/geometry_nodes/instances>`

The interface of the modifier is described in the
:doc:`Modifier </modeling/modifiers/generate/geometry_nodes>` page.

To expand Blender with node-group operators see the description in the
:doc:`/modeling/geometry_nodes/tools` page.


## Tools

.. index:: Geometry Nodes; Tools
.. _bpy.types.GeometryNodeTree:

****************
Node-Based Tools
****************

Geometry Nodes can be used to expand the core functionality of Blender via node-group-defined tools.
They can be shared as any regular node group assets.

.. figure:: /images/modeling_geometry-nodes_tools.png
   :align: center

   Node group tools integrated in the Selection menu.


.. _tool_context:

Tool Context
============

The way to create Node-based tools is by switching the Geometry Nodes editor
:ref:`context <bpy.types.SpaceNodeEditor.geometry_nodes_type>` to *Tool*.

New node groups created in the tool context will be enabled as
:ref:`Tool <bpy.types.GeometryNodeTree.is_tool>` by default,
although users still need to set them as Assets if they want to share them (see below).

.. note::

   The :doc:`Inspection </modeling/geometry_nodes/inspection>`
   features are not supported in the *Tool* context: Viewer Node and Socket Inspection.


Asset
=====

For a node group to be shared as a tool, it has to be an :doc:`Asset </editors/asset_browser>` first. The asset
catalog is used to determine on which menus the node group will show, similar to the regular node group assets.
If the catalog name matches an existing menu, the tool will be added to the end of it.
Assets that have no catalog assigned to them, or local tools are exposed in the "Unassigned" menu.

The asset options need to be set on the :doc:`Asset Browser </editors/asset_browser>`.


Tool Settings
=============

The node group inputs will be exposed as in the :doc:`Adjust Last Operation </interface/undo_redo>` panel.


.. _modeling-geometry_nodes-tools_contexts:

Supported Modes & Data-Types
============================

Node groups must specify which modes and object types they support.
This helps to determine where the tool is available in the user interface.
These properties can be configured in popover menus in the
:ref:`Geometry Node editor <editors-geometry_nodes-tool_context>` when in the *Tool* context.

Currently only Object, Edit, and Sculpting modes are supported, and only for the Mesh and Hair Curves object types.

.. important::

   For mesh objects, :doc:`/animation/shape_keys/index` are not supported.
   Operating a node tool on a mesh with shape keys will remove the shape key data.


Tool-specific Nodes
===================

The following nodes are only supported in the *Tool* context:

- :doc:`/modeling/geometry_nodes/input/scene/3d_cursor`
- :doc:`/modeling/geometry_nodes/mesh/read/face_set`
- :doc:`/modeling/geometry_nodes/geometry/read/selection`
- :doc:`/modeling/geometry_nodes/mesh/write/set_face_set`
- :doc:`/modeling/geometry_nodes/geometry/write/set_selection`

.. note::

   The :doc:`Self Object </modeling/geometry_nodes/input/scene/self_object>`
   node returns the Active object when inside a *Tool* node group.


Non-supported Nodes
===================

These nodes are only supported in the *Modifier* context:

- :doc:`/modeling/geometry_nodes/simulation/simulation_zone`
- :doc:`/modeling/geometry_nodes/output/viewer`


## Attribute Statistic

.. index:: Geometry Nodes; Attribute Statistic
.. _bpy.types.GeometryNodeAttributeStatistic:

************************
Attribute Statistic Node
************************

.. figure:: /images/node-types_GeometryNodeAttributeStatistic.webp
   :align: right
   :alt: Attribute Statistic node.

The *Attribute Statistic* node evaluates a field on a geometry and outputs a statistic about the entire data set.


Inputs
======

Geometry
   Standard geometry input.

Selection
   A boolean field input for each element indicating whether to include its value in the statistics result
   If the boolean is false, the corresponding value from the *Attribute* input will be ignored.

Attribute
   The attribute field to query a statistic from.


Properties
==========

Data Type
   :Float:
      The output will be a single floating-point value.
   :Vector:
      The output will be a vector of three floating-point values.
      All calculations are elementwise.

Domain
   The :ref:`attribute domain <attribute-domains>` used for the statistics
   and to evaluate the input *Attribute* field on.


Outputs
=======

Mean
   The average value of all data.

Median
   The median value of all data.

Sum
   The sum value of all data.

Min
   The min value of all data.

Max
   The max value of all data.

Range
   The difference between the max and min value.

Standard Deviation
   How much values differ from the mean.
   A low standard deviation indicates that the values are grouped tightly together at the mean.
   A high standard deviation indicates that the values are spread out over a large range.

Variance
   The variance of all data, defined as the square of the standard deviation.


## Blur Attribute

.. index:: Geometry Nodes; Blur Attribute
.. _bpy.types.GeometryNodeBlurAttribute:

*******************
Blur Attribute Node
*******************

.. figure:: /images/node-types_GeometryNodeBlurAttribute.webp
   :align: right
   :alt: Blur Attribute node.
   :width: 300px

The *Blur Attribute* node smooths attribute values between neighboring geometry elements.

The goal of each step is mixing values of each element with its neighbors.
The weight for element is factor for multiplying all neighbor's values before accumulating them as new primitive
value.

Blurring will only work with certain geometry types and :ref:`attribute domains <attribute-domains>`.
Therefore, the attribute can only be affected on the :doc:`Meshes </modeling/meshes/introduction>` and
:doc:`Curves </modeling/curves/introduction>` components.

The domains this node works on is based on the :ref:`field context <field-context>` of the node's evaluation.
Only domains with explicit relations with their neighbors will work with this node.
Explicit relations for correct blurring are vertices, edges, and faces of meshes, and curve control points.

.. note::

   Blurring of face corner attributes is not handled by this node,
   because the ideal behavior for mixing face corner values is not clear.

All :ref:`attribute data types <attribute-data-types>` are supported except
for boolean attributes.


Inputs
======

Value
   The immediate value of each primitive to blur.

Iterations
   Number of repetitions of mixing value with neighbors. Each iteration is independent.
   Until one iteration is completed, its results are not used as a source for next blurring.

Weight
   Weight of each primitive.


Properties
==========

Data Type
   The :ref:`data type <attribute-data-types>` used for the evaluated data.


Outputs
=======

Value
   Values, mixed with neighbors defined number of times.


Examples
========

.. figure:: /images/modeling_geometry-nodes_blur_attribute-attribute_example.png

Input is Mesh Plane. First :doc:`/modeling/geometry_nodes/mesh/operations/subdivide_mesh` add some
faces for capture color with :doc:`/modeling/geometry_nodes/utilities/random_value`
used as hue in :doc:`/modeling/geometry_nodes/utilities/color/combine_color` on this.
Now second :doc:`/modeling/geometry_nodes/mesh/operations/subdivide_mesh` split each face on a lot of new.
Each one new duplicates original attribute.
Blur Attribute node mixes all attributes for each face. Due to this, the result is smoothed.


## Capture Attribute

.. index:: Geometry Nodes; Capture Attribute
.. _bpy.types.GeometryNodeCaptureAttribute:

**********************
Capture Attribute Node
**********************

.. figure:: /images/node-types_GeometryNodeCaptureAttribute.webp
   :align: right
   :alt: Capture Attribute node.

The *Capture Attribute* node stores the result of a field on a geometry,
and outputs the data as a node socket so it can be used by other nodes.

The result is stored on the geometry just like a regular attribute with
a name, but instead of referencing it with a name, it is retrieved whenever
the socket is connected to the input of a node. Later on when evaluating the node tree,
the attribute will be removed automatically if it is no longer used.

This node is essential because field input nodes like the :doc:`/modeling/geometry_nodes/geometry/read/radius`
work in the context of the node they are connected to. Meaning that in order to pass data like ``radius``
to a geometry that doesn't have radius, an explicit node link with the output of this node must be used.

.. note::

   Because this node stores an :ref:`anonymous attribute <anonymous-attributes>` in the geometry,
   it's essential to use the geometry output for further operations in the node tree.
   The anonymous attribute will not exist for any other geometry besides the output.


Inputs
======

Geometry
   Standard geometry input.

Value
   The input field to evaluate.


Properties
==========

Data Type
   The :ref:`data type <attribute-data-types>` used for the evaluated data.

Domain
   Which :ref:`attribute domain <attribute-domains>` to store the evaluated data on.


Outputs
=======

Geometry
   Standard geometry output.

Attribute
   The result of the evaluated field, stored on the geometry.


Examples
========

.. figure:: /images/modeling_geometry-nodes_attribute_capture-attribute_example.png

Here, a noise texture is evaluated in along the path of the curve in one dimension
and rendered with a shader. The capture node is required because the output of
the :doc:`/modeling/geometry_nodes/curve/operations/curve_to_mesh` does not have a "curve parameter",
since it is a mesh and not a curve. So, the :doc:`/modeling/geometry_nodes/curve/read/spline_parameter`
must be evaluated while the geometry is still a curve.

Internally, after the noise texture is evaluated on the curve,
it is automatically copied to the mesh result of the Curve to Mesh node.
This means that anywhere *Attribute* output of this node can be connected along
the same stream of geometry nodes, the internal attribute will be available.


## Domain Size

.. index:: Geometry Nodes; Domain Size
.. _bpy.types.GeometryNodeAttributeDomainSize:

****************
Domain Size Node
****************

.. figure:: /images/node-types_GeometryNodeAttributeDomainSize.webp
   :align: right
   :alt: Domain Size node.

The *Domain Size* outputs the size of an attribute domain on the selected geometry type,
for example, the number of edges in a mesh, or the number of points in a point cloud.

For more information about attribute domains, see the :ref:`geometry attributes page <attribute-domains>`.


Inputs
======

Geometry
   Standard geometry input.


Properties
==========

Component
    Which geometry type to retrieve the domain sizes from.

Outputs
=======

Point Count
   The size of the *Point* domain on any supported geometry.

Edge Count
   The size of the *Edge* domain on meshes.

Face Count
   The size of the *Face* domain on meshes.

Face Corner Count
   The size of the *Face Corner* domain on meshes.

Spline Count
   The size of the *Spline* domain on curves.

Instance Count
   The number of top-level instances in the geometry. :ref:`Nested instances <geometry-nodes_nested-instancing>`
   are not considered.


## Index


###################
  Attribute Nodes
###################

Nodes for working with data stored per object element, e.g. vertex groups.

.. toctree::
   :maxdepth: 1

   attribute_statistic.rst
   domain_size.rst

-----

.. toctree::
   :maxdepth: 1

   blur_attribute.rst
   capture_attribute.rst
   remove_named_attribute.rst
   store_named_attribute.rst


## Remove Named Attribute

.. index:: Geometry Nodes; Remove Named Attribute
.. _bpy.types.GeometryNodeRemoveAttribute:

***************************
Remove Named Attribute Node
***************************

.. figure:: /images/node-types_GeometryNodeRemoveAttribute.webp
   :align: right
   :alt: Remove Named Attribute node.

The *Remove Named Attribute* node deletes an attribute with a certain name from its geometry input.
Any attribute that exists on geometry data will be automatically propagated when the geometry storing it
is changed, which can be an expensive operation, so using this node can be a simple way to optimize
the performance of a geometry node tree or even to lower the memory usage of the entire scene.

Almost all named attributes can be removed. For certain :ref:`geometry-nodes_builtin-attributes`,
removing it will mean that a default value will be used instead. For example, removing the
:doc:`cyclic </modeling/geometry_nodes/curve/read/is_spline_cyclic>` attribute on curves means that
all curves will be non-cyclic.


Inputs
======

Geometry
   Standard geometry input.

Name
   The name of the attribute to remove.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Store Named Attribute

.. index:: Geometry Nodes; Store Named Attribute
.. _bpy.types.GeometryNodeStoreNamedAttribute:

**************************
Store Named Attribute Node
**************************

.. figure:: /images/node-types_GeometryNodeStoreNamedAttribute.webp
   :align: right
   :alt: Store Named Attribute node.

The *Store Named Attribute* node stores the result of a field on a geometry
as an attribute with the specified name. If the attribute already exists, the data
type and domain will be updated to the values chosen in the node.
However, keep in mind that the domain and data type of :ref:`geometry-nodes_builtin-attributes`
cannot be changed.

Compared with the :doc:`/modeling/geometry_nodes/attribute/capture_attribute`, this node basically
does the same thing, but the attribute gets a name instead of an anonymous reference.
For reusing the data in the same node tree, the *Capture Attribute* node might be preferable
since it does not create the chance for name conflicts in the input geometry.

.. note::

   If the input geometry contains multiple geometry component types, the attribute will be
   created on each component that has the chosen domain.


Inputs
======

Geometry
   Standard geometry input.

Selection
   A boolean field input for each element indicating whether to store the attribute value for the given index.
   If the attribute does not exist, unselected parts are filled with zero values;
   otherwise, only the selected parts are filled.

Value
   The input field to evaluate.

Name
   The name to give the stored data.


Properties
==========

Data Type
   The :ref:`data type <attribute-data-types>` used for the evaluated data.

Domain
   Which :ref:`attribute domain <attribute-domains>` to store the evaluated data on.


Outputs
=======

Geometry
   Standard geometry output.


## Index


###############
  Curve Nodes
###############

Nodes that only operate on curves.

.. note::
   If any modifiers precede the Geometry Nodes modifier,
   the curve will be seen as a mesh internally, and the Curve Nodes won't work.
   To get around this, first run the geometry through a
   :doc:`/modeling/geometry_nodes/mesh/operations/mesh_to_curve`.

.. toctree::
   :maxdepth: 2

   Read <read/index.rst>
   Sample <sample/index.rst>
   Write <write/index.rst>

-----

.. toctree::
   :maxdepth: 2

   Operations <operations/index.rst>
   Primitives <primitives/index.rst>
   Topology <topology/index.rst>


## Curve To Mesh

.. index:: Geometry Nodes; Curve to Mesh
.. _bpy.types.GeometryNodeCurveToMesh:

******************
Curve to Mesh Node
******************

.. figure:: /images/node-types_GeometryNodeCurveToMesh.webp
   :align: center
   :alt: The Curve to Mesh node.

The Curve to Mesh node converts all splines of a curve to a mesh.
Optionally, a profile curve can be provided to give the curve a custom shape.
This profile curve is scaled by the radius at each control point;
see the :doc:`/modeling/geometry_nodes/curve/write/set_curve_radius`.

The node transfers attributes to the result. Attributes that are built-in on meshes but not curves,
like ``sharp_face``, will be transferred to the correct domain as well.

.. tip::

   The output mesh has :ref:`sharp edges <geometry-nodes_builtin-attributes>` set from
   the profile curve tagged automatically. If any splines in the profile curve
   are Bézier splines and any of the control points use *Free* or *Vector* handles,
   the corresponding edges will be shaded sharp.


Inputs
======

Curve
   Standard geometry input.
   All non-curve components are ignored.

Profile Curve
   If a profile curve is provided, it will be extruded along all splines.
   Otherwise the generated mesh will just be a chain of edges.

Fill Caps
   If the profile spline is cyclic, fill the ends of the generated mesh with n-gons.
   The resulting mesh is :term:`Manifold`, the two new faces for each spline are
   simply connected to existing edges.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.


## Curve To Points

.. index:: Geometry Nodes; Curve to Points
.. _bpy.types.GeometryNodeCurveToPoints:

********************
Curve to Points Node
********************

.. figure:: /images/node-types_GeometryNodeCurveToPoints.webp
   :align: right
   :alt: Curve to Points node.

The *Curve to Points* node generates a point cloud from a curve.


Inputs
======

Curve
   Standard curve input.

Count
   Number of points generated. This input is only available for *Count* mode.

Length
   Length of the curve. This input is only available for *Length* mode.

Properties
==========

Mode
   :Evaluated:
      Creates points from the curve's evaluated points based on
      the :doc:`resolution </modeling/geometry_nodes/curve/read/spline_resolution>` attribute
      for NURBS and Bézier splines. This mode will generally be the fastest,
      since the second step of sampling equal lengths is not necessary.

   :Count:
      Sample each spline by evenly distributing the specified number of points.

   :Length:
      Sample each spline by splitting it into segments with specified length.
      The length will be rounded down so that a whole number of samples will fit in
      each input spline. To counteract jumping when the length of the spline changes,
      the :doc:`/modeling/geometry_nodes/curve/operations/trim_curve` can be used with
      a multiple of this length.


Outputs
=======

Points
   Generated point cloud.

Tangent
   The normalized :doc:`curve tangent </modeling/geometry_nodes/curve/read/curve_tangent>` at the sampled
   position, or the direct evaluated normal in *Evaluated* mode.

Normal
   The normal value from the evaluated curve at each result point.
   This is the same value from the :doc:`/modeling/geometry_nodes/geometry/read/normal`
   at those positions.

Rotation
   The :term:`Euler` rotation build from the *Tangent* and *Normal* outputs, for convenience.


## Deform Curves On Surface

.. index:: Geometry Nodes; Deform Curves on Surface
.. _bpy.types.GeometryNodeDeformCurvesOnSurface:

*****************************
Deform Curves on Surface Node
*****************************

.. figure:: /images/node-types_GeometryNodeDeformCurvesOnSurface.webp
   :align: center
   :alt: Deform Curves on Surface node.


The *Deform Curves on Surface* node translates and rotates each curve based on the
difference in its root position. The root position is defined by UV coordinates stored
on each curve and the :term:`UV Map` selected for the purpose in the
:ref:`Curves surface settings <bpy.types.Curves.surface>`.

The transformation is calculated based on the difference of the original mesh
(before shape keys and modifiers are evaluated), and the final mesh.

Unlike other geometry nodes, this node has quite a few implicit inputs:

- The original and evaluated mesh are retrieved from the modifier object's :ref:`surface <bpy.types.Curves.surface>`
  property. This means the node only works for curves objects.
- The original and evaluated UV map are also retrieved from the object's surface property.
- A 3D vector attribute named ``rest_position``, used for calculating tangents for rotating
  curves that are consistent with the tangents calculated on the original mesh (the rotation
  needs to be calculated from the normal and tangent of the original and evaluated meshes).
- A 2D vector attribute on the curve domain named ``surface_uv_coordinate`` to store the
  location of the root positions on the surface mesh's UV map.

In future development, this node will be generalized so the setup is more flexible.

Parts of the internal operation are similar to the :doc:`/modeling/geometry_nodes/mesh/sample/sample_uv_surface`.

.. warning::

  In order to achieve consistent deformation after the :doc:`/modeling/modifiers/generate/subdivision_surface`,
  the *UV Smooth* option of the modifier should be set to *None*. Otherwise the surface UV map will
  be subdivided in a way that may invalidate the curve UV attachement points stored in the
  ``surface_uv_coordinate`` attribute.

Inputs
======

Curves
   Standard curves input.


Properties
==========

This node has no properties.


Outputs
=======

Curves
   Standard curves output.


## Fillet Curve

.. index:: Geometry Nodes; Fillet Curve
.. _bpy.types.GeometryNodeFilletCurve:

*****************
Fillet Curve Node
*****************

.. figure:: /images/node-types_GeometryNodeFilletCurve.webp
   :align: right
   :alt: Fillet Curve node.

The *Fillet Curve* rounds corners on curve control points, similar to the effect of
the :doc:`Bevel Modifier </modeling/modifiers/generate/bevel>` on a 2D mesh.
However, a key difference is that the rounded portions created by the Fillet Curve node
are always portions of a circle.


Inputs
======

Curve
   Standard geometry input with a curve component.

Radius
   The radius of the circle portion generated at each fillet.

Count
   Only in *Poly* mode, the number of control points to add for each fillet.

Limit Radius
   Whether to limit the maximum value of the radius in order to avoid overlapping fillets.


Properties
==========

Method
   :Bézier:
      Only two control points will be generated for every filleted control point. The shape generated
      by the aligned handles on the generated control points on either side of the fillet is used to
      create the circle portion shape, meaning that the number of segments in the fillet shape depends on
      the :doc:`spline's resolution value </modeling/geometry_nodes/curve/read/spline_resolution>`.
   :Poly:
      The number of control points generated for each field
      input is controlled directly with an integer field input.
      This mode works better for poly and NURBS splines.


Outputs
=======

Curve
   Standard geometry input with a curve component.


Examples
========

.. figure:: /images/modeling_geometry-nodes_curve_fillet-curve_example_1.png
   :align: center

   The node can be used to round the corners of simple 3D poly splines.

.. figure:: /images/modeling_geometry-nodes_curve_fillet-curve_example_2.png
   :align: center

   The node can be combined with the curve primitive nodes to make more interesting shapes.


## Fill Curve

.. index:: Geometry Nodes; Fill Curve
.. _bpy.types.GeometryNodeFillCurve:

***************
Fill Curve Node
***************

.. figure:: /images/node-types_GeometryNodeFillCurve.webp
   :align: right
   :alt: Fill Curve node.

The *Fill Curve* node generates a mesh using the constrained Delaunay triangulation algorithm
with the curves as boundaries. The mesh is only generated flat with a local Z of 0.


Inputs
======

Curve
   Standard geometry input with a curve component.

Group ID
   Value used to group curves together.
   Curves with different Group ID are treated separately.


Properties
==========

Mode
   The type of geometry the output consists of.

   :Triangles:
      The output is made up of triangles.
   :N-gons:
      The output is made up of n-gons.


Outputs
=======

Mesh
   The filled-in curves.


Examples
========

Customized triangulation
------------------------

One or many "single point spline" can be used to customize the triangulation of the filled-in curves.

.. figure:: /images/modeling_geometry-nodes_curve_curve-fill_example_0.png
   :align: center

   This is the default behavior of the *Fill Curve* node applied to the star primitive.


.. figure:: /images/modeling_geometry-nodes_curve_curve-fill_example_1.png
   :align: center

   Here, a single curve point is joined to the star primitive to customize the triangulation.

.. figure:: /images/modeling_geometry-nodes_curve_curve-fill_example_2.png
   :align: center

   Here, 300 single curve point are joined to the star primitive to customize the triangulation.

Group ID
--------

The following figures display diverse application of the Group ID.

.. The following example were made with some nodes "hidden" to illustrate the amount of mesh islands
.. and avoid Z fighting.
.. Mesh Island Index -> Set Position (as z offset)
.. Mesh Island Index -> Map Range (Mesh island count as input max) -> Color Ramp (distributed from left)
.. Colors Used : 5ABD9E, 85BD50, DDB72C, D26072

.. figure:: /images/modeling_geometry-nodes_curve_curve-fill_group-id_0.png
   :align: center
   :alt:

   Here, the 4 curves share the same Group ID, resulting in 1 mesh island (default behavior).

.. figure:: /images/modeling_geometry-nodes_curve_curve-fill_group-id_1.png
   :align: center

   Here, the 4 curves have different Group ID, resulting in 4 mesh islands.

.. figure:: /images/modeling_geometry-nodes_curve_curve-fill_group-id_2.png
   :align: center

   Here, the 4 curves are seperated into two groups based on their positions, resulting in 2 mesh islands.


## Index


#########################
  Curve Operation Nodes
#########################

.. toctree::
   :maxdepth: 1

   curve_to_mesh.rst
   curve_to_points.rst
   deform_curves_on_surface.rst
   fill_curve.rst
   fillet_curve.rst
   interpolate_curves.rst
   resample_curve.rst
   reverse_curve.rst
   subdivide_curve.rst
   trim_curve.rst


## Interpolate Curves

.. index:: Geometry Nodes; Interpolate Curves
.. _bpy.types.GeometryNodeInterpolateCurves:

***********************
Interpolate Curves Node
***********************

.. figure:: /images/node-types_GeometryNodeInterpolateCurves.webp
   :align: right
   :alt: Interpolate Curves node.

Generate new curves on points by interpolating between existing curves.
This is useful to have a smaller set of original curves to make editing easier and faster
while still generating high-density curves for the viewport or a final render.


Inputs
======

Guide Curves
   Base curves that new curves are interpolated between.
Guide Up
   Optional up vector that is typically a surface normal. Supplying an up vector will improve
   the quality of the interpolation, making it aware of the surface shape which it otherwise
   wouldn't have a way to know about.

   .. tip::

      In a typical "child hair" generation setup, this up direction is retrieved with a combination
      of the :doc:`/modeling/geometry_nodes/mesh/sample/sample_uv_surface` using the same geometry
      that the points were distributed on, and the :doc:`/modeling/geometry_nodes/geometry/read/normal`.

Guide Group ID
   Splits guides into separate groups. New curves interpolate existing curves from a single group.
   This input can be useful for generating hair parts by stopping curves in different sections
   (with different group IDs) from affecting each other.
Points
   The positions of the first root control points of the newly generated interpolated curves.
Points Up
   Optional up vector that is typically a surface normal.
Point Group ID
   The curve group to interpolate in.
Max Neighbor
   Maximum amount of close guide curves that are taken into account for interpolation.


Properties
==========

This node has no properties.


Outputs
=======

Curves
   The guide curves with interpolated curves.
Closest Index
   Index of the closest guide curve for each generated curve.

   .. note::

      Internally this node mixes the data from multiple guide curves, with the maximum number
      of sources depending on the *Max Neighbor* input. This output is only the index of the curve
      with the largest weight.

Closest Weight
   Weight of the closest guide curve for each generated curve.


## Resample Curve

.. index:: Geometry Nodes; Resample Curve
.. _bpy.types.GeometryNodeResampleCurve:

*******************
Resample Curve Node
*******************

.. figure:: /images/node-types_GeometryNodeResampleCurve.webp
   :align: center
   :alt: Resample Curve node.

The Resample Curve node creates a poly spline for each input spline.
In the *Count* and *Length* modes, the control points of the new poly
splines will have uniform spacing.

.. tip::

   Use a field as an input to have a different count/length for each spline.


Inputs
======

Curve
   Standard geometry input.

Selection
   Whether or not to resample each spline. True values mean spline will be resampled to a poly spline,
   false values mean the spline will be unaffected.

Count
   The number of control points on the new splines.

Length
   The approximate length between the control points of the new splines.

   .. tip::

      A :doc:`/modeling/geometry_nodes/curve/operations/trim_curve` can be used with
      a multiple of the input length to make the distance between each sampled point exact,
      even when the length of the spline changes.


Properties
==========

Mode
   How to specify the amount of samples.

   :Count:
      Sample the specified number of points along each spline.
   :Length:
      Calculate the number of samples by splitting each spline into segments with the specified length.
      The length will be rounded down so that a whole number of samples will fit in each input spline.
   :Evaluated:
      Evaluate the spline's points based on the resolution attribute for NURBS and Bézier splines.
      Changes nothing for poly splines.


Outputs
=======

Curve
   Standard geometry output.


## Reverse Curve

.. index:: Geometry Nodes; Reverse Curve
.. _bpy.types.GeometryNodeReverseCurve:

******************
Reverse Curve Node
******************

.. figure:: /images/node-types_GeometryNodeReverseCurve.webp
   :align: center
   :alt: Reverse Curve node.

The *Reverse Curve* node swaps the start and end of splines.
The shape of the splines is not changed.

.. tip::

   When used on the *Profile* input of the :doc:`/modeling/geometry_nodes/curve/operations/curve_to_mesh`,
   this node fill flip the normals of the resulting mesh.


Inputs
======

Curve
   Standard geometry input.

Selection
   Whether or not to change the direction of each spline. True values mean the direction will be changed,
   false values mean the spline will be unaffected.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Standard geometry output.


## Subdivide Curve

.. index:: Geometry Nodes; Subdivide Curve
.. _bpy.types.GeometryNodeSubdivideCurve:

********************
Subdivide Curve Node
********************

.. figure:: /images/node-types_GeometryNodeSubdivideCurve.webp
   :align: center
   :alt: The Subdivide Curve node.

The *Subdivide Curve* node adds more control points in between existing control points on the curve input.
For Bézier and poly splines, the shape of the spline will not be changed at all.

With Bézier curves, this can be used to increase the control on the shape of the curve
while still having the higher-level provided by Bézier splines.
Unlike the :doc:`/modeling/geometry_nodes/curve/operations/resample_curve`, where they are converted to poly splines.


Inputs
======

Curve
   Standard geometry input.

Cuts
   The number of control points to create on the segment following each point.
   When the input is a field, the number of cuts for a segment is determined by
   the value of the field when evaluated at the previous point.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Standard geometry output.


## Trim Curve

.. index:: Geometry Nodes; Trim Curve
.. _bpy.types.GeometryNodeTrimCurve:

***************
Trim Curve Node
***************

.. figure:: /images/node-types_GeometryNodeTrimCurve.webp
   :align: center
   :alt: Trim Curve node.

The *Trim Curve* node shortens each spline in the curve by removing sections at
the start and end of each spline.

Bézier splines will still be Bézier splines in the output, with the first and last control point and
its handles moved as necessary to preserve the shape.
NURBS splines will be transformed into poly splines in order to be trimmed.

.. warning::

   Currently the Trim Curve node does not support
   :doc:`cyclic </modeling/geometry_nodes/curve/read/is_spline_cyclic>` splines.

.. note::

   Since curve :doc:`normals </modeling/geometry_nodes/geometry/read/normal>` are calculated the final curve,
   this node may change the resulting normals when the **Minimum** twist method is used, since the **Minimum**
   method considers the entire length of the curve to decide the final normals. In some cases the
   :doc:`/modeling/geometry_nodes/attribute/capture_attribute` could be used to avoid this,
   by saving the original normals to be used later.


Inputs
======

Curve
   Standard geometry input with a curve component.

Selection
   A boolean field input for each curve indicating whether it is trimmed or not.

Start
   The factor or length used to determine where to start each output spline.

   .. note::

      If the *Start* input is larger than the *End*, then the resulting spline
      will have a single point, located at the sample location of the *Start* value.

End
   The factor or length used to determine where to end each output spline.


Properties
==========

Mode
   How to find endpoint positions for the trimmed spline.

   :Factor:
      Find the endpoint positions using a factor of each spline's length.
      The input values should be between 0 or 1.
   :Length:
      Find the endpoint positions using a length from the start of each spline.
      The input values should be between 0 and the length of the splines.


Outputs
=======

Curve
   Standard geometry output.


## Arc

.. index:: Geometry Nodes; Arc
.. _bpy.types.GeometryNodeCurveArc:

********
Arc Node
********

.. figure:: /images/node-types_GeometryNodeCurveArc.webp
   :align: right
   :alt: Arc Node.

The *Arc* node generates a poly spline arc. The node has two modes, Radius and Points.


Inputs
======

Resolution
   Number of edges on the arc.

Radius
   The radius of the arc. *Radius* mode only.

Start Angle
   Starting angle of the arc.  *Radius* mode only.

Sweep Angle
   Length of the arc.   *Radius* mode only.

Connect Center
   Connect the arc at the center.

Invert Arc
   Invert and draw opposite arc.

Start, Middle, End
   The three points on the arc. *Points* mode only.
   The order of the points determines the direction (clockwise or counterclockwise) of the arc.
   The arc will always draw from Start to End via the Middle point. This can be changed by using
   the Invert Arc option.

Offset Angle
   Offset angle of the arc. *Points* mode only.

.. note::

   Because of the finite resolution, the middle point does not necessarily lie on the generated arc.


Properties
==========

Mode
   :Points:
      The position and radius of the arc are determined by three points.
      The center of the arc, radius and normal are also given as outputs.
   :Radius:
      The arc is determined by the radius, start angle and sweep angle.


Outputs
=======

Curve
   Poly spline generated from the inputs.

Center
   The center of the arc described by the three points. *Points* mode only.
Normal
   The normal direction of the plane described by the three points,
   pointing towards the positive Z axis. *Points* mode only.
Radius
   The radius of the arc described by the three points. *Points* mode only.


## Bezier Segment

.. index:: Geometry Nodes; Bézier Segment
.. _bpy.types.GeometryNodeCurvePrimitiveBezierSegment:

*******************
Bézier Segment Node
*******************

.. figure:: /images/node-types_GeometryNodeCurvePrimitiveBezierSegment.webp
   :align: right
   :alt: Bézier Segment Node.

The *Bézier Segment* node generates a 2D Bézier spline from the given control points and handles.


Inputs
======

Resolution
   The number of edges on the curve.

Start, End
   Positions of the start and end control point of the curve.

Start Handle, End Handle
   Positions of the handles used to define the shape of the curve.


Properties
==========

Mode
   :Position:
      The handle inputs are the absolute positions of the handles in 3D space.
   :Offset:
      The handle positions are relative to the control point on the curve.
      The handle inputs give the offset from the control points.


Outputs
=======

Curve
   Bézier spline generated from the inputs.


## Curve Circle

.. index:: Geometry Nodes; Curve Circle
.. _bpy.types.GeometryNodeCurvePrimitiveCircle:

*****************
Curve Circle Node
*****************

.. figure:: /images/node-types_GeometryNodeCurvePrimitiveCircle.webp
   :align: right
   :alt: Circle Node.

The *Curve Circle* node generates a poly spline circle.


Inputs
======

Resolution
   Number of edges on the circle.

Radius
   The radius of the circle.

Point 1, Point 2, Point 3
   The three points on the circle.
   The order of the points determines the direction (clockwise or counterclockwise) of the circle.

.. note::

   Because of the finite resolution, the three points do not necessarily lie on the generated curve.


Properties
==========

Mode
   :Points:
      The position and radius of the circle are determined by three points.
      The center of the circle is also given as an output.
      If the three points lie on one line, no geometry is generated.
   :Radius:
      The circle is determined by the radius.


Outputs
=======

Curve
   Poly spline generated from the inputs.

Center
   The center of the circle defined by the three points.


## Curve Line

.. index:: Geometry Nodes; Curve Line
.. _bpy.types.GeometryNodeCurvePrimitiveLine:

***************
Curve Line Node
***************

.. figure:: /images/node-types_GeometryNodeCurvePrimitiveLine.webp
   :alt: Curve Line node.

The *Curve Line* node generates poly spline line.


Inputs
======

Start
   Position of the first control point.

End
   Position of the second control point.
   This is only available in the *Points* mode.

Direction
   Direction the line is going in.
   The length of this vector does not matter.
   This is only available in the *Direction* mode.

Length
   Length of the line.
   This is only available in the *Direction* mode.


Properties
==========

Mode:
   :Points:
      Define the spline with start and end points.
   :Direction:
      Define the spline with a start, direction and length.


Outputs
=======

Curve
   Standard geometry output.


## Curve Spiral

.. index:: Geometry Nodes; Curve Spiral
.. _bpy.types.GeometryNodeCurveSpiral:

*****************
Curve Spiral Node
*****************

.. figure:: /images/node-types_GeometryNodeCurveSpiral.webp
   :align: right
   :alt: Curve Spiral Node.

The *Curve Spiral* node generates a poly spline in a spiral shape.
It can be used to create springs or other similar objects.
By default the spiral twists in a clockwise fashion.


Inputs
======

Resolution
   Number of points in one rotation of the spiral.

Rotations
   Number of times the spiral makes a full rotation.

Start Radius, End Radius
   Radius of the start point and end point of the spiral.
   The radius of the spiral changes linearly between the two values over the whole spiral.

Height
   Height of the spiral.

Reverse
   Boolean value that changes the direction from clockwise to counterclockwise when it is enabled.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Poly spline generated from the inputs.


## Index


#########################
  Curve Primitive Nodes
#########################

Nodes that create a primitive curve, e.g., a circle.

.. toctree::
   :maxdepth: 1

   arc.rst
   bezier_segment.rst
   curve_circle.rst
   curve_line.rst
   curve_spiral.rst
   quadratic_bezier.rst
   quadrilateral.rst
   star.rst


## Quadratic Bezier

.. index:: Geometry Nodes; Quadratic Bézier
.. _bpy.types.GeometryNodeCurveQuadraticBezier:

*********************
Quadratic Bézier Node
*********************

.. figure:: /images/node-types_GeometryNodeCurveQuadraticBezier.webp
   :align: right
   :alt: Quadratic Bézier Node.

The *Quadratic Bézier* node generates a poly spline curve from the given control points.
The generated shape is a parabola.


Inputs
======

Resolution
   The number of edges on the curve.

Start, Middle, End
   Positions of the three control points.
   The generated curve passes through the two end points, and is tangent to the lines between
   the middle point and the two end points.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Poly spline generated from the inputs.


## Quadrilateral

.. index:: Geometry Nodes; Quadrilateral
.. _bpy.types.GeometryNodeCurvePrimitiveQuadrilateral:

******************
Quadrilateral Node
******************

.. figure:: /images/node-types_GeometryNodeCurvePrimitiveQuadrilateral.webp
   :alt: Quadrilateral Node.

The *Quadrilateral* node generates a polygon with four points, with different modes.


Inputs
======

Width / Bottom Width / Top Width
   The X axis size of the shape.

Height
   The Y axis size of the shape.

Bottom Height / Top Height
   The distance between the bottom or top point and the X axis, in *Kite* mode.

Offset
   In *Parallelogram* mode, the relative X difference between the top and bottom edge.
   In *Trapezoid* mode, the amount to move the top edge in the positive X axis.

Point 1 - 4
   Input vectors for the *Points* mode.


Properties
==========

Mode
   :Rectangle:
      Generate a rectangle-shaped curve with a width and a height.
   :Parallelogram:
      Generate a rectangle with an offset for the different X values of the top and bottom edges.
   :Trapezoid:
      Generate a trapezoid-shaped curve with a height, a width for the top and bottom, and an offset.
   :Kite:
      Generate a kite shape with a width, and the top and bottom points distance from the X axis.
   :Points:
      Generate a four point cyclic poly spline by inputting the position vectors directly.


Outputs
=======

Curve
   Poly spline generated from the inputs.


## Star

.. index:: Geometry Nodes; Star
.. _bpy.types.GeometryNodeCurveStar:

*********
Star Node
*********

.. figure:: /images/node-types_GeometryNodeCurveStar.webp
   :align: right
   :alt: Star Node.

The *Star* node generates a poly spline in a star pattern by connecting alternating points of two circles.
The points on the inner circle are offset by a rotation so that they lie in between the points on the outer circle.
This offset can be changed with the twist input.


Inputs
======

Points
   Number of points on each of the circles.

Inner Radius, Outer Radius
   Radii of the two circles on which to place the control points.
   The inner radius can be larger than the outer radius.

Twist
   Angle offset of the inner circle.
   The twist value rotates the points on the circle corresponding with the inner radius
   counterclockwise by the given angle.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Poly spline generated from the inputs.

Outer Points
   A boolean attribute field with a selection of the points on the *Outer Radius*, which is every
   other point.


## Curve Handle Position

.. index:: Geometry Nodes; Curve Handle Position
.. _bpy.types.GeometryNodeInputCurveHandlePositions:

**************************
Curve Handle Position Node
**************************

.. figure:: /images/node-types_GeometryNodeInputCurveHandlePositions.webp
   :align: right
   :alt: Curve Handle Position node.

The *Curve Handle Position* node outputs the position of each of a Bézier spline's handles.
If the curve does not contain Bézier splines, the node will output zero.

The node to set this data is the :doc:`/modeling/geometry_nodes/curve/write/set_handle_positions`.


Inputs
======

Relative
   Output the handle positions relative to the corresponding control point
   instead of in the local space of the geometry.

Properties
==========

This node has no properties.


Outputs
=======

Left
   The position of the each control point's left handle.

Right
   The position of the each control point's right handle.


## Curve Length

.. index:: Geometry Nodes; Curve Length
.. _bpy.types.GeometryNodeCurveLength:

*****************
Curve Length Node
*****************

.. figure:: /images/node-types_GeometryNodeCurveLength.webp
   :alt: The Curve Length node.

The *Curve Length* node outputs the length of all splines added together.


Inputs
======

Curve
   Standard geometry input.


Properties
==========

This node has no properties.


Output
======

Length
   Accumulated length of all splines of the curve.


## Curve Tangent

.. index:: Geometry Nodes; Curve Tangent
.. _bpy.types.GeometryNodeInputTangent:

******************
Curve Tangent Node
******************

.. figure:: /images/node-types_GeometryNodeInputTangent.webp
   :align: right
   :alt: Curve Tangent node.

The *Curve Tangent* node outputs the direction that a curve points in at each control point,
depending on the direction of the curve (which can be controlled with
the :doc:`/modeling/geometry_nodes/curve/operations/reverse_curve`). The output values are normalized vectors.

.. warning::

   For NURBS and Bézier spline curves, keep in mind that the value retrieved from this node is
   the value at every control point, which may not correspond to the visible *evaluated* points.
   For example, a Bézier spline might have 48 evaluated points, but only four control points,
   if its resolution is 12. For NURBS splines the difference may be even more pronounced and the result
   may not be as expected. A :doc:`/modeling/geometry_nodes/curve/operations/resample_curve` can be used to
   create a poly spline, where there is a control point for every evaluated point.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Tangent
   The direction of the curve at every control point.


## Curve Tilt

.. index:: Geometry Nodes; Curve Tilt
.. _bpy.types.GeometryNodeInputCurveTilt:

***************
Curve Tilt Node
***************

.. figure:: /images/node-types_GeometryNodeInputCurveTilt.webp
   :align: right
   :alt: Curve Tilt node.

The *Curve Tilt* node outputs the angle used to turn the curve normal
around the direction of the curve tangent in its evaluated points.
Keep in mind that the output is per control point, just like the values
that can be controlled in curve Edit Mode. For NURBS and Bézier splines,
the values will be interpolated to the final evaluated points.

The input node for this data is the :doc:`Set Curve Tilt </modeling/geometry_nodes/curve/write/set_curve_tilt>` node.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Tilt
   The tilt angle for the normal in radians.


## Endpoint Selection

.. index:: Geometry Nodes; Endpoint Selection
.. _bpy.types.GeometryNodeCurveEndpointSelection:

***********************
Endpoint Selection Node
***********************

.. figure:: /images/node-types_GeometryNodeCurveEndpointSelection.webp
   :align: right
   :alt: Endpoint Selection node.

The *Endpoint Selection* node provides a selection for an arbitrary number of endpoints in each spline in a curve.

.. note::

   The selection operates for every control point. This may not correspond to the evaluated
   points displayed in the viewport for NURBS and Bézier splines, where one control point may
   correspond to many evaluated points.

.. tip::

   To use this data after the curve has been converted to another data type like mesh or a point cloud,
   the :doc:`/modeling/geometry_nodes/attribute/capture_attribute` can be used.


Inputs
======

Start Size
   The number of points to select from the start.

End Size
   The number of points to select from the end.


Properties
==========

This node has no properties.


Outputs
=======

Selection
   Selection of the start and end of each spline of the curve.


Examples
========

.. figure:: /images/modeling_geometry-nodes_curve_endpoint-selection_example.png
   :align: center

Anywhere the geometry is a curve, this node can be used to generate a selection of
only the first and last points of each spline. Here, the *Points* input of
the :doc:`/modeling/geometry_nodes/instances/instance_on_points` is a curve
consisting of the poly spline shown in Edit Mode.


## Handle Type Selection

.. index:: Geometry Nodes; Handle Type Selection
.. _bpy.types.GeometryNodeCurveHandleTypeSelection:

**************************
Handle Type Selection Node
**************************

.. figure:: /images/node-types_GeometryNodeCurveHandleTypeSelection.webp
   :align: center
   :alt: The Handle Type Selection node.

Creates a selection based on the handle types of the control points.

The handle type of each control point can be changed with the
:doc:`/modeling/geometry_nodes/curve/write/set_handle_type`.

Inputs
======

This node has no inputs.


Properties
==========

Mode
   Whether to consider left and/or right handles.
   When both are selected, the output value is true
   if either of the handles are of the chosen type.

   :Left:
      Consider the left handle.
   :Right:
      Consider the right handle.

Handle Type
   Handle type for which the selection will be true.
   See the :ref:`Bézier curves <curve-bezier-handle-type>` page for more details
   on the different handle types.


Outputs
=======

Selection
   Boolean field set to true wherever the handle type matches.


## Index


####################
  Read Curve Nodes
####################

.. toctree::
   :maxdepth: 1

   curve_handle_position.rst
   curve_length.rst
   curve_tangent.rst
   curve_tilt.rst
   endpoint_selection.rst
   handle_type_selection.rst
   is_spline_cyclic.rst
   spline_length.rst
   spline_parameter.rst
   spline_resolution.rst


## Is Spline Cyclic

.. index:: Geometry Nodes; Is Spline Cyclic
.. _bpy.types.GeometryNodeInputSplineCyclic:

*********************
Is Spline Cyclic Node
*********************

.. figure:: /images/node-types_GeometryNodeInputSplineCyclic.webp
   :align: right
   :alt: Is Spline Cyclic node.

The *Is Spline Cyclic* controls whether each of the curve splines start and endpoints form a connection.
Its output corresponds to the built-in ``cyclic`` attribute on the curve spline domain.

The node to set this data is the :doc:`/modeling/geometry_nodes/curve/write/set_spline_cyclic`.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Cyclic
   Whether the spline is cyclic.


## Spline Length

.. index:: Geometry Nodes; Spline Length
.. _bpy.types.GeometryNodeSplineLength:

******************
Spline Length Node
******************

.. figure:: /images/node-types_GeometryNodeSplineLength.webp
   :align: right
   :alt: Spline Length node.

The *Spline Length* node outputs the total length of each spline, as a distance, or a number of points.
This is different than the :doc:`Curve Length </modeling/geometry_nodes/curve/read/curve_length>` node,
which adds up the total length for all of the curve's splines.

The output values correspond to the spline domain, but the node can be used to output a value for every
curve control point as well.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Length
   The length of each spline.

Point Count
   The number of control points in each spline.


## Spline Parameter

.. index:: Geometry Nodes; Spline Parameter
.. _bpy.types.GeometryNodeSplineParameter:

*********************
Spline Parameter Node
*********************

.. figure:: /images/node-types_GeometryNodeSplineParameter.webp
   :align: right
   :alt: Spline Parameter node.

The *Spline Parameter* node outputs how far along each spline a control point is.
The *Factor* output is different from dividing the index by the total number of control points,
because the control points might not be equally spaced along the curve.

The first value is zero, so the output corresponds to the length at the control point rather than
including the length of the following segment.

When used on the spline domain, the node outputs the portion of the total length of the curve (including
all splines) has been traversed at the start of each spline. The order of the curve's splines is visible
in the :doc:`Spreadsheet Editor </editors/spreadsheet>`.

.. warning::

   For NURBS and Bézier spline curves, keep in mind that the value retrieved from this node is
   the value at every control point, which may not correspond to the visible *evaluated* points.
   For NURBS splines the difference may be even more pronounced and the result may not be as expected.
   A :doc:`/modeling/geometry_nodes/curve/operations/resample_curve` node can be used to create a poly spline,
   where there is a control point for every evaluated point.

.. note::

   When the *Length* is zero, the *Factor* is arbitrary. In this case the result is
   exceptionally calculated dividing the index by the total number of control points or curves.

Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Factor
   When the node is used on the point domain, the value is the portion of the spline's
   total length at each control point. On the spline domain it is the portion of the
   curve's total length at the start of the spline.

Length
   When the node is used on the point domain, the value is the distance along the spline to each
   control point. On the spline domain it is the length along the entire curve at the start
   of the spline.

Index
   Each control point's index on its spline. This is different from the output of the
   :doc:`index node </modeling/geometry_nodes/geometry/read/input_index>`, which also counts the
   control points in all previous splines.


Examples
========

.. figure:: /images/modeling_geometry-nodes_curve_curve-parameter_example.png
   :align: right

The parameter used to control the radius of the curve.
The beginning of the spline has a radius of 0, the end has a radius of 1.


## Spline Resolution

.. index:: Geometry Nodes; Spline Resolution
.. _bpy.types.GeometryNodeInputSplineResolution:

**********************
Spline Resolution Node
**********************

.. figure:: /images/node-types_GeometryNodeInputSplineResolution.webp
   :align: right
   :alt: Spline Resolution node.

The *Spline Resolution* outputs the number of evaluated curve points that will be generated for
every control point on the spline. This node works for NURBS, Bézier, and Catmull Rom splines.

For poly splines, there is a one-to-one correspondence between original points and evaluated points,
so the resolution does not have an effect.

On Bézier splines, the resolution does not have an effect on segments between vector handles,
since there are no extra evaluated points between the neighboring control points.

The node to set this data is the :doc:`/modeling/geometry_nodes/curve/write/set_spline_resolution`.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Resolution
   The integer resolution value for each spline.


## Index


######################
  Curve Sample Nodes
######################

.. toctree::
   :maxdepth: 1

   sample_curve.rst


## Sample Curve

.. index:: Geometry Nodes; Sample Curve
.. _bpy.types.GeometryNodeSampleCurve:

*****************
Sample Curve Node
*****************

.. figure:: /images/node-types_GeometryNodeSampleCurve.webp
   :align: right
   :alt: Sample Curve node.

The *Sample Curve* calculates a point on a curve at a certain distance from the start of the curve,
specified by the length or factor inputs. It also outputs data retrieved from that position on the curve.
The sampled values are linearly interpolated from the values at the evaluated curve points
at each side of the sampled point.

.. note::

   When the curve contains multiple splines, the sample position is found based on the total accumulated length,
   including the lengths of all previous splines. The order of the splines is the same order as
   displayed in the :doc:`Spreadsheet Editor </editors/spreadsheet>`.


Inputs
======

Curves
   Standard geometry input with a curve component.

Value
   A field input to evaluate custom attributes.
   The evaluation is outputted through the *Value* output.

Factor :guilabel:`Factor mode`
   The portion of the total length used to determine the sample position.

Length :guilabel:`Length mode`
   A length in distance units used to determine how far along the curve to travel before sampling.

Curve Index
   An index to only evaluate specific splines, these indices can be specified manually
   or from the :doc:`/modeling/geometry_nodes/geometry/read/input_index`.
   This input is ignored when the *All Curves* property is enabled.


Properties
==========

Data Type
   The :ref:`data type <attribute-data-types>` used for the evaluated data.

Mode
   How to find endpoint positions for the trimmed spline.
   The option acts the same as it does in the :doc:`/modeling/geometry_nodes/curve/operations/trim_curve`.

   :Factor:
      Find the endpoint positions using a factor of each spline's length.
      The input values should be between 0 or 1.
   :Length:
      Find the endpoint positions using a length from the start of each spline.
      The input values should be between 0 and the length of the splines.

All Curves
   Sample lengths based on the total length of all curves, rather than using a length inside each selected curve.


Outputs
=======

Value
   The value of the input *Value* at the sample point.

Position
   The position at the sample along the spline.

Tangent
   The normalized :doc:`curve tangent </modeling/geometry_nodes/curve/read/curve_tangent>` at the sample.

   .. tip::

      This output can be combined with the :doc:`/modeling/geometry_nodes/utilities/rotation/align_euler_to_vector`
      to create a rotation that lines up with direction of the curve. Including the *Normal* output
      in a second align node after can align the other rotation axis.

Normal
   The normalized :doc:`curve normal </modeling/geometry_nodes/geometry/read/normal>` at the sample.


Examples
========

.. figure:: /images/modeling_geometry-nodes_curve_sample-curve_example.png
   :align: center

Here, the *Count* mode of the :doc:`/modeling/geometry_nodes/curve/operations/resample_curve` is recreated,
except a mesh is used for the result instead of a curve. The Z axis of the position can be used
as the sample factor because the position is between zero and one for the entire line.


## Curve Of Point

.. index:: Geometry Nodes; Curve of Point
.. _bpy.types.GeometryNodeCurveOfPoint:

*******************
Curve of Point Node
*******************

.. figure:: /images/node-types_GeometryNodeCurveOfPoint.webp
   :align: right
   :alt: Curve of Point node.

The *Curve of Point* node retrieves the index of the curve a control point is part of.
This node is conceptually similar to the :doc:`/modeling/geometry_nodes/mesh/topology/face_of_corner`.


Inputs
======

Point Index
   The index of the input control point.

   .. note::

      By default this uses the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      from the field context, which makes it important that the node is evaluated on
      the point domain.


Properties
==========

This node has no properties.


Outputs
=======

Curve Index
   The index of the curve the control point is part of.

Index in Curve
   How far along the control point is along its curve, with a value of 0 for the first point in each curve.


## Index


########################
  Curve Topology Nodes
########################

Nodes that retrieve information about the connectivity between curves and control points.

.. toctree::
   :maxdepth: 1

   curve_of_point.rst
   offset_point_in_curve.rst
   points_of_curve.rst


## Offset Point In Curve

.. index:: Geometry Nodes; Offset Point in Curve
.. _bpy.types.GeometryNodeOffsetPointInCurve:

**************************
Offset Point in Curve Node
**************************

.. figure:: /images/node-types_GeometryNodeOffsetPointInCurve.webp
   :align: right
   :alt: Offset Point in Curve node.

The *Offset Point in Curve* node retrieves other points in the same curve as
the input control point. This is like starting at a specific control point and
walking along neighboring points toward the start or end of the curve.

Conceptually the operation is similar to the
:doc:`/modeling/geometry_nodes/mesh/topology/offset_corner_in_face`,
but the point index doesn't wrap around to the other end of the curve unless it is cyclic.


Inputs
======

Point Index
   The index of the input control point.

   .. note::

      By default this uses the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      from the field context, which makes it important that the node is evaluated on
      the point domain.

Offset
   The number of points to move around the curve before finding the result.
   If the curve is :doc:`cyclic </modeling/geometry_nodes/curve/read/is_spline_cyclic>`
   and the offset goes past the start or end point of the curve, it will wrap around
   to the other side.


Properties
==========

This node has no properties.


Outputs
=======

Is Valid Offset
   Whether the input control point plus the offset is a valid index of the original curve.
   Any offset in a cyclic curve is always valid.

Point Index
   The index of the offset curve point.


## Points Of Curve

.. index:: Geometry Nodes; Points of Curve
.. _bpy.types.GeometryNodePointsOfCurve:

********************
Points of Curve Node
********************

.. figure:: /images/node-types_GeometryNodePointsOfCurve.webp
   :align: right
   :alt: Points of Curve node.

The *Points of Curve* node retrieves indices of specific control points in a curve.


Inputs
======

Curve Index
   The index of the input curve.

   .. note::

      By default this uses the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      from the field context, which makes it important that the node is evaluated on
      the curve domain.

Weights
   Values used to sort the curve's control points.
   By default the control points are sorted by index, so the control points with the smallest indices come first.

Sort Index
   Which of the sorted control points to use for the *Point Index* output. If the value is larger than
   the total number of control points, it will wrap around to the beginning.


Properties
==========

This node has no properties.


Outputs
=======

Point Index
   The index of one of the curve's control points, chosen by the *Sort Index* input.

Total
   The number of control points in the curve.


## Index


#####################
  Write Curve Nodes
#####################

.. toctree::
   :maxdepth: 1

   set_curve_normal.rst
   set_curve_radius.rst
   set_curve_tilt.rst
   set_handle_positions.rst
   set_handle_type.rst
   set_spline_cyclic.rst
   set_spline_resolution.rst
   set_spline_type.rst


## Set Curve Normal

.. index:: Geometry Nodes; Set Curve Normal
.. _bpy.types.GeometryNodeSetCurveNormal:

*********************
Set Curve Normal Node
*********************

.. figure:: /images/node-types_GeometryNodeSetCurveNormal.webp
   :align: right
   :alt: Set Curve Normal node.

The *Set Curve Normal* controls the method used to calculate curve normals for every curve.

The node doesn't set the normals directly, those are calculated later as necessary.
Combined with the :doc:`tilt </modeling/geometry_nodes/curve/read/curve_tilt>` attribute value
at each control point, this will define the final normals accessible with the
:doc:`/modeling/geometry_nodes/geometry/read/normal`.

Internally this node adjusts the values of the ``normal_mode`` attribute on each curve.


Inputs
======

Curve
   Standard geometry input, containing curves.
Selection
   Whether or not to change the value on each curve.
Normal
   Input for the custom normal attribute (``custom_normal``) when using *Free* mode.


Properties
==========

Mode
   The method for evaluation of the curve's normals

   :Minimum Twist:
      The final normals are calculated to have the smallest twist around
      the curve tangent across the whole curve.
   :Z-Up:
      The final normals are calculated so that they is perpendicular to the Z axis and the tangent.
      If a series of points is vertical, the X axis is used
   :Free:
      Use the stored custom normal attribute (``custom_normal``) as the final normals.

      This mode adds a *Normal* input that can be used to set the value of the custom normal.

      .. note::

         Custom normals are not rotation invariant,
         meaning normals must be set **after** any rotation transformations;
         i.e. at the end of the node tree or at the bottom of the modifier stack.


Outputs
=======

Curve
   Standard geometry output.


## Set Curve Radius

.. index:: Geometry Nodes; Set Curve Radius
.. _bpy.types.GeometryNodeSetCurveRadius:

*********************
Set Curve Radius Node
*********************

.. figure:: /images/node-types_GeometryNodeSetCurveRadius.webp
   :align: right
   :alt: Set Curve Radius node.

The *Set Curve Radius* controls the radius of the curve, used for operations like the size of the profile
in the :doc:`Curve to Mesh </modeling/geometry_nodes/curve/operations/curve_to_mesh>` node. The value is set for
every control point, and is then interpolated to each evaluated point in between the control points.

The input node for this data is the :doc:`Curve Radius node </modeling/geometry_nodes/geometry/read/radius>`.


Inputs
======

Geometry
   Standard geometry input, containing curves.

Selection
   Whether or not to change the value on each control point. True values mean the value will be changed,
   false values mean the value will remain the same.

Radius
   The radius value for each control point.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Set Curve Tilt

.. index:: Geometry Nodes; Set Curve Tilt
.. _bpy.types.GeometryNodeSetCurveTilt:

*******************
Set Curve Tilt Node
*******************

.. figure:: /images/node-types_GeometryNodeSetCurveTilt.webp
   :align: right
   :alt: Set Curve Tilt node.

The *Set Curve Tilt* controls the tilt angle at each curve control point.
That angle rotates normal vector which is generated at each point
when evaluating the curve. The normal then can be retrieved with
the :doc:`/modeling/geometry_nodes/geometry/read/normal`.

The rotation of the normal vector is an :term:`Axis Angle` rotation.
It is the same as the :doc:`/modeling/geometry_nodes/utilities/vector/vector_rotate` operation
with the tangent vector as the axis, the raw evaluated normal is used as
the original vector, and the tilt as the rotation angle.

The input node for this data is the :doc:`/modeling/geometry_nodes/curve/read/curve_tilt`.


Inputs
======

Curve
   Standard geometry input, containing curves.

Selection
   Whether or not to change the value on each control point. True values mean the value will be changed,
   false values mean the value will remain the same.

Tilt
   The tilt angle for each control point.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Standard geometry output.


## Set Handle Positions

.. index:: Geometry Nodes; Set Handle Positions
.. _bpy.types.GeometryNodeSetCurveHandlePositions:

*************************
Set Handle Positions Node
*************************

.. figure:: /images/node-types_GeometryNodeSetCurveHandlePositions.webp
   :align: right
   :alt: Set Handle Positions node.

The *Set Handle Positions* node sets the positions for the handles of :ref:`Bézier curves <curve-bezier>`.
They can be used to alter the generated shape of the curve.
The input node for this data is the :doc:`/modeling/geometry_nodes/curve/read/curve_handle_position`.
See the :ref:`Bézier curves <curve-bezier-handle-type>` page for more details.

.. note::

   When the position is changed, *Auto* handle types will be converted to *Aligned*, and *Vector* handle
   types will be converted to *Free*.

.. note::

   The left and right handles cannot be changed at the same time with this node. That is because it would
   break the alignment for left and right handles at the same control point.


Inputs
======

Curve
   Standard geometry input, containing curves.

Selection
   Whether or not to change the handle position on each control point.
   True values mean the resolution will be changed, false values mean
   the resolution will remain the same.

Position
   The new handle position.

.. note::

   The handle positions are the global position of the handle, they are not relative to
   the position of the corresponding control point.

Offset
   An optional translation for each handle. This is evaluated at the same time as the *Position* input,
   meaning that fields evaluated for it will not reflect the changed position.


Properties
==========

Left / Right
   Whether to set the handle position of the left or right handle.
   The *Left* handle is closer to the start of the spline, and the *Right* handle is closer to the end.


Outputs
=======

Curve
   Standard geometry output.


Examples
========

.. figure:: /images/modeling_geometry-nodes_curve_set-handle-positions_example.png
   :align: center

Here, the handles are adjusted to the same position as the control points, but offset down in
the Z direction slightly. With the :doc:`/modeling/geometry_nodes/curve/write/set_spline_type`,
the curve can be a poly spline in Edit Mode, to make adjustment simpler for the user of the node group.


## Set Handle Type

.. index:: Geometry Nodes; Set Handle Type
.. _bpy.types.GeometryNodeCurveSetHandles:

********************
Set Handle Type Node
********************

.. figure:: /images/node-types_GeometryNodeCurveSetHandles.webp
   :align: right
   :alt: Set Handle Type node.

Sets the handle type for the points on the Bézier curve that are in the selection.

A selection for a certain handle type can be retrieved with
the :doc:`/modeling/geometry_nodes/curve/read/handle_type_selection`.


Inputs
======

Curve
   Bézier curve.

Selection
   The points whose handle types will be changed.


Properties
==========

Mode
   Whether to update left or right or both handles.
   When both are selected, both the left and the right handles will be updated.

   :Left:
      Update the left handles.
   :Right:
      Update the right handles.

Handle Type
   The handle type to switch to. See the :ref:`Bézier curves <curve-bezier-handle-type>`
   page for more details on the different handle types.


Outputs
=======

Curve
   Standard curve output.


## Set Spline Cyclic

.. index:: Geometry Nodes; Set Spline Cyclic
.. _bpy.types.GeometryNodeSetSplineCyclic:

**********************
Set Spline Cyclic Node
**********************

.. figure:: /images/node-types_GeometryNodeSetSplineCyclic.webp
   :align: right
   :alt: Set Spline Cyclic node.

The *Set Spline Cyclic* controls whether each spline will loop back on itself.
Each spline has the same number of control points whether or not it is set as cyclic.
But when displaying in the viewport or for operations with other nodes,
a connection will be made between the first and last control points.

The input node for this data is the :doc:`/modeling/geometry_nodes/curve/read/is_spline_cyclic`.


Inputs
======

Curve
   Standard geometry input.

Selection
   Whether or not to change the cyclic value on each spline. True values mean the value will be changed,
   false values mean the value will remain the same.

Cyclic
   Whether or not to join the first and last points of each spline.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Standard geometry output.


## Set Spline Resolution

.. index:: Geometry Nodes; Set Spline Resolution
.. _bpy.types.GeometryNodeSetSplineResolution:

**************************
Set Spline Resolution Node
**************************

.. figure:: /images/node-types_GeometryNodeSetSplineResolution.webp
   :align: right
   :alt: Set Spline Resolution node.

The *Set Spline Resolution* node sets the value for how many evaluated points should be generated on the curve for
every control point. It only has an effect on :term:`NURBS`, :term:`Bézier`, and Catmull Rom splines. In case of
Bézier splines, the resolution does not have an effect on segments between vector handles.

The evaluated points are displayed in the viewport, used in the
:doc:`/modeling/geometry_nodes/curve/operations/curve_to_mesh` node,
and optionally used in the :doc:`/modeling/geometry_nodes/curve/operations/resample_curve`.

The input node for this data is the :doc:`/modeling/geometry_nodes/curve/read/spline_resolution`.


Inputs
======

Curve
   Standard geometry input.

Selection
   Whether or not to change the resolution value on each spline. True values mean the value will be changed,
   false values mean the resolution will remain the same.

Resolution
   The number of evaluated points generated for each control point in NURBS and Bézier splines.
   It controls the accuracy of operations like trimming or sampling a curve.
   Higher resolutions are more accurate, but slower.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Standard geometry output.


## Set Spline Type

.. index:: Geometry Nodes; Set Spline Type
.. _bpy.types.GeometryNodeCurveSplineType:

********************
Set Spline Type Node
********************

.. figure:: /images/node-types_GeometryNodeCurveSplineType.webp
   :align: right
   :alt: The Set Spline Type node.

Sets the spline type for the splines in the curve component that
are in the selection.


Inputs
======

Curve
   Standard geometry input with a curve component.

Selection
   The splines whose spline types will be changed.


Properties
==========

Spline Type
   The type to convert the splines in the selection to.
   Read the :ref:`Spline Types <curve-spline-types>` page for more details
   on the different spline types.

   :Bézier:
      Convert to a Bézier spline. A spline converted from a poly spline gets vector handles,
      while one converted from NURBS or Catmull Rom spline gets auto handles.

      .. note::

         When converting from a NURBS spline to a Bézier spline,
         at least six points are needed.
         When the number of points is not a multiple of three
         a full conversion is not possible and the spline has to be truncated.
   :NURBS:
      Convert to a NURBS spline.
   :Poly:
      Convert to a poly spline.
   :Catmull Rom:
      Convert to a Catmull Rom spline.


Outputs
=======

Curve
   Standard curve output.


## Geometry To Instance

.. index:: Geometry Nodes; Geometry to Instance
.. _bpy.types.GeometryNodeGeometryToInstance:

*************************
Geometry to Instance Node
*************************

.. figure:: /images/node-types_GeometryNodeGeometryToInstance.webp
   :align: right
   :alt: Geometry to Instance node.

The *Geometry to Instance* node turns every connected input geometry into an instance.
Visually, the node has a similar result as the :doc:`/modeling/geometry_nodes/geometry/join_geometry`,
but it outputs the result as separate instances instead. The geometry data itself isn't actually
joined.

The node can be used in combination with the *Pick Instances* option in the
:doc:`/modeling/geometry_nodes/instances/instance_on_points`, as a way to pick
between geometry generated in the node tree (as opposed to picking from separate
instances from the :doc:`/modeling/geometry_nodes/input/scene/collection_info`, for example).

.. tip::

   This node can be much faster than the join geometry node when the inputs are large geometries.
   This is because the join geometry node must actually create a larger mesh, or a larger curve.
   Even though the operation is simple, just creating a large mesh can have a significant cost.
   This node can be better, because instead of merging large geometries, it just groups them
   together as instances.


Inputs
======

Geometry
   Geometry that will be joined. Multiple inputs are allowed.
   When the node is muted, only the first link will be passed through.


Properties
==========

This node has no properties.


Output
======

Geometry
   Standard geometry output.


Examples
========

.. figure:: /images/modeling_geometry-nodes_geometry_geometry-to-instance_instance.png
   :align: center

The node used in combination with the :doc:`/modeling/geometry_nodes/instances/instance_on_points`
to choose between multiple primitives for instancing.


## Index


##################
  Geometry Nodes
##################

Nodes that can operate on different geometry types (volume, mesh).

.. toctree::
   :maxdepth: 2

   Read <read/index.rst>
   Sample <sample/index.rst>
   Write <write/index.rst>

-----

.. toctree::
   :maxdepth: 2

   Operations <operations/index.rst>

-----

.. toctree::
   :maxdepth: 1

   geometry_to_instance.rst
   join_geometry.rst


## Join Geometry

.. index:: Geometry Nodes; Join Geometry
.. _bpy.types.GeometryNodeJoinGeometry:

******************
Join Geometry Node
******************

The *Join Geometry* node merges separately generated geometries into a single one.
If the geometry inputs contain different types of data, the output will also contain different data types.

.. figure:: /images/node-types_GeometryNodeJoinGeometry.webp
   :alt: Join Geometry node.

.. note::

   The node cannot handle the case when more than one geometry input has a volume component.


Materials
=========

When multiple mesh inputs contain different materials, the material slots from each mesh geometry
are merged so that the output mesh will contain all the input materials.


Attributes
==========

When merging attributes from multiple geometry inputs, the highest complexity data type is chosen
for the output attribute. In other words, if a ``weight`` attribute has a Boolean type on one geometry input
and a vector data type on another geometry, the ``weight`` attribute on the output geometry will have
a vector data type. The same heuristic is used for attribute domains, the domain with the most information
will be used for the output.

.. warning::

   Like other geometry nodes, this node always outputs generic typed attributes. So instead of a
   :term:`Vertex Group` attribute, it will create a "Float" attribute on the result, and it will
   create a generic 2D vector attribute instead of a special "UV Map" attribute. Some other areas
   of Blender don't properly handle generic attributes in version 3.0.

   Custom face corner normals are also not transferred currently.

Inputs
======

Geometry
   Geometry that will be joined. Multiple inputs are allowed.
   When the node is muted, only the first link will be passed through.


Properties
==========

This node has no properties.


Output
======

Geometry
   Standard geometry output.


## Bake

.. index:: Geometry Nodes; Bake
.. _bpy.types.GeometryNodeBake:

*********
Bake Node
*********

.. figure:: /images/node-types_GeometryNodeBake.webp
   :align: right
   :alt: Bake node.

The *Bake* node allows saving and loading intermediate geometries.
This node bakes parts of the node tree for better performance.

The data format used to store geometry data is not considered to be an import/export format.
Volume objects, however, are saved using the OpenVDB file format which can be used interoperably.

.. important::

   - Blend-files must be saved to a disk before data can be baked.
   - It's not guaranteed that data written with one Blender version can be read by another Blender version.


Inputs
======

Geometry
   Standard geometry input, which is used as the default bake item.
   More bake items can be added by dragging sockets into the blank socket or in the *Bake Items* panel.


Bake Items
==========

.. reference::

   :Editor:    Geometry Node Editor
   :Panel:     :menuselection:`Sidebar --> Node --> Bake Items`

The *Bake Items* panel is used to manage the input sockets
of the node thus also managing what data is baked.

.. _bpy.types.GeometryNodeBake.active_index:

Bake Items List
   Used to manage the inputs and outputs of the bake node.
   Items can be added, removed, renamed, and sorted.

Socket Type
   The data (:ref:`bpy.types.NodeLink`) of the input/output.

Attribute Domain
   The :ref:`attribute domain <attribute-domains>` used to evaluate the input field on.

Is Attribute
   Bake item is an attribute stored on a geometry.


Properties
==========

.. note::

   Some properties can only be edited in the Properties panel
   (:menuselection:`Sidebar --> Node --> Properties`).

Bake Mode
   The *Bake* node can calculate the geometry of a single frame or an animation.

   :Animation:
      Bakes the geometry data for multiple frames.
      By default the scene frame range is used, however, a *Custom Range* can also be defined.
   :Still: Bakes the geometry data of the current frame.

Bake
   Preforms all necessary geometry calculations and saves the data to disk.

   Delete (Trash Icon)
      Deletes the bake data.

Custom Path
   Specify a path where the baked data should be stored manually.

   Bake Path
      Location on disk where the baked data is stored.
      Note, this path is also used for :doc:`simulation zones </modeling/geometry_nodes/simulation/simulation_zone>`.

Custom Range :guilabel:`Animation`
   Override the simulation frame range from the scene.

Start, End
   The start and end frame numbers for the custom range.


Outputs
=======

For each input, the same output is added to act as a pass through.

Geometry
   Standard geometry output, which is used as the default bake item.
   More bake items can be added by dragging sockets into the blank socket or in the *Bake Items* panel.


## Bounding Box

.. index:: Geometry Nodes; Bounding Box
.. _bpy.types.GeometryNodeBoundBox:

*****************
Bounding Box Node
*****************

.. figure:: /images/node-types_GeometryNodeBoundBox.webp
   :align: right
   :alt: Bounding Box node.

The *Bounding Box* node creates a box mesh with the minimum volume that encapsulates
the geometry of the input. The node also can output the vector positions of the bounding dimensions.

The mesh output and the *Min* and *Max* outputs do not take instances into account. Instead,
for instanced geometry, a bounding box is computed for each instance rather than the whole geometry.
To compute the bounding box including the instances,
a :doc:`/modeling/geometry_nodes/instances/realize_instances` can be used.


Inputs
======

Geometry
   Standard geometry input.


Properties
==========

This node has no properties.


Outputs
=======

Bounding Box
   The resulting box that encapsulate the input geometry.

Min
   The coordinates corresponding to the box's -X, -Y, -Z position values,
   i.e. how far the box extends in each of the negative axes directions.

Max
   The coordinates corresponding to the box's +X, +Y, +Z position values,
   i.e. how far the box extends in each of the positive axes directions.


Example
=======

.. figure:: /images/modeling_geometry-nodes_geometry_bounding-box_example.png

   Bounding Box node used to create a box that encapsulates the geometry of the monkey mesh.


## Convex Hull

.. index:: Geometry Nodes; Convex Hull
.. _bpy.types.GeometryNodeConvexHull:

****************
Convex Hull Node
****************

.. figure:: /images/node-types_GeometryNodeConvexHull.webp
   :alt: Convex Hull node.

The *Convex Hull* node outputs a convex mesh that is enclosing all points in the input geometry.

.. note::

   When the node is used on a geometry with instances, the algorithm will run once per instance,
   resulting in many convex hull meshes in the instance geometries. The *Realize Instances* node can
   be used to get a convex hull of an entire geometry.

.. important::

   Volumes are not supported by this node, and attributes are not automatically transferred to the result.


Inputs
======

Geometry
   Standard geometry inputs.


Properties
==========

This node has not properties.


Outputs
=======

Convex Hull
   Mesh that encloses all points in the input.


## Delete Geometry

.. index:: Geometry Nodes; Delete Geometry
.. _bpy.types.GeometryNodeDeleteGeometry:

********************
Delete Geometry Node
********************

.. figure:: /images/node-types_GeometryNodeDeleteGeometry.webp
   :align: center
   :alt: Delete Geometry node.

The *Delete Geometry* node removes the selected part of a geometry.
It behaves similarly to the :ref:`Delete <bpy.ops.mesh.delete>` tool in Edit Mode.
The type of elements to be deleted can be specified with the domain and mode properties.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Boolean field that is true for parts of the geometry to be deleted.


Properties
==========

Domain
   The domain on which the selection field is evaluated.

   :Point:
      The selection is on the points, control points, and vertices of the geometry.
   :Edge:
      The selection is on the edges of the mesh component. The other components
      are not modified.
   :Faces:
      The selection is on the faces of the mesh component. The other components
      are not modified.
   :Spline:
      The selection is on the splines in the curve component. For each spline, it
      will either be deleted entirely or not at all. The other components are not
      modified.
   :Instances:
      The selection is on the top-level instances, and the entire instance is
      removed if it is selected. If the input also contains realized geometry,
      that will be unaffected.

Mode
   The type of elements to be affected.
   This only applies to the mesh component.

   :All:
      Vertices, edges, and faces in the selection will be deleted.
   :Only Edges & Faces:
      Vertices won't be deleted, even if they are in the selection.
   :Only Faces:
      Only faces in the selection will be deleted.


Output
======

Geometry
   Standard geometry output.


## Duplicate Elements

.. index:: Geometry Nodes; Duplicate Elements
.. _bpy.types.GeometryNodeDuplicateElements:

***********************
Duplicate Elements Node
***********************

.. figure:: /images/node-types_GeometryNodeDuplicateElements.webp
   :align: center
   :alt: Duplicate Elements node.

The *Duplicate Elements* node creates a new geometry with the specified elements
from the input duplicated an arbitrary number of times. The positions of elements
are not changed, so all of the duplicates will be at the exact same location.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Boolean field that is true for parts of the geometry to be deleted.

Amount
   Field indicating how many times each input element should be duplicated.
   If the value is zero for an element, it will not be included in the output at all.


Properties
==========

Domain
   The type of geometry element to duplicate

   :Point:
      Duplicate the points of meshes, curves, or point clouds.
      Any other elements will not be included in the output.
   :Edge:
      Duplicate mesh edges. Faces will not be included in the output.
   :Faces:
      Duplicate mesh faces. Each duplicated face will be separate,
      in other words they will not share edges with other faces.
   :Spline:
      Individual curves from the input curves component will be duplicated.
   :Instances:
      Input top-level instances will be duplicated.


Output
======

Geometry
   Standard geometry output.

Duplicate Index
   An attribute field with a value for every output element describing which
   duplicate of the corresponding input. The value for every input element will
   start at 0 and increase to ``Amount - 1``.


Examples
========

.. figure:: /images/modeling_geometry-nodes_geometry_duplicate-elements_instance.png
   :align: center


Combined with the :doc:`/modeling/geometry_nodes/geometry/geometry_to_instance`,
this can be used to create a basic efficient "Array" operation. This should be more efficient
because the duplicates are :doc:`instances </modeling/geometry_nodes/instances>`.

The "Duplicate Index" is used to move each instance in the result a different amount.


## Index


############################
  Geometry Operation Nodes
############################

.. toctree::
   :maxdepth: 1

   bake.rst
   bounding_box.rst
   convex_hull.rst
   delete_geometry.rst
   duplicate_elements.rst
   merge_by_distance.rst
   split_to_instances.rst
   sort_elements.rst
   transform_geometry.rst

-----

.. toctree::
   :maxdepth: 1

   separate_components.rst
   separate_geometry.rst


## Merge By Distance

.. index:: Geometry Nodes; Merge by Distance
.. _bpy.types.GeometryNodeMergeByDistance:

**********************
Merge by Distance Node
**********************

.. figure:: /images/node-types_GeometryNodeMergeByDistance.webp
   :align: right
   :alt: Merge by Distance node.

The *Merge by Distance* node merges selected mesh vertices or point cloud points within a given distance,
merging surrounding geometry where necessary. This operation is similar to the :ref:`bpy.ops.mesh.remove_doubles`
operator or the :doc:`/modeling/modifiers/generate/weld`.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Boolean field that is true for parts of the geometry to be deleted.
   Unselected points will be completely unused for the operation--
   they will not be merged into other points, and no points will merge into them either.

   .. tip::

      When possible, using the selection input can be a simple way to speed up the node,
      since searching for nearby points is a relatively expensive operation that gets even
      more expensive when more points are involved.

Distance
    The distance to use for searching for nearby points.


Properties
==========

Mode
   Method for choosing which vertices are merged.

   :All: Merge includes all geometry including loose parts.
   :Connected: Merge only includes attached geometry i.e. the modifier will not merge loose parts together.


Output
======

Geometry
   Standard geometry output.


Examples
========

.. figure:: /images/modeling_geometry-nodes_geometry_merge-by-distance_points.png
   :align: center

   Using the selection input to only merge some of the points in a point cloud.


## Separate Components

.. index:: Geometry Nodes; Separate Components
.. _bpy.types.GeometryNodeSeparateComponents:

************************
Separate Components Node
************************

.. figure:: /images/node-types_GeometryNodeSeparateComponents.webp
   :align: center
   :alt: Separate Components node.

The *Separate Components* node splits a geometry into a separate output
for each type of data in the geometry.


Inputs
======

Geometry
   Standard geometry input.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Mesh component of the input geometry.

Curve
   Curve component of the input geometry.

Point Cloud
   Point cloud component of the input geometry.

Volume
   Volume component of the input geometry.

Instances
   Instances component of the input geometry. Even if the instances contain geometry data with
   one of the other types, all instances will be added to this output.
   A :doc:`/modeling/geometry_nodes/instances/realize_instances` can be added to move the data from
   geometry instances to their corresponding outputs.


## Separate Geometry

.. index:: Geometry Nodes; Separate Geometry
.. _bpy.types.GeometryNodeSeparateGeometry:

**********************
Separate Geometry Node
**********************

.. figure:: /images/node-types_GeometryNodeSeparateGeometry.webp
   :align: right
   :alt: Separate Geometry node.

The *Separate Geometry* node produces two geometry outputs. Based on the *Selection* input,
the input geometry is split between the two outputs.

.. tip::

   This node can be combined with the :doc:`/modeling/geometry_nodes/utilities/math/compare`
   for a more precise control of which parts are separated to a given output geometry.


Inputs
======

Geometry
   Standard Geometry input.

Selection
   Boolean field used to calculate which output each part of the geometry will go to.
   Parts in the selection will move to the *Selection* output.
   Parts not in the selection will move to the *Inverted* output.


Properties
==========

Domain
   The domain on which the selection field is evaluated.

   :Point:
      The selection is on the points, control points, and vertices of the geometry.
   :Edge:
      The selection is on the edges of the mesh component. The other components
      are not modified.
   :Faces:
      The selection is on the faces of the mesh component. The other components
      are not modified.
   :Spline:
      The selection is on the splines in the curve component. For each spline, it
      is either entirely in the selection or not at all. The other components are not
      modified.

   .. note::

      When selecting a domain that doesn't modify all components, the unmodified
      components will appear in both outputs.


Outputs
=======

Selection
   The parts of the geometry in the selection.

Inverted
   The parts of the geometry not in the selection.


## Sort Elements

.. index:: Geometry Nodes; Sort Elements
.. _bpy.types.GeometryNodeSortElements:

******************
Sort Elements Node
******************

.. figure:: /images/node-types_GeometryNodeSortElements.png
   :align: right
   :alt: Sort Elements node.

The *Sort Elements* node rearranges geometry elements by changing their indices.


Inputs
======

Geometry
   Standard geometry input.

Selection
   The selection of elements to sort, if left blank, all elements are sorted.
   Non selected elements will be keep their current indices.

Group ID
   Elements with the same group ID are sorted together.
   If this is not a field, the node has no affect.

Sort Weight
   The sorted values used to do the reordering.
   If this is not a field, the node has no affect.


Properties
==========


Domain
   The domain on which the selection and group ID fields are evaluated.

   :Point:
      The fields are evaluated on points, control points, and vertices.
   :Edge:
      The fields are evaluated on the edges of the mesh component.
   :Faces:
      The fields are evaluated on the faces of the mesh component.
   :Spline:
      The fields are evaluated on the splines in the curve component.
   :Instance:
      The fields are evaluated on the top-level instances. Realized instances are ignored.


Outputs
=======

Geometry
   Standard geometry output.


## Split To Instances

.. index:: Geometry Nodes; Split To Instances
.. _bpy.types.GeometryNodeSplitToInstances:

***********************
Split To Instances Node
***********************

.. figure:: /images/node-types_GeometryNodeSplitToInstances.webp
   :align: right
   :alt: Split to Instance node.

The *Split to Instances* node splits up geometry elements into :doc:`/modeling/geometry_nodes/instances`,
based on a Group ID.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Boolean field that is true for parts of the geometry to be evaluated.
   Parts not in the selection will not be in the node's output.

Group ID
   ID field (integer) used to distinguish different groups.


Properties
==========

Domain
   The domain on which the selection and group ID fields are evaluated.

   :Point:
      The fields are evaluated on points, control points, and vertices.
   :Edge:
      The fields are evaluated on the edges of the mesh component.
   :Faces:
      The fields are evaluated on the faces of the mesh component.
   :Spline:
      The fields are evaluated on the splines in the curve component.
   :Instances:
      The fields are evaluated on the top-level instances. Realized instances are ignored.

.. note::

      When selecting a domain that doesn't modify all components, the unmodified
      components will not be present in the output.


Output
======

Instances
   input geometry splitted up as instances.

Group ID
   ID field from the input Group ID


Examples
========

.. figure:: /images/modeling_geometry-nodes_geometry_split-to-instances_example.png
   :align: center

   Here, a grid is split into instances based on a voronoi texture, then translated randomly in Z.
   Note that the GroupID field expects different integers values (0, 1, 2, 3…), not floats (0.1, 0.2, 0.3),
   which is why the color needs to be multiplied by 1000.




## Transform Geometry

.. index:: Geometry Nodes; Transform Geometry
.. _bpy.types.GeometryNodeTransform:

***********************
Transform Geometry Node
***********************

.. figure:: /images/node-types_GeometryNodeTransform.webp
   :align: right
   :alt: Transform Geometry node.
   :width: 190px

The *Transform Geometry Node* allows you to move, rotate or scale the geometry.
The transformation is applied to the entire geometry, and not per element.
The :doc:`/modeling/geometry_nodes/geometry/write/set_position` is used for moving
individual points of a geometry. For transforming instances individually, the instance
:doc:`translate </modeling/geometry_nodes/instances/translate_instances>`,
:doc:`rotate </modeling/geometry_nodes/instances/rotate_instances>`, or
:doc:`scale </modeling/geometry_nodes/instances/scale_instances>`
nodes can be used.


Inputs
======

Geometry
   Standard geometry input.

Translation
   Translation of the entire geometry in the local space of the modified object.

Rotation
   Euler rotation in the local space of the modified object.

Scale
   Scale for the geometry in the local space of the modified object.


Properties
==========

This node has no properties.


Output
======

Geometry
   Standard geometry output.


## Id

.. index:: Geometry Nodes; ID
.. _bpy.types.GeometryNodeInputID:

*******
ID Node
*******

.. figure:: /images/node-types_GeometryNodeInputID.webp
   :align: right
   :alt: ID node.

The *ID* node gives an integer value indicating the stable random identifier of each element on the point domain,
which is stored in the ``id`` attribute.

The node to set this data is the :doc:`/modeling/geometry_nodes/geometry/write/set_id` node.

.. note::

   Unlike other built-in attributes, the ``id`` attribute does not always exist.
   In that case, this node will output the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

ID
   Integer value.


## Index


#######################
  Read Geometry Nodes
#######################

.. toctree::
   :maxdepth: 1

   id.rst
   input_index.rst
   named_attribute.rst
   normal.rst
   position.rst
   radius.rst
   selection.rst


## Input Index

.. index:: Geometry Nodes; Index
.. _bpy.types.GeometryNodeInputIndex:

**********
Index Node
**********

.. figure:: /images/node-types_GeometryNodeInputIndex.webp
   :align: right
   :alt: Index node.

The *Index* node gives an integer value indicating the position of each element in the list,
starting at zero. This depends on the internal order of the data in the geometry, which is not
necessarily visible in the 3D Viewport. However, the index value is visible in the left-most column
in the :doc:`Spreadsheet Editor </editors/spreadsheet>`.

.. note::

   Indices in geometry data are often defined by the internals of complex algorithms that create it.
   If no inputs change, indices will be the same when the same node tree is executed multiple times.
   However, they may not be predictable when inputs to nodes that generate geometry or change its
   topology are adjusted. Additionally, updates to algorithms in newer versions of Blender may
   change the order of generated elements.

   To avoid relying on consistent indices, it is recommended to calculate them locally,
   or to avoid operations that change topology when they must be consistent over time.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Index
   Integer value which enumerates each point on the geometry.


## Named Attribute

.. index:: Geometry Nodes; Named Attribute
.. _bpy.types.GeometryNodeInputNamedAttribute:

********************
Named Attribute Node
********************

.. figure:: /images/node-types_GeometryNodeInputNamedAttribute.webp
   :align: right
   :alt: Named Attribute node.

The *Named Attribute* node outputs the data of an attribute based on the
context of where it is connected (the :ref:`field-context`).


Inputs
======

Name
   The name of the attribute to read.


Properties
==========

Data Type
   The :ref:`data type <attribute-data-types>` used for the retrieved data.
   :ref:`geometry-nodes-attribute-search` can be used to give a basic list of possible
   attribute names and data types. When a value is chosen from the search menu, the data
   type is set to automatically choose the data type from the geometry nodes result.

Outputs
=======

Attribute
   The attribute data stored on the geometry.

Exists
   True if the attribute accessed by the node is present in the connected context.


## Normal

.. index:: Geometry Nodes; Normal
.. _bpy.types.GeometryNodeInputNormal:

***********
Normal Node
***********

.. figure:: /images/node-types_GeometryNodeInputNormal.webp
   :align: right
   :alt: Normal node.

The *Normal* node returns a vector for each evaluated point indicating the
:ref:`normal direction <modeling-meshes-structure-normals>`. The output can depend
on the attribute domain used in the node evaluating the field, but the output
is always a normalized `unit vector <https://en.wikipedia.org/wiki/Unit_vector>`__.

:Face:
   On the face domain, the normal is the "up" direction of the face.

:Mesh Vertices:
   For mesh vertices, the normal is an average of the surrounding face normals.
   If the vertex does not have any connected faces, the output is simply the normalized position
   of that vertex.

:Edge:
   The normal output for each edge is the average of the edge's two vertex normals.

:Face Corner:
   The output for each face corner is the same as the face normal of the corresponding face.

:Curve Control Points:
   The output of this node when used for curve geometry is the evaluated normal of the curve,
   which depends on the twist method. The normal vector is always perpendicular to the direction
   of the curve's path at every point.

.. warning::

   For NURBS and Bézier spline curves, keep in mind that the value retrieved from this node is
   the value at every control point, which may not correspond to the visible *evaluated* points.
   For NURBS splines the difference may be even more pronounced and the result may not be as expected.
   A :doc:`/modeling/geometry_nodes/curve/operations/resample_curve` can be used to create a poly spline,
   where there is a control point for every evaluated point.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Normal
   Vector indicating the normal of each geometry element.


## Position

.. index:: Geometry Nodes; Position
.. _bpy.types.GeometryNodeInputPosition:

*************
Position Node
*************

.. figure:: /images/node-types_GeometryNodeInputPosition.webp
   :align: right
   :alt: Position node.

The *Position* node outputs a vector of each point of the geometry the node is connected to.

The node can work on geometry domains besides points. In that case, the position data will be
automatically interpolated to the new domain. For example, when used as part of the input to
the :doc:`/modeling/geometry_nodes/mesh/operations/split_edges`, the position for each edge
will be the average position of the edge's two vertices.

For instances themselves, the output is the origin of each instance. However, if the node is for
a geometry node that adjusts data inside instances, the position output of this node will be
in the local space of each instance. See the :ref:`geometry-nodes_instance-processing` page
for more details.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Position
   Vector that indicates the location of each element of the geometry.


## Radius

.. index:: Geometry Nodes; Radius
.. _bpy.types.GeometryNodeInputRadius:

***********
Radius Node
***********

.. figure:: /images/node-types_GeometryNodeInputRadius.webp
   :align: right
   :alt: Radius node.

The *Radius* node outputs the radius value at each point on the evaluated geometry.
For curves, this value is used for things like determining the size of the mesh created in
the :doc:`Curve to Mesh </modeling/geometry_nodes/curve/operations/curve_to_mesh>` node.
For point clouds, the value is used for the display size of the point in the viewport.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Radius
   Float value indicating radius at each point on the geometry.


## Selection

.. index:: Geometry Nodes; Selection
.. _bpy.types.GeometryNodeToolSelection:

**************
Selection Node
**************

.. figure:: /images/node-types_GeometryNodeToolSelection.webp
   :align: right
   :alt: Selection node.

The *Selection* node outputs true for geometry that is :doc:`selected </interface/selecting>`, and false elsewhere.

The corresponding data flow node is the :doc:`/modeling/geometry_nodes/geometry/write/set_selection`.

.. note::

   This node can only be used in the :ref:`Tool context <tool_context>`.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Selection
   Boolean field set to true for geometry that is selected in edit mode.


## Geometry Proximity

.. index:: Geometry Nodes; Geometry Proximity
.. _bpy.types.GeometryNodeProximity:

***********************
Geometry Proximity Node
***********************

.. figure:: /images/node-types_GeometryNodeProximity.webp
   :align: center
   :alt: Geometry Proximity node.

The *Geometry Proximity* node computes the closest location on the target geometry.

.. tip::

   The :doc:`/modeling/geometry_nodes/utilities/math/map_range` is often helpful to use with the distance
   output of this node to create a falloff with a maximum distance.


Inputs
======

Geometry
   Standard geometry input.

Sample Position
   The given position to calculate the closest location on the target.


Properties
==========

Target Element
   :Faces:
      Calculate the closest point anywhere on the faces of the target's mesh geometry.
   :Edges:
      Calculate the closest point anywhere on the edges of the target's mesh geometry.
   :Points:
      Calculate the closest point or vertex on the target geometry. This mode is usually the fastest.
      This mode works for both point cloud and mesh geometry, the other modes only work for meshes.


Outputs
=======

Position
   Closest location on the surface of the target mesh, or the closest point in the target point cloud
   in *Points* mode.

Distance
   Distance (as floating-point value) from the source position to the closest location in the target.


Examples
========

The different modes of the node: faces, edges and points.
In this example the Geometry Nodes modifier is added on the target plane.
Note that the larger plane is subdivided and the smaller plane is not.

.. figure:: /images/modeling_geometry-nodes_geometry-proximity_modes.png
   :align: center

   The three target element modes: faces, edges, and points.

.. figure:: /images/modeling_geometry-nodes_geometry-proximity_example.png
   :align: center

   Points distributed on a sphere used as a target for a distance used in a shader.


## Index


#########################
  Sample Geometry Nodes
#########################

.. toctree::
   :maxdepth: 1

   geometry_proximity.rst
   index_of_nearest.rst
   raycast.rst
   sample_index.rst
   sample_nearest.rst


## Index Of Nearest

.. index:: Geometry Nodes; Index of Nearest
.. _bpy.types.GeometryNodeIndexOfNearest:

****************
Index of Nearest
****************

.. figure:: /images/node-types_GeometryNodeIndexOfNearest.webp
   :align: right
   :alt: Index of Nearest node.
   :width: 300px


The **Index of Nearest** node is a way to find other close elements in the same geometry.
If needed you can use Group ID to determine the group of neighbors to be analyzed together.

This is an alternative to the :doc:`/modeling/geometry_nodes/geometry/sample/sample_nearest` node.
The main difference is that this node does not require a geometry input, because the geometry
from the :ref:`field context <field-context>` is used.

.. tip::

    This is often combined with the :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index` or
    the :doc:`/modeling/geometry_nodes/geometry/sample/sample_index` node.


Inputs
======

Position
   The position for each element to search.
   By default, this is the same as if the :doc:`/modeling/geometry_nodes/geometry/read/position` was connected.

Group ID
   ID to group elements together.


Outputs
=======

Index
   The :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
   of the closest element in the same geometry component.

Has Neighbor
   This is true when the group of the element has at least two elements.
   This is only relevant when using *Group ID*.


## Raycast

.. index:: Geometry Nodes; Raycast
.. _bpy.types.GeometryNodeRaycast:

************
Raycast Node
************

.. figure:: /images/node-types_GeometryNodeRaycast.webp
   :align: center
   :alt: Raycast node.

The *Raycast* node intersects rays from one geometry onto another. The source geometry is defined by
the context of the node that the *Raycast* node is connected to.
Each ray computes hit points on the target mesh and outputs normals, distances
and any surface attribute specified.


Inputs
======

Target Geometry
   Geometry that rays are tested against.

Attribute
   An optional field input evaluated on the *Target Geometry* that will be interpolated at the hit points.
   The resulting values are outputted with the *Attribute* output.

Source Position
   The position from where to start each ray. By default, this is the same as
   if the :doc:`/modeling/geometry_nodes/geometry/read/position` was connected.

Ray Direction
   Direction of each ray from the starting position.
   The field is evaluated on the geometry from the context of the field evaluation, not the *Target Geometry*.

Ray Length
   Maximum distance a ray can travel before being considered "no hit".


Properties
==========

Mapping
   How attributes of the target mesh are mapped to the attribute values on the result geometry.

   :Interpolated:
      Vertex and corner attributes are interpolated smoothly, with a bilinear function.
   :Nearest:
      Choose the value of the closest vertex without interpolating.


Outputs
=======

Is Hit
   Boolean output that is true for each ray which has hit the *Target Geometry*.

Hit Position
   The location of the intersection point with the target mesh.

Hit Normal
   The surface :term:`Normal` vector at the hit location.

Hit Distance
   The distance from the *Source Position* to the *Hit Position*.
   If the ray does not hit, the *Ray Length* is returned.

Attribute
   Interpolated values of the *Attribute* input sampled at the *Hit Position*.


## Sample Index

.. index:: Geometry Nodes; Sample Index
.. _bpy.types.GeometryNodeSampleIndex:

*****************
Sample Index Node
*****************

.. figure:: /images/node-types_GeometryNodeSampleIndex.webp
   :align: center
   :alt: Sample Index node.

The *Sample Index* node retrieves values from a source geometry at a specific index.

.. tip::

   If the *Geometry* used for the input is the same as the geometry from the :ref:`field context <field-context>`,
   this node is equivalent to the :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index`. Using that node
   is usually preferable since avoiding the geometry socket makes the whole setup easier to use in other situations
   and share.

.. tip::

   Different components can have same attribute domain (Points).
   This node simply uses first component that not empty for such domain,
   checked in the order of: Mesh, Point Cloud, Curve.
   The :doc:`/modeling/geometry_nodes/geometry/operations/separate_components` can be used to sample directly from a
   specific component.


Inputs
======

Geometry
   The geometry to retrieve the attribute from.

Value
   A field to evaluate on the source *Geometry*. The values are then retrieved from specific
   indices for the output.

Index
   Which index to use when retrieving the data from the input *Value* field. Any index can be
   connected, resulting in a "shuffling" of the values.


Properties
==========

Data Type
   The :ref:`data type <attribute-data-types>` to use for the retrieved values.

Domain
   The :ref:`attribute domain <attribute-domains>` that the attribute is transferred from, or in other words,
   the domain used to evaluate the *Attribute* input. For example, it is possible to transfer data from the
   faces of one geometry to the points of another.

Clamp
   Clamp the indices to the size of the attribute domain instead of outputting a default value for invalid indices.

Outputs
=======

Value
   The data retrieved from the source *Geometry* input.


Examples
========

.. figure:: /images/modeling_geometry-nodes_sample_index-example.png
   :align: center

   Here the node is used to copy the positions of one object to another. This recreates the behavior of the
   *Transfer Attribute* node from Blender versions before 3.4. This works best when their geometries have
   the same number of points and the same :term:`Topology`.


## Sample Nearest

.. index:: Geometry Nodes; Sample Nearest
.. _bpy.types.GeometryNodeSampleNearest:

*******************
Sample Nearest Node
*******************

.. figure:: /images/node-types_GeometryNodeSampleNearest.webp
   :align: center
   :alt: Sample Nearest node.

The *Sample Nearest* node retrieves the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
of the geometry element in its input geometry that is closest to the input position.

This node is similar to the :doc:`/modeling/geometry_nodes/geometry/sample/geometry_proximity`,
but it outputs the index of the closest element instead of its distance from the current location.

.. tip::

  If you want to find nearest to each point in same geometry, its better to use
  the :doc:`/modeling/geometry_nodes/geometry/sample/index_of_nearest` node.


Inputs
======

Geometry
   The geometry to sample.

   .. note::

      This node only supports point cloud and mesh inputs.

Sample Position
   The position to start from when finding the closest location on the target geometry.
   By default, this is the same as if the :doc:`/modeling/geometry_nodes/geometry/read/position` was connected.


Properties
==========

Domain
   The :ref:`attribute domain <attribute-domains>` to consider the distance from.


Outputs
=======

Index
   The :doc:`index </modeling/geometry_nodes/geometry/read/input_index>` of the closest geometry element of the
   chosen domain.


Examples
========

.. figure:: /images/modeling_geometry-nodes_sample_nearest-example.png
   :align: center

   Combining this node with the :doc:`/modeling/geometry_nodes/geometry/sample/sample_index` gives a setup that
   can retrieve the closest attribute value from another geometry. This is the same behavior as the
   *Transfer Attribute* node in versions of Blender before 3.4.


## Index


########################
  Write Geometry Nodes
########################

.. toctree::
   :maxdepth: 1

   set_id.rst
   set_position.rst
   set_selection.rst


## Set Id

.. index:: Geometry Nodes; Set ID
.. _bpy.types.GeometryNodeSetID:

***********
Set ID Node
***********

.. figure:: /images/node-types_GeometryNodeSetID.webp
   :align: right
   :alt: Set ID node.

The *Set ID* node fills the ``id`` attribute on the input geometry. If the attribute does not
exist yet, it will be created with a default value of zero. The ID is also created by
the :doc:`/modeling/geometry_nodes/point/distribute_points_on_faces`, and it is used in
the :doc:`/modeling/geometry_nodes/utilities/random_value` and other nodes if it exists.

The input node for this data is the :doc:`/modeling/geometry_nodes/geometry/read/id`.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Whether or not to change the value on each point or instance.
   True values mean the value will be changed, false values mean the value will remain the same.

ID
   The value for each element. By default, this input uses
   the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`, which is useful
   when stable IDs are desired when deleting a dynamic number of instances.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Set Position

.. index:: Geometry Nodes; Set Position
.. _bpy.types.GeometryNodeSetPosition:

*****************
Set Position Node
*****************

.. figure:: /images/node-types_GeometryNodeSetPosition.webp
   :align: right
   :alt: Set Position node.

The *Set Position* node controls the location of each point, the same way as controlling
the ``position`` attribute.
If the input geometry contains instances, this node will affect the location of the origin of each instance.

The input node for this data is the :doc:`/modeling/geometry_nodes/geometry/read/position`.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Whether or not to change the position of each point or instance.
   True values mean the position will be changed, false values mean it will remain the same.

Position
   The new position for selected elements. By default, this is the same as
   if the :doc:`/modeling/geometry_nodes/geometry/read/position` was connected,
   meaning the node will do nothing.

Offset
   An optional translation for each point. This is evaluated at the same time as the *Position* input,
   meaning that fields evaluated for it will not reflect the changed position.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Set Selection

.. index:: Geometry Nodes; Set Selection
.. _bpy.types.GeometryNodeToolSetSelection:

******************
Set Selection Node
******************

.. figure:: /images/node-types_GeometryNodeToolSetSelection.webp
   :align: right
   :alt: Set Selection node.

The *Set Selection* node controls which geometry is :doc:`selected </interface/selecting>`.

The input node for this data is the :doc:`/modeling/geometry_nodes/geometry/read/selection`.

.. note::

   This node can only be used in the :ref:`Tool context <tool_context>`.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Boolean field for specifying which elements should be selected in the output geometry.
   Elements for which this field evaluates to false are implicitly de-selected.


Properties
==========

Domain
   Which :ref:`domain <attribute-domains>` to set the selection on.


Outputs
=======

Geometry
   Standard geometry output.


## Index

.. index:: Geometry Nodes; Hair

##############
  Hair Nodes
##############

Nodes focussed on generating or editing curves, typically used for hair.

.. toctree::
   :maxdepth: 2

   Deformation <deformation/index.rst>
   Generation <generation/index.rst>
   Guides <guides/index.rst>
   Read <read/index.rst>
   Utility <utility/index.rst>
   Write <write/index.rst>


## Blend Hair Curves

.. index:: Geometry Nodes; Blend Hair Curves

*****************
Blend Hair Curves
*****************

Blends shape between multiple hair curves in a certain radius.

.. peertube:: kegHEYG8URADfPpBZ4jRUo

Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Factor
   Factor to blend overall effect.

Blend Radius
   Radius to select neighbors for blending.

Blend Neighbors
   Amount of neighbors used for blending.

Preserve Length
   Preserve each curve's length during deformation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Displace Hair Curves

.. index:: Geometry Nodes; Displace Hair Curves

********************
Displace Hair Curves
********************

Displaces hair curves by a vector based on various options.

.. peertube:: 8DP1hsJucDanf2s54P1qe3


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Factor
   Factor to scale overall displacement.

Shape
   Shape of the influence along curves (0=constant, 0.5=linear).

Object Space
   Object used to define the displacement space.

Displace Vector
   Vector for displacement.

Surface
   Surface geometry used to sample the normal for displacement. This input takes priority over the corresponding
   object input, if used.

Surface
   Surface object used to sample the normal for displacement.

Surface UV Map
   Surface UV map used to sample the normal for displacement.

Surface Normal Displacement
   Amount of displacement along the surface normal.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Frizz Hair Curves

.. index:: Geometry Nodes; Frizz Hair Curves

*****************
Frizz Hair Curves
*****************

Deforms hair curves using a random vector per point to frizz them.

.. peertube:: jdiMkR9aQnCm1QXc71Fz5h


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Cumulative Offset
   Apply offset cumulatively (previous points affect points after).

Factor
   Factor to blend overall effect.

Distance
   Overall distance factor for the deformation.

Shape
   Shape of the influence along curves (0=constant, 0.5=linear).

Seed
   Random Seed for the operation.

Preserve Length
   Preserve each curve's length during deformation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

Offset Vector
   Vector by which each point was offset during deformation.


## Hair Curves Noise

.. index:: Geometry Nodes; Hair Curves Noise

*****************
Hair Curves Noise
*****************

Deforms hair curves using a noise texture.

.. peertube:: eWCeePgTsA75Q8QhKQ6Qh9


Inputs
======

**Geometry**

Cumulative Offset
   Apply offset cumulatively (previous points affect points after).

Factor
   Overall factor for the deformation.

Distance
   Overall distance factor for the deformation.

Shape
   Shape of amount along each curve (0=constant, 0.5=linear).

Scale
   Scale of the noise texture by root position.

Scale along Curve
   Scale of noise texture along each Curve.

Offset per Curve
   Random offset of noise texture for each Curve.

Seed
   Seed value for randomization.

Preserve Length
   Preserve the length of the Curves on a segment basis.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

**Offset Vector**


## Index


##########################
  Hair Deformation Nodes
##########################

.. toctree::
   :maxdepth: 1

   blend_hair_curves.rst
   displace_hair_curves.rst
   frizz_hair_curves.rst
   hair_curves_noise.rst
   roll_hair_curves.rst
   rotate_hair_curves.rst
   shrinkwrap_hair_curves.rst
   smooth_hair_curves.rst
   straighten_hair_curves.rst
   trim_hair_curves.rst


## Roll Hair Curves

.. index:: Geometry Nodes; Roll Hair Curves

****************
Roll Hair Curves
****************

Rolls up hair curves starting from their tips.

.. peertube:: 5jrgEkcWH88fmL1MEsqQN2


Inputs
======

**Geometry**

Factor
   Factor to blend overall effect.

Subdivision
   Subdivision level applied before deformation.

Variation Level
   Level of smoothing on the roll path to include shape variation.

Roll Length
   Length of each curve to be rolled.

Roll Radius
   Radius of the rolls.

Roll Depth
   Depth offset of the roll.

Roll Taper
   Taper of the roll.

Retain Overall Shape
   Offset the roll along the original curve to retain shape.

Roll Direction
   Axis around which each curve is rolled.

Random Orientation
   Amount of randomization of the direction of the roll.

Seed
   Random Seed for the operation.

Preserve Length
   Preserve each curve's length during deformation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Rotate Hair Curves

.. index:: Geometry Nodes; Rotate Hair Curves

******************
Rotate Hair Curves
******************

Rotates each hair curve around an axis.

.. peertube:: dLEJ6ZgP1t9ksxfB3zHrsj


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Factor
   Factor to influence the rotation angle.

Axis
   Rotation Axis (Default: Tangent at root).

Angle
   Angle of rotation.

Random Offset
   Random offset to the rotation angle per Curve.

Lock Ends
   Lock rotation to the axis between the curve ends.

Seed
   Random Seed for the operation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Shrinkwrap Hair Curves

.. index:: Geometry Nodes; Shrinkwrap Hair Curves

**********************
Shrinkwrap Hair Curves
**********************

Shrinkwraps hair curves to a mesh surface from below and optionally from above.

.. peertube:: rA2Ytunkm2SorWhXeVQTWq


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Surface
   Surface geometry used for shrinkwrap. This input takes priority over the corresponding object input, if used.

Surface
   Surface object used for shrinkwrap.

Factor

Offset Distance
   Distance from the surface used for shrinkwrap.

Above Surface
   Blend shrinkwrap for points above the surface.

Smoothing Steps
   Amount of steps of smoothing applied after shrinkwrap.

Lock Roots
   Lock the position of root points.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Smooth Hair Curves

.. index:: Geometry Nodes; Smooth Hair Curves

******************
Smooth Hair Curves
******************

Smooths the shape of  hair curves.

.. peertube:: 7fpUB2eRT6zjMyHRzJ2ZoJ


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Amount
   Amount of smoothing. Negative values will result in crumpling the curves.

Shape
   Shape of the influence along curves (0=constant, 0.5=linear).

Iterations
   Amount of smoothing steps.

Weight
   Weight used for smoothing.

Lock Tips
   Lock tip position when smoothing.

Preserve Length
   Preserve each curve's length during deformation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Straighten Hair Curves

.. index:: Geometry Nodes; Straighten Hair Curves

**********************
Straighten Hair Curves
**********************

Straightens hair curves between root and tip.

.. peertube:: grmo32udHpGWz2TwdEp9GD


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Amount
   Amount of straightening. Negative values will result in crumpling the curves.

Shape
   Shape of the influence along curves (0=constant, 0.5=linear).

Preserve Length
   Preserve each curve's length during deformation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Trim Hair Curves

.. index:: Geometry Nodes; Trim Hair Curves

****************
Trim Hair Curves
****************

Trims or scales hair curves to a certain length.

.. peertube:: qfXRAqbL8MKus8YKMkUpE5


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Scale Uniform
   Scale each curve uniformly to reach the target length.

Length Factor
   Multiply the original length by a factor.

Replace Length
   Use the length input to fully replace the original length.

Length
   Target length for the operation.

Mask
   Mask to blend overall effect.

Random Offset
   Trim hair curves randomly up to a certain amount.

Pin at Parameter
   Pin each curve at a certain point for the operation.

Seed
   Random Seed for the operation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Duplicate Hair Curves

.. index:: Geometry Nodes; Duplicate Hair Curves

*********************
Duplicate Hair Curves
*********************

Duplicates hair curves a certain number of times within a radius.

.. peertube:: es5bkTNvRwrvUFdjuK1UvB

Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Amount
   Amount of duplicates per curve.

Viewport Amount
   Percentage of amount used for the viewport.

Radius
   Radius in which the duplicate curves are offset from the guides.

Distribution Shape
   Shape of distribution from center to the edge around the guide.

Tip Roundness
   Offset of the curves to round the tip.

Even Thickness
   Keep an even thickness of the distribution of duplicates.

Seed
   Random Seed for the operation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

Guide Index
   Guide index map that was used for the operation.


## Generate Hair Curves

.. index:: Geometry Nodes; Generate Hair Curves

********************
Generate Hair Curves
********************

Generates new hair curves on a surface mesh.
The curves are generated from scratch at point locations; if creating curves that depend on
existing curves is desired, the :doc:`/modeling/geometry_nodes/hair/generation/interpolate_hair_curves`
is a better choice.

.. note::

   This node/modifier will not function without the *Surface* geometry/object and *Surface UV Map* inputs.

.. peertube:: nkB43evNMakLmvuoExgKuF


Inputs
======

Surface
   Surface geometry for generation. This input takes priority over the corresponding object input if both are
   provided.

Surface
   Surface object for generation (The transforms of this object must match the modifier object).

Surface UV Map
   Surface UV map stored on the mesh used for finding curve attachment locations.

Surface Rest Position
   Set the surface mesh into its rest position before attachment.

   .. tip::

      In a typical hair generation setup, this node or modifier will be
      combined with the :doc:`/modeling/geometry_nodes/curve/operations/deform_curves_on_surface`.
      If that operation comes after this one, it makes sense to turn this option on so the
      position used is the pre-deformed position consistent with the expectations for the
      deformation's input.

Hair Length
   Length of the generated hair curves.

Hair Material
   Material of the generated hair curves.

Control Points
   Amount of control points of the generated hair curves.

Poisson Disk Distribution
   Use poisson disk distribution method to keep a minimum distance.
   See the :doc:`/modeling/geometry_nodes/point/distribute_points_on_faces` for more information.

Density
   Surface density of generated hair curves.

Density Mask
   Factor applied on the density for curve distribution.

Mask Texture
   Discard points based on an mask texture after distribution.
   The image is sampled with the *Surface UV Map* input.

   .. tip::

      The accuracy of sampling the image doesn't depend on the density of the surface mesh's vertices
      because it is sampled after the curve root points are generated, the accuracy . However, using
      the *Density Mask* input instead can give better performance. Using them in combination can
      give the benefits of both methods.

Viewport Amount
   Factor applied on the density for the viewport.

Seed
   Random seed for the operation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

**Curves**

Surface Normal
   Normal direction of the surface mesh at the attachment point.


## Index


#########################
  Hair Generation Nodes
#########################

.. toctree::
   :maxdepth: 1

   duplicate_hair_curves.rst
   generate_hair_curves.rst
   interpolate_hair_curves.rst


## Interpolate Hair Curves

.. index:: Geometry Nodes; Interpolate Hair Curves

***********************
Interpolate Hair Curves
***********************

Interpolates existing guide curves on a surface mesh.
The :doc:`/modeling/geometry_nodes/hair/generation/duplicate_hair_curves` is a similar option with simpler
behavior that may offer better performance.

.. note::

   This node/modifier will not function without the *Surface* geometry/object and *Surface UV Map* inputs.

.. peertube:: 4dt7vp3qmry5MPZC3usxVb

Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Surface
   Surface geometry for generation. This input takes priority over the corresponding object input if both are
   provided.

Surface
   Surface object for generation (Needs matching transforms).

Surface UV Map
   Surface UV map stored on the mesh used for finding curve attachment locations.

Surface Rest Position
   Set the surface mesh into its rest position before attachment.

   .. tip::

      In a typical hair generation setup, this node or modifier will be
      combined with the :doc:`/modeling/geometry_nodes/curve/operations/deform_curves_on_surface`.
      If that operation comes after this one, it makes sense to turn this option on so the
      position used is the pre-deformed position consistent with the expectations for the
      deformation's input.

Follow Surface Normal
   Align the interpolated curves to the surface normal.

Part by Mesh Islands
   Use mesh islands of the surface geometry for parting.

Interpolation Guides
   Amount of guides to be used for interpolation per curve.

Distance to Guides
   Distance around each guide to spawn interpolated curves.

Poisson Disk Distribution
   Use poisson disk distribution method to keep a minimum distance.

Density
   Surface density of generated hair curves.

Density Mask
   Factor applied on the density for curve distribution.

Mask Texture
   Discard points based on an mask texture after distribution.
   The image is sampled with the *Surface UV Map* input.

   .. tip::

      The accuracy of sampling the image doesn't depend on the density of the surface mesh's vertices
      because it is sampled after the curve root points are generated, the accuracy . However, using
      the *Density Mask* input instead can give better performance. Using them in combination can
      give the benefits of both methods.

Viewport Amount
   Factor applied on the density for the viewport.

Seed
   Random seed for the operation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

Guide Index
   Index of the main guide curve per curve.

Surface Normal
   Normal direction of the surface mesh at the attachment point.


## Braid Hair Curves

.. index:: Geometry Nodes; Braid Hair Curves

*****************
Braid Hair Curves
*****************

Deforms existing hair curves into braids using guide curves.

.. peertube:: wqJoqfqsWvT6msnD75RV2Q


Inputs
======

**Geometry**

Guide Index
   Guide index map witch describes which curve to use as the center of each braid group.
   If this input is provided, it priority over an existing map in the ``guide_curve_index``
   attribute, and the *Guide Distance* and *Guide Mask* attribute will be unused.

Guide Distance
   Minimum distance between two guides for new guide map.

Guide Mask
   Mask for which curve are eligible to be selected as guides.

Existing Guide Map
   Use the existing guide map attribute if available. If this is false, and the *Guide Index*
   input isn't provided, the *Guide Distance* and *Guide Mask* input will be used to generate
   a new :doc:`guide map </modeling/geometry_nodes/hair/guides/create_guide_index_map>` for this node.
   Creating the guide map in a separate node or modifier gives more complete control over its creation.

Factor
   Factor to blend overall effect.

Subdivision
   Subdivision level applied before deformation.

Braid Start
   Percentage along each curve to blend deformation from the root.

Radius
   Overall radius of the braids.

Shape
   Shape of the braid radius along each curve.

Factor Min
   Factor of the minimum radius of the braids.

Factor Max
   Factor of the maximum radius of the braids.

Frequency
   Frequency factor of the braids.
   This input can vary for different points of the same curve.

Thickness
   Thickness of each strand of hair.

Thickness Shape
   Shape adjustment of the strand thickness for the braids.

Shape Asymmetry
   Asymmetry of the shape adjustment of the strand thickness.

Flare Length
   Length of the flare at the end of the braid.

Flare Opening
   Opening radius of the flare at the tip of the braid.

Hair Tie
   Geometry used for the hair tie instance (priority).

Hair Tie
   Object used for the hair tie instance.

Hair Tie Scale
   Scale of the hair tie instance.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

Guide Index
   Guide index map that was used for the operation.
   If a new guide map is created by this node, it will be stored for
   this output.

Flare Parameter
   Parameter from 0 to 1 along the flare.

Strand Index
   Index of the group of hair in the braid that each hair curve belongs to.


## Clump Hair Curves

.. index:: Geometry Nodes; Clump Hair Curves

*****************
Clump Hair Curves
*****************

Clumps together existing hair curves using guide curves.

.. peertube:: gnhg72C8JoNYmNy441QHgt


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Guide Index
   Guide index map witch describes which curve to use as the center of each braid group.
   If this input is provided, it priority over an existing map in the ``guide_curve_index``
   attribute, and the *Guide Distance* and *Guide Mask* attribute will be unused.

Guide Distance
   Minimum distance between two guides for new guide map.

Guide Mask
   Mask for which curve are eligible to be selected as guides.

Existing Guide Map
   Use the existing guide map attribute if available. If this is false, and the *Guide Index*
   input isn't provided, the *Guide Distance* and *Guide Mask* input will be used to generate
   a new :doc:`guide map </modeling/geometry_nodes/hair/guides/create_guide_index_map>` for this node.
   Creating the guide map in a separate node or modifier gives more complete control over its creation.

Factor
   Factor to blend overall effect.

Shape
   Shape of the influence along curves (0=constant, 0.5=linear).

Tip Spread
   Distance of random spread at the curve tips.

Clump Offset
   Offset of each clump in a random direction.

Distance Falloff
   Falloff distance for the clumping effect (0 means no falloff).

Distance Threshold
   Distance threshold for the falloff around the guide.

Seed
   Random seed for the operation.

Preserve Length
   Preserve each curve's length during deformation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

Guide Index
   Guide index map that was used for the operation.
   If a new guide map is created by this node, it will be stored for
   this output.


## Create Guide Index Map

.. index:: Geometry Nodes; Create Guide Index Map

**********************
Create Guide Index Map
**********************

Creates an integer attribute named ``guide_curve_index`` that stores
the nearest guide curve for every curve to its nearest guide via index.

Other nodes in the :doc:`/modeling/geometry_nodes/hair/guides/index`
category can generate guide maps themselves for convenience, but the behavior is
always the same as this node.

.. peertube:: cPLeMHSnPYidQmJezdhcyL


Inputs
======

**Geometry**

Guides
   Guide Curves or Points used for the selection of Guide Curves.

Guide Distance
   Minimum distance between two guides.

Guide Mask
   Mask for which curve are eligible to be selected as guides.

Group ID
   ID to group together curves for guide map creation.
   Curves will only choose a guide with the same ID value.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Output geometry including the new map attribute and the guide selection
   :ref:`anonymous attribute <anonymous-attributes>` as well. This geometry
   includes the guide curves, they are not separated.

Guide Curves
   Output geometry including only the selected guide curves.

Guide Index
   The index of the closest curve with the same *Group ID* value.

Guide Selection
   A selection in the *Geometry* output set to true for only the curves
   that were chosen as guides.


## Curl Hair Curves

.. index:: Geometry Nodes; Curl Hair Curves

****************
Curl Hair Curves
****************

Deforms existing hair curves into curls using guide curves.

.. peertube:: 3AcYeH2nqMzjEXFUNqTbj7


Inputs
======

**Geometry**

Guide Index
   Guide index map witch describes which curve to use as the center of each braid group.
   If this input is provided, it priority over an existing map in the ``guide_curve_index``
   attribute, and the *Guide Distance* and *Guide Mask* attribute will be unused.

Guide Distance
   Minimum distance between two guides for new guide map.

Guide Mask
   Mask for which curve are eligible to be selected as guides.

Existing Guide Map
   Use the existing guide map attribute if available. If this is false, and the *Guide Index*
   input isn't provided, the *Guide Distance* and *Guide Mask* input will be used to generate
   a new :doc:`guide map </modeling/geometry_nodes/hair/guides/create_guide_index_map>` for this node.
   Creating the guide map in a separate node or modifier gives more complete control over its creation.

Factor
   Factor to blend overall effect.

Subdivision
   Subdivision level applied before deformation.

Curl Start
   Percentage along each curve to blend deformation from the root.

Radius
   Overall radius of the curls.

Factor Start
   Factor for the radius at the curl start.

Factor End
   Factor for the radius at the curl end.

Frequency
   Frequency factor of the curls.
   This input can vary for different points of the same curve.

Random Offset
   Amount of random offset per curve.

Seed
   Random Seed for the operation.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

Guide Index
   Guide index map that was used for the operation.
   If a new guide map is created by this node, it will be stored for
   this output.


## Index


#####################
  Hair Guides Nodes
#####################

.. toctree::
   :maxdepth: 1

   braid_hair_curves.rst
   clump_hair_curves.rst
   create_guide_index_map.rst
   curl_hair_curves.rst


## Curve Info

.. index:: Geometry Nodes; Curve Info

**********
Curve Info
**********

Reads information about each curve.

.. peertube:: 2tqKoeqhj6dbwMzHeEd9yQ


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Curve Index
   Index of each Curve.

Curve ID
   ID of each Curve.

Length
   Length of each Curve.

Direction
   Direction from root to tip of each Curve.

Random
   Random vector for each Curve.

Surface UV
   Attachment surface UV coordinate of each Curve.


## Curve Root

.. index:: Geometry Nodes; Curve Root

**********
Curve Root
**********

Reads information about each curve's root point.

.. peertube:: mMFF7YU4uJ7SXtJR7BdV5Q


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Root Selection
   Boolean selection of curve root points.

Root Position
   Position of the root point of a Curve.

Root Direction
   Direction of the root segment of a Curve.

Root Index
   Index of the root point of a Curve.


## Curve Segment

.. index:: Geometry Nodes; Curve Segment

*************
Curve Segment
*************

Reads information each point's previous curve segment.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Segment Length
   Distance to previous point on Curve.

Segment Direction
   Direction from previous neighboring point on segment.

Neighbor Index
   Index of previous neighboring point on segment.


## Curve Tip

.. index:: Geometry Nodes; Curve Tip

*********
Curve Tip
*********

Reads information about each curve's tip point.

.. peertube:: pcyUMH2SZ2DtwuDVF1bQio


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Tip Selection
   Boolean selection of curve tip points.

Tip Position
   Position of the tip point of a Curve.

Tip Direction
   Direction of the tip segment of a Curve.

Tip Index
   Index of the tip point of a Curve.


## Hair Attachment Info

.. index:: Geometry Nodes; Hair Attachment Info

********************
Hair Attachment Info
********************

Reads attachment information regarding a surface mesh.


Inputs
======

Surface Geometry
   Surface geometry of the curve attachment.

Surface UV Map
   Surface UV map stored on the mesh used for finding curve attachment locations.


Properties
==========

This node has no properties.


Outputs
=======

Attachment UV
   Surface attachment UV coordinate stored on each curve.

Attachment is Valid
   Whether the stored attachment UV coordinate is valid.

Surface Normal
   Normal direction of the surface mesh at the attachment point.


## Index


###################
  Hair Read Nodes
###################

.. toctree::
   :maxdepth: 1

   curve_info.rst
   curve_root.rst
   curve_segment.rst
   curve_tip.rst
   hair_attachment_info.rst


## Attach Hair Curves To Surface

.. index:: Geometry Nodes; Attach Hair Curves to Surface

*****************************
Attach Hair Curves to Surface
*****************************

Attaches hair curves to a surface mesh.

.. note::

   This node/modifier will not function without the *Surface* geometry/object and *Surface UV Map* inputs.

.. peertube:: keeNa3Rpe7grQvX5d35w8H


Inputs
======

Geometry
   Input Geometry (only curves will be affected).

Surface
   Surface Geometry to attach hair curves to. This input takes priority over the corresponding object input, if used.

Surface
   Surface Object to attach to (needs to have matching transforms).

Surface UV Map
   Surface UV map stored on the mesh used for finding curve attachment locations.

Surface Rest Position
   Set the surface mesh into its rest position before attachment.

   .. tip::

      In a typical hair generation setup, this node or modifier will be
      combined with the :doc:`/modeling/geometry_nodes/curve/operations/deform_curves_on_surface`.
      If that operation comes after this one, it makes sense to turn this option on so the
      position used is the pre-deformed position consistent with the expectations for the
      deformation's input.

Sample Attachment UV
   Sample the surface UV map at the attachment point.

Snap to Surface
   Snap the root of each curve to the closest surface point.

Align to Surface Normal
   Align the curve to the surface normal (need guide as reference).

Blend along Curve
   Blend deformation along each curve from the root.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**

Surface UV Coordinate
   Surface UV coordinate at the attachment point.

Surface Normal
   Surface normal at the attachment point.


## Index


######################
  Hair Utility Nodes
######################

.. toctree::
   :maxdepth: 1

   attach_hair_curves_to_surface.rst
   redistribute_curve_points.rst
   restore_curve_segment_length.rst


## Redistribute Curve Points

.. index:: Geometry Nodes; Redistribute Curve Points

*************************
Redistribute Curve Points
*************************

Redistributes existing control points evenly along each curve.

.. peertube:: syFssvhthKJUo45B2dxw5W


Inputs
======

**Curves**

Factor
   Factor to blend overall effect.

Feature Awareness
   Use simple feature awareness to keep feature definition.


Properties
==========

This node has no properties.


Outputs
=======

**Curves**


## Restore Curve Segment Length

.. index:: Geometry Nodes; Restore Curve Segment Length

****************************
Restore Curve Segment Length
****************************

Restores the length of each curve segment using a previous state after deformation.

.. peertube:: vCkQDxPe65KBTEHwfHUivN


Inputs
======

**Curves**

Selection
   Only affect selected elements.

Factor
   Factor to blend overall effect.

Reference Position
   Reference position before deformation.

Pin at Parameter
   Pin each curve at a certain point for the operation.


Properties
==========

This node has no properties.


Outputs
=======

**Curves**


## Index


####################
  Write Hair Nodes
####################

.. toctree::
   :maxdepth: 1

   set_hair_curve_profile.rst


## Set Hair Curve Profile

.. index:: Geometry Nodes; Set Hair Curve Profile

**********************
Set Hair Curve Profile
**********************

Sets the radius attribute of hair curves according to a profile shape.

.. peertube:: gpQi2ZRQ3usV1FbQ9p3FHw


Inputs
======

**Geometry**

Replace Radius
   Replace the original radius.

Radius
   Base radius to be set if *Replace Radius* is enabled.

Shape
   Shape of the radius along the curve.

Factor Min
   Factor of the radius at the minimum.

Factor Max
   Factor of the radius at the maximum.


Properties
==========

This node has no properties.


Outputs
=======

**Geometry**


## Index


###############
  Input Nodes
###############

Nodes used mainly as input to other nodes.

.. toctree::
   :maxdepth: 1

   Constant <constant/index.rst>
   Scene <scene/index.rst>


## Boolean

.. index:: Geometry Nodes; Boolean
.. _bpy.types.FunctionNodeInputBool:

************
Boolean Node
************

.. figure:: /images/node-types_FunctionNodeInputBool.webp
   :align: right
   :alt: Boolean node.

The *Boolean* node provides a Boolean value.


Inputs
======

This node has no input sockets.


Properties
==========

Single Boolean value (true/false).


Outputs
=======

Boolean
   Standard Boolean output.


## Color

.. index:: Geometry Nodes; Color
.. _bpy.types.FunctionNodeInputColor:

**********
Color Node
**********

.. figure:: /images/node-types_FunctionNodeInputColor.webp
   :align: right
   :alt: Color node.

The *Color* node outputs the color value chosen with the color picker widget.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Color
   Color value indicated by the color picker widget.


## Image

.. index:: Geometry Nodes; Image
.. _bpy.types.GeometryNodeInputImage:

**********
Image Node
**********

.. figure:: /images/node-types_GeometryNodeInputImage.webp
   :align: right
   :width: 300px

   Image node.

The *Image* node provides access to a image file which allows you to
conveniently enter and switch images for multiple nodes in the tree.

.. seealso::

   :doc:`/modeling/geometry_nodes/input/scene/image_info`


Inputs
======

This node has no inputs.


Properties
==========

Image Data-Block
   The :ref:`data-block selector <ui-data-block>` to select an existing image or open an image from the file browser.


Outputs
=======

Image
   The image file chosen from the data-block selector.


## Index


########################
  Input Constant Nodes
########################

Nodes used mainly as input to other nodes.

.. toctree::
   :maxdepth: 1

   boolean.rst
   color.rst
   image.rst
   integer.rst
   material.rst
   string.rst
   value.rst
   vector.rst


## Integer

.. index:: Geometry Nodes; Integer
.. _bpy.types.FunctionNodeInputInt:

************
Integer Node
************

.. figure:: /images/node-types_FunctionNodeInputInt.webp
   :align: right
   :alt: Integer node.

The *Integer* node provides an integer value.


Inputs
======

This node has no input sockets.


Properties
==========

Single integer value.


Outputs
=======

Integer
   Standard integer output


## Material

.. index:: Geometry Nodes; Material
.. _bpy.types.GeometryNodeInputMaterial:

*************
Material Node
*************

.. figure:: /images/node-types_GeometryNodeInputMaterial.webp
   :align: right
   :width: 300px
   :alt: Material Input Node.

The *Material* input node outputs a single material. It can be connected to other material sockets
to make using the same material name in multiple places more convenient.

.. tip::

   The Material node can also be added by dragging and dropping a material data-block into the node editor.
   This will add the node and select the dropped material in the :ref:`ui-data-block`.


Inputs
======

This node has no inputs.


Properties
==========

- Material


Output
======

Material
   A reference to the selected material.


## String

.. index:: Geometry Nodes; String
.. _bpy.types.FunctionNodeInputString:

***********
String Node
***********

.. figure:: /images/node-types_FunctionNodeInputString.webp
   :align: right
   :alt: String Input Node.

The *String* input node creates a single string. It can be connected to attribute name sockets
to make using the same attribute name in multiple places more convenient.


Inputs
======

This node has no inputs.


Properties
==========

- String


Output
======

String
   Standard string output.


## Value

.. index:: Geometry Nodes; Value
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /compositing/types/input/constant/value.rst
   :start-after: .. --- copy below this line ---


## Vector

.. index:: Geometry Nodes; Vector
.. _bpy.types.FunctionNodeInputVector:

***********
Vector Node
***********

.. figure:: /images/node-types_FunctionNodeInputVector.webp
   :align: right
   :alt: Vector Node.

The *Vector* input node creates a single vector.


Inputs
======

This node has no inputs.


Properties
==========

- X
- Y
- Z


Output
======

Vector
   Standard vector output.


## 3D Cursor

.. index:: Geometry Nodes; 3D Cursor
.. _bpy.types.GeometryNodeTool3DCursor:

**************
3D Cursor Node
**************

.. figure:: /images/node-types_GeometryNodeTool3DCursor.webp
   :align: right
   :alt: 3D Cursor node.

The *3D Cursor* node outputs the position and orientation of the 3D cursor in the scene.

.. note::

   This node can only be used in the :ref:`Tool context <tool_context>`.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Location
   The position of the 3D cursor.

Rotation
   The orientation of the 3D cursor as a standard rotation value.


## Active Camera

.. index:: Geometry Nodes; Active Camera
.. _bpy.types.GeometryNodeInputActiveCamera:

******************
Active Camera Node
******************

.. figure:: /images/node-types_GeometryNodeInputActiveCamera.webp
   :align: right
   :alt: Active Camera node.

The *Active Camera* node outputs the scene's current active camera.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Active Camera
   Current active camera.


## Collection Info

.. index:: Geometry Nodes; Collection Info
.. _bpy.types.GeometryNodeCollectionInfo:

********************
Collection Info Node
********************

.. figure:: /images/node-types_GeometryNodeCollectionInfo.webp
   :align: right
   :alt: Collection Info node.
   :width: 190px

The *Collection Info* node gets information from collections.
This can be useful to control parameters in the geometry node tree with an external collection.

.. tip::

   A *Collection Info* node can be added quickly by dragging a collection into the node editor.


Inputs
======

Collection
   Collection to get the properties from.

Separate Children
   Output each child of the collection as a separate instance. The list of instances will be sorted
   alphabetically with the objects and child collections sorted together. This can be used with
   the *Pick Instance* option in the :doc:`/modeling/geometry_nodes/instances/instance_on_points` to
   choose between collection children at each point.

Reset Children
   Remove the transform of each of the collection's children when converting them to instances.
   This is useful in order to keep child objects visually separate in the viewport,
   while keeping every instance located directly at the location of the point it was added for.


Properties
==========

Transform Space
   The transformation of the output instances. The instances are transformed, but not the geometry of the
   collection in them.

   :Original:
      Output the instances relative to the collection offset.
   :Relative:
      Join the input collection instances with the modified object as geometry,
      maintaining the relative position between the objects in the scene.


Outputs
=======

Instances
   Instances of the collection in world space with all modifiers applied and represented as geometry in instances.


## Image Info

.. index:: Geometry Nodes; Image Info
.. _bpy.types.GeometryNodeImageInfo:

***************
Image Info Node
***************

.. figure:: /images/node-types_GeometryNodeImageInfo.webp
   :align: right
   :alt: Image Info node.
   :width: 300px


The *Image Info* node gets information from image and animation.
This can be useful to generate parameters in the geometry node for arbitrary images. Image information can be either
general or frame-specific.

Inputs
======

Image
   Source image to get parameters from.

Frame
   Frame index for frame-specific outputs.


Properties
==========

This node has no properties.


Outputs
=======

Width
   The number of pixels along the X axis. Specific to each frame.

Height
   The number of pixels along the Y axis. Specific to each frame.

Has Alpha
   Whether the transparency channel be different from 1 for the pixels of this image frame. Specific to each frame.

Frame Count
   The number of frames in an image or video frame sequence. For a static image, always 1.

FPS
   The number of frames per second. For static image is always 0.


## Index


##########################
  Input Scene Data Nodes
##########################

.. toctree::
   :maxdepth: 1

   3d_cursor.rst
   active_camera.rst
   collection_info.rst
   image_info.rst
   is_viewport.rst
   object_info.rst
   scene_time.rst
   self_object.rst


## Is Viewport

.. index:: Geometry Nodes; Is Viewport
.. _bpy.types.GeometryNodeIsViewport:

****************
Is Viewport Node
****************

.. figure:: /images/node-types_GeometryNodeIsViewport.webp
   :align: right
   :alt: Is Viewport Node.

The *Is Viewport* node outputs true when geometry nodes are evaluated for the viewport.
For the final render the node outputs false.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Is Viewport
   Boolean value that indicates whether geometry nodes are evaluated for preview.


## Object Info

.. index:: Geometry Nodes; Object Info
.. _bpy.types.GeometryNodeObjectInfo:

****************
Object Info Node
****************

.. figure:: /images/node-types_GeometryNodeObjectInfo.webp
   :align: right
   :alt: Object Info node.

The *Object Info* node gets information from objects.
This can be useful to control parameters in the geometry node tree with an external object,
either directly by using its geometry, or via its transformation properties.

An *Object Info* node can be added quickly by dragging an object into the node editor.


Inputs
======

Object
   Object to get the properties from.

As Instance
   Output the entire object as single instance instead of realized geometry.
   This allows instancing non-geometry object types, because the output will contain an instance of the object.

Properties
==========

Transform Space
   The transformation of the vector and geometry outputs.

   :Original:
      Output the geometry relative to the input object transform, and the location,
      rotation and scale relative to the world origin.
   :Relative:
      Bring the input object geometry, location, rotation and scale into the modified object,
      maintaining the relative position between the two objects in the scene.


Outputs
=======

Location
   Location of the object in world space.
Rotation
   Rotation of the object in world space.
Scale
   Scale of the object in world space.

Geometry
   Geometry of the object in world space with all its modifiers applied.


## Scene Time

.. index:: Geometry Nodes; Scene Time
.. _bpy.types.GeometryNodeInputSceneTime:

.. --- copy below this line ---

***************
Scene Time Node
***************

.. figure:: /images/node-types_GeometryNodeInputSceneTime.webp
   :align: right
   :alt: Scene Time node.

The *Scene Time* node outputs the current time in the scene's animation in units of seconds or frames.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Seconds
   Current scene time in seconds.

Frames
   Current scene frame.
   As an input in geometry nodes, this output may also output non-round numbers,
   in order to support higher quality :doc:`motion blur </render/eevee/render_settings/motion_blur>`.


## Self Object

.. index:: Geometry Nodes; Self Object
.. _bpy.types.GeometryNodeSelfObject:

****************
Self Object Node
****************

.. figure:: /images/node-types_GeometryNodeSelfObject.webp
   :align: right
   :alt: Self Object node.

The *Self Object* node outputs the object that contains the geometry nodes modifier
currently being executed. This can be used to retrieve the original transforms.

When evaluated in the :ref:`Tool context <tool_context>`, this node returns the Active object.

.. note::

   The geometry cannot be retrieved from this object with the
   :doc:`/modeling/geometry_nodes/input/scene/object_info`, since its final geometry is still
   being evaluated.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Self Object
   The object currently being evaluated.


## Index


###################
  Instances Nodes
###################

Nodes that only operate on instances.

.. toctree::
   :maxdepth: 1

   instance_on_points.rst
   instances_to_points.rst
   rotate_instances.rst
   scale_instances.rst
   translate_instances.rst
   realize_instances.rst

----

.. toctree::
   :maxdepth: 1

   instance_rotation.rst
   instance_scale.rst


## Instances To Points

.. index:: Geometry Nodes; Instances to Points
.. _bpy.types.GeometryNodeInstancesToPoints:

************************
Instances to Points Node
************************

.. figure:: /images/node-types_GeometryNodeInstancesToPoints.webp
   :align: right
   :alt: Instances to Points node.

The *Instances to Points* node generates points at the origins of top-level instances.
Attributes on the :ref:`instance domain <attribute-domains>` are moved to the point cloud points.

.. note::

   Top-level instances are those that are owned by the node's input geometry.
   Instances owned by other instances, i.e. nested instances, are not considered
   by this node.


Inputs
======

Instances
   Standard geometry input.

Selection
   The instances used to generate points. True values mean a point is created for the instance,
   false values mean the instance is skipped.

Position
   Overrides the default position of generated point.

Radius
   Controls the radius of the result points.


Properties
==========

This node has no properties.


Outputs
=======

Points
   Standard geometry output.


## Instance On Points

.. index:: Geometry Nodes; Instance on Points
.. _bpy.types.GeometryNodeInstanceOnPoints:

***********************
Instance on Points Node
***********************

.. figure:: /images/node-types_GeometryNodeInstanceOnPoints.webp
   :align: center
   :alt: Instance on Points node.

The *Instance on Points* node adds a reference to a geometry to each of the points present
in the input geometry. Instances are a fast way to add the same geometry to a scene many times
without duplicating the underlying data. The node works on any geometry type
with a *Point* domain, including meshes, point clouds, and curve control points.

Any attributes on the points from the *Geometry* input will be available on the instance
domain of the generated instances.

.. tip::

   The :ref:`bpy.ops.object.duplicates_make_real` operator can be used to create objects
   from instances generated with this node.

.. note::

   To instance object types that do not contain geometry, like a light object, the
   :doc:`/modeling/geometry_nodes/input/scene/object_info` can be used. Other objects like
   :doc:`Metaball </modeling/metas/introduction>` objects are not supported for instancing.

Inputs
======

Points
   Standard geometry input. The position of the points of this geometry affect the transforms of
   each instance output.

   .. note::

      If the input geometry contains instances, the node will create more instances on
      the points inside the instances, creating :ref:`nested instancing <geometry-nodes_nested-instancing>`.
      In this case, each new instance will have the transform created by the node from the *Rotation*
      and *Scale* inputs, but it will *also* be transformed based on the parent instances.

Selection
   Whether to instance on each point. True values mean an instance will be generated on the point,
   false values mean the point will be skipped.

Instance
   The geometry to instance on each selected point. This can contain real geometry, or multiple instances,
   which can be useful when combined with the *Pick Instance* option.

Pick Instances
   If enabled, instead of adding the entire geometry from the *Instance* input on every point,
   choose an instance from the instance list of the geometry based on the *Instance Index* input.
   This option is intended to be used with the :doc:`/modeling/geometry_nodes/input/scene/collection_info`.

Instance Index
   The selection of index for every selected point, only used when *Pick Instances* is true.
   By default the point :doc:`ID </modeling/geometry_nodes/geometry/read/id>` is used,
   or the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>` if that doesn't exist.
   Negative values or values that are too large are wrapped around to the other end of
   the instance list.

Rotation
   The :term:`Euler` rotation for every instance. This can use the rotation output of nodes like
   :doc:`Distribute Points on Faces </modeling/geometry_nodes/point/distribute_points_on_faces>`
   and :doc:`Curve to Points </modeling/geometry_nodes/curve/operations/curve_to_points>`. An Euler rotation
   can also be created from a direction vector like the :doc:`normal </modeling/geometry_nodes/geometry/read/normal>`
   with the :doc:`/modeling/geometry_nodes/utilities/rotation/align_euler_to_vector`.

Scale
   The size of each generated instance.


Properties
==========

This node has no properties.


Outputs
=======

Instances
   Standard geometry output. If the ``id`` attribute exists on the input geometry,
   it will be copied to the result instances.


## Instance Rotation

.. index:: Geometry Nodes; Instance Rotation
.. _bpy.types.GeometryNodeInputInstanceRotation:

**********************
Instance Rotation Node
**********************

.. figure:: /images/node-types_GeometryNodeInputInstanceRotation.webp
   :align: right
   :alt: Instance Rotation node.

The *Instance Rotation* outputs the XYZ :term:`Euler` rotation of each top-level instance in the
local space of the modifier object.

The :doc:`/modeling/geometry_nodes/instances` page contains more information about geometry instances.

.. note::

   Though rotations are often displayed in units of degrees in the spreadsheet or node editor,
   they are stored internally in radians, so this node outputs radians.

Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Rotation
   Vector that indicates the rotation of each top-level instance in radians.


## Instance Scale

.. index:: Geometry Nodes; Instance Scale
.. _bpy.types.GeometryNodeInputInstanceScale:

*******************
Instance Scale Node
*******************

.. figure:: /images/node-types_GeometryNodeInputInstanceScale.webp
   :align: right
   :alt: Instance Scale node.

The *Instance Scale* outputs the size of top-level instances on each axis in the
local space of the modifier object.

The :doc:`/modeling/geometry_nodes/instances` page contains more information about geometry instances.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Scale
   Vector that indicates the scale of each top-level instance.


## Realize Instances

.. index:: Geometry Nodes; Realize Instances
.. _bpy.types.GeometryNodeRealizeInstances:

**********************
Realize Instances Node
**********************

.. figure:: /images/node-types_GeometryNodeRealizeInstances.webp
   :align: right
   :alt: Realize Instances node.

The *Realize Instances* node makes any instances (efficient duplicates of the same geometry)
into real geometry data. This makes it possible to affect each instance individually,
whereas without this node, the exact same changes are applied to every instance of
the same geometry. However, performance can become much worse when the input
contains many instances of complex geometry, which is a fundamental limitation
when procedurally processing geometry.

.. note::

   If the input contains multiple volume instances, only the first volume component is moved to the output.


Attributes
==========

When merging attributes from multiple geometry inputs, the highest complexity data type is chosen
for the output attribute. In other words, if a ``weight`` attribute has a Boolean type on one geometry input
and a vector data type on another geometry, the ``weight`` attribute on the output geometry will have
a vector data type.

Named and anonymous attributes are propagated from the :ref:`instance domain <attribute-domains>`
to the realized geometry. If the same attribute exists on the geometry and on an instance,
the attribute values from the geometry has precedence over the values on the instances.

In order to avoid creating duplicate values, the ``id`` attribute has special handling.
The ``id`` values or indices of each instance are combined with id values from the points on
geometry data.

.. warning::

   Like other geometry nodes, this node always outputs generic typed attributes. So instead of a
   :term:`Vertex Group` attribute, it will create a "Float" attribute on the result, and it will
   create a generic 2D vector attribute instead of a special "UV Map" attribute. Some other areas
   of Blender don't properly handle generic attributes in version 3.0.

   Custom face corner normals are also not transferred currently.

Inputs
======

Geometry
   Standard geometry input.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Rotate Instances

.. index:: Geometry Nodes; Rotate Instances
.. _bpy.types.GeometryNodeRotateInstances:

*********************
Rotate Instances Node
*********************

.. figure:: /images/node-types_GeometryNodeRotateInstances.webp
   :align: right
   :alt: Rotate Instances node.

The *Rotate Instances* node rotates geometry instances in local or global space.

The :doc:`/modeling/geometry_nodes/instances` page contains more information about geometry instances.


Inputs
======

Instances
   Standard geometry input.

Selection
   Boolean field used to determine if an instance will be rotated.

Rotation
   The :term:`Euler` rotation to rotate the instances by.

Pivot Point
   The position around which each instance is rotated. If the *Local Space* input is true,
   the location is relative to the initial transform of the instance.

Local Space
   If enabled, the instances are rotated in local space. In other words,
   they are rotated around the axes described by the initial transform of each instance.
   When the input is disabled, the pivot point and rotation are specified in
   the local space of the modifier object.


Properties
==========

This node has no properties.


Outputs
=======

Instances
   Standard geometry output.


## Scale Instances

.. index:: Geometry Nodes; Scale Instances
.. _bpy.types.GeometryNodeScaleInstances:

********************
Scale Instances Node
********************

.. figure:: /images/node-types_GeometryNodeScaleInstances.webp
   :align: right
   :alt: Scale Instances node.

The *Scale Instances* node scales geometry instances in local or global space.

The :doc:`/modeling/geometry_nodes/instances` page contains more information about geometry instances.


Inputs
======

Instances
   Standard geometry input.

Selection
   Boolean field used to determine if an instance will be scaled.

Scale
   The scale factor to apply to the instance's transform on each axis.

Center
   The position from which the instance origins are scaled. Each instance will move away from this location.
   When the *Local Space* input is enabled, this location is relative to the initial transform
   of each instance.

Local Space
   If enabled, the instances are scaled in local space. In other words,
   they are scaled in the directions the described by the initial transform of each instance.
   When the input is disabled, the *Center* and *Scale* inputs are specified in
   the local space of the modifier object.


Properties
==========

This node has no properties.


Outputs
=======

Instances
   Standard geometry output.


## Translate Instances

.. index:: Geometry Nodes; Translate Instances
.. _bpy.types.GeometryNodeTranslateInstances:

************************
Translate Instances Node
************************

.. figure:: /images/node-types_GeometryNodeTranslateInstances.webp
   :align: right
   :alt: Translate Instances node.

The *Translate Instances* node moves top-level geometry instances in local or global space.

The :doc:`/modeling/geometry_nodes/instances` page contains more information about geometry instances.


Inputs
======

Instances
   Standard geometry input.

Selection
   Boolean field used to determine if an instance will be translated.

Translation
   The vector to translate the instances by.

Local Space
   If enabled, the instances are translated relative to their initial rotation.
   Otherwise they are translated in the local space of the modifier object.


Properties
==========

This node has no properties.


Outputs
=======

Instances
   Standard geometry output.


## Index


##################
  Material Nodes
##################

Nodes that work with materials.

.. toctree::
   :maxdepth: 1

   replace_material.rst

----

.. toctree::
   :maxdepth: 1

   material_index.rst
   material_selection.rst

----

.. toctree::
   :maxdepth: 1

   set_material.rst
   set_material_index.rst


## Material Index

.. index:: Geometry Nodes; Material Index
.. _bpy.types.GeometryNodeInputMaterialIndex:

*******************
Material Index Node
*******************

.. figure:: /images/node-types_GeometryNodeInputMaterialIndex.webp
   :align: right
   :alt: Material Index node.

The *Material Index* node outputs which material in the list of materials of the geometry
each element corresponds to. Currently the node supports mesh data, where ``material_index``
is a built-in attribute on faces.

The node to set this data is
the :doc:`Set Material Index </modeling/geometry_nodes/material/set_material_index>` node.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Material Index
   Standard integer value, with a minimum value of zero.


## Material Selection

.. index:: Geometry Nodes; Material Selection
.. _bpy.types.GeometryNodeMaterialSelection:

***********************
Material Selection Node
***********************

.. figure:: /images/modeling_geometry-nodes_material_material-selection_node.png
   :align: right
   :alt: Material Selection node.

The *Material Selection* node provides a selection for meshes that use this material.
Since the ``material_index`` is stored on each face, the output will be implicitly interpolated to
a different domain when necessary. For example, every vertex connected to
a selected face will be selected.


Inputs
======

Material
   Standard material input.


Properties
==========

This node has no properties.


Outputs
=======

Selection
   Selection of faces that use the input material.


## Replace Material

.. index:: Geometry Nodes; Replace Material
.. _bpy.types.GeometryNodeReplaceMaterial:

*********************
Replace Material Node
*********************

.. figure:: /images/node-types_GeometryNodeReplaceMaterial.webp
   :align: right
   :width: 300px
   :alt: Replace Material Node.

The *Replace Material* node swaps one material with another.
Replacing a material with this node is more efficient than creating a selection of all faces
with the old material with the :doc:`/modeling/geometry_nodes/material/material_selection`
and then using the :doc:`/modeling/geometry_nodes/material/set_material`.

.. note::

   Currently this node only adjusts mesh data.


Inputs
======

Geometry
   Standard geometry input.

Old
   Material that is going to be replaced.

New
   Material that is replacing the old material.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Set Material

.. index:: Geometry Nodes; Set Material
.. _bpy.types.GeometryNodeSetMaterial:

*****************
Set Material Node
*****************

.. figure:: /images/node-types_GeometryNodeSetMaterial.webp
   :align: right
   :alt: Set Material node.

The *Set Material* changes the material assignment in the specified selection,
by adjusting the ``material_index`` attribute. If the material is already used
on the geometry, the existing material index will be reused.

.. note::

   This node adjusts mesh, point clouds, and volume data;
   other data types do not support materials.


Inputs
======

Geometry
   Standard geometry input containing a mesh.

Material
   The material to apply to the geometry.

Selection
   Whether to change the material of each face.
   True values mean the material will be changed, false values mean it will remain the same.

   Note, volumes and point clouds only support a single material,
   in these cases a field input will be ignored.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Set Material Index

.. index:: Geometry Nodes; Set Material Index
.. _bpy.types.GeometryNodeSetMaterialIndex:

***********************
Set Material Index Node
***********************

.. figure:: /images/node-types_GeometryNodeSetMaterialIndex.webp
   :align: right
   :alt: Set Material Index node.

The *Set Material Index* node sets the material index for a geometry.

The node to get this data is the :doc:`Material Index </modeling/geometry_nodes/material/material_index>` node.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Whether to change the material index for each face.
   True values mean the material index will be changed, false values mean it will remain the same.

Material Index
   The new material index.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Index


##############
  Mesh Nodes
##############

Nodes that only operate on meshes.

.. toctree::
   :maxdepth: 2

   Read <read/index.rst>
   Sample <sample/index.rst>
   Write <write/index.rst>

----

.. toctree::
   :maxdepth: 2

   Operations <operations/index.rst>
   Primitives <primitives/index.rst>
   Topology <topology/index.rst>
   UV <uv/index.rst>


## Dual Mesh

.. index:: Geometry Nodes; Dual Mesh
.. _bpy.types.GeometryNodeDualMesh:

**************
Dual Mesh Node
**************

.. figure:: /images/node-types_GeometryNodeDualMesh.webp
   :align: right
   :alt: Dual Mesh node.

The *Dual Mesh Node* converts a mesh into its dual, i.e. faces are turned into
vertices and vertices are turned into faces. This also means that attributes
which were on the face domain are transferred to the point domain in the dual mesh.

.. warning::

   The Dual Mesh node only works on manifold geometry. To work with non-manifold geometry
   it's best to remesh the geometry first.


Inputs
======

Mesh
   Standard geometry input.

Keep Boundaries
   Keeps the non-manifold boundaries of the input mesh in place, by creating
   extra geometry, and avoiding the dual mesh transformation there.


Properties
==========

This node has no properties.


Output
======

Dual Mesh
   Standard geometry output.


Examples
========

The *Dual Mesh Node* combines nicely with triangulated meshes. In this case
an Ico Sphere is used, which is made up of nice and evenly spaced triangles.

.. figure:: /images/modeling_geometry-nodes_dual-mesh_icosphere.png


## Edge Paths To Curves

.. index:: Geometry Nodes; Edge Paths to Curves
.. _bpy.types.GeometryNodeEdgePathsToCurves:

*************************
Edge Paths to Curves Node
*************************

.. figure:: /images/node-types_GeometryNodeEdgePathsToCurves.webp
   :align: right
   :alt: Edge Paths to Curves Node.

The *Edge Paths to Curves* node output curves that follow paths across mesh edges.

.. seealso::

   This node is meant to use the output of the :doc:`/modeling/geometry_nodes/mesh/read/shortest_edge_paths`.
   It is similar to the :doc:`/modeling/geometry_nodes/mesh/operations/edge_paths_to_selection`, but it creates
   a curve that follow each path, rather than a selection of every visited edge.


Inputs
======

Mesh
   Standard mesh input.

Start Vertices
   A selection of the vertices to start at when traveling along the next vertex indices.

Next Vertex Index
   Describes the path to follow at every vertex.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard curves output.


## Edge Paths To Selection

.. index:: Geometry Nodes; Edge Paths to Selection
.. _bpy.types.GeometryNodeEdgePathsToSelection:

****************************
Edge Paths to Selection Node
****************************

.. figure:: /images/node-types_GeometryNodeEdgePathsToSelection.webp
   :align: right
   :alt: Edge Paths to Selection Node.

The *Edge Paths to Selection* node follows paths across mesh edges and outputs a selection
of every visited edge.

.. seealso::

   This node is meant to use the output of the :doc:`/modeling/geometry_nodes/mesh/read/shortest_edge_paths`.
   It can be combined with the :doc:`/modeling/geometry_nodes/geometry/operations/separate_geometry` to remove
   any unused edges.


Inputs
======

Start Vertices
   A selection of the vertices to start at when traveling along the next vertex indices.

Next Vertex Index
   Describes the path to follow at every vertex.


Properties
==========

This node has no properties.


Outputs
=======

Selection
   A boolean field indicating all edges visited when traversing the mesh.


## Extrude Mesh

.. index:: Geometry Nodes; Extrude Mesh
.. _bpy.types.GeometryNodeExtrudeMesh:

*****************
Extrude Mesh Node
*****************

.. figure:: /images/node-types_GeometryNodeExtrudeMesh.webp
   :align: right
   :alt: Extrude Mesh node.

The *Extrude Mesh Node* generates new vertices, edges, or faces, on selected geometry
and transforms them based on an offset.

The operations are similar to the :doc:`extrude tools </modeling/meshes/editing/mesh/extrude>`
in mesh edit mode, though there are some differences. Most importantly, the node never keeps the back-faces
of the extrusion in place, they are always removed. Attribute propagation rules may also be different.


Inputs
======

Mesh
   Standard geometry input.

Selection
   Whether to extrude each element.
   True values mean elements will be extruded, false values mean elements will remain unchanged.

Offset
   The amount to translate the new geometry on each axis. The default value of the "Offset" input
   is the mesh's :doc:`normals </modeling/geometry_nodes/geometry/read/normal>`. To change the distance,
   the *Scale* input can be used. However, when an input is computed for this directly, the length
   of the input vectors is used.

   .. tip::

      Because the default input is the mesh's normals, they may need to be calculated just for this node.
      If the extrusion is only in one direction anyway, a potential performance improvement is to connect
      a :doc:`/modeling/geometry_nodes/input/constant/vector` instead.

Scale
   The factor used to scale elements or groups of elements.

Individual :guilabel:`Face Mode Only`
   Whether to extrude each face individually rather than extruding connected groups of faces together as regions.
   A quad side face will be generated on each side of every selected face.


Properties
==========

Mode
   :Vertices:
      This mode is quite simple, it just attaches new edges and vertices to the selected vertices.

   :Edges:
      Attach new quad faces to the selected edges. Vertices shared by the
      original selected vertices are also shared in the duplicated edges.

      .. note::

         Depending on the situation, the normals of the new faces may be arbitrary. If the selected
         edges only have one selected face, then the node can pick a consistent orientation for the
         new faces, but if there is more than one connected face, or no connected faces, the normals
         may have to be adjusted afterwards.

   :Faces:
      Extrudes contiguous regions of selected faces, or each selected face individually,
      depending on the *Individual* boolean input.

      When the *Individual* input is false, the node will find regions of connected faces and generate
      new "side" faces on the boundaries of those regions. If the whole mesh is selected and it is already
      a :term:`Manifold` shape, then result will just be that the whole mesh moves. Any vertices, edges
      or faces on the *inside* of the face regions are just moved, they are not duplicated.


Output
======

Mesh
   Standard geometry output.

Top
   A boolean field output containing the top new top geometry. The :ref:`domain <attribute-domains>`
   depends on the selected mode. In *Vertex* mode, this is a selection of the new vertices.
   In *Edge* mode, this is a selection of the duplicated edges
   and in *Face* mode, it is a selection of the new faces.

Side
   A boolean field output containing the "side" of the new geometry. In *Vertex* mode, it selects
   the new edges, in *Edge* mode, the new faces, and in *Face* mode, the new side faces are selected,
   which are all of the new faces that aren't in the *Top* selection.


Examples
========

.. figure:: /images/modeling_geometry-nodes_extrude-mesh_sphere-materials.png
   :align: center

Here, the selection outputs are used to set materials on certain faces of the mesh.
A :doc:`/modeling/geometry_nodes/utilities/random_value` node can be used to limit the
extrusion to a random set of faces.


Attribute Propagation
=====================

Attributes are transferred to the new elements with specific rules.
An attribute will never change domains on the resulting mesh.
The ``id`` attribute does not have any special handling.

Generally boolean attributes are propagated with "or", meaning any connected
"true" value that is mixed in for other types will cause the new value
to be "true" as well.

The following sections describe:

Vertex Mode
-----------

.. figure:: /images/modeling_geometry-nodes_extrude-mesh_attributes-vertex-new-edges.png
   :align: center
   :width: 400px

   The new edges created in vertex mode use the average value of all connected edges.

* New **vertices** have copied values from their original vertices
* New **edges** have the average value of any connected original edges.
  For boolean attributes, edges are selected if any connected edges were selected.

Edge Mode
---------

.. figure:: /images/modeling_geometry-nodes_extrude-mesh_attributes-edge-connecting-edges.png
   :align: center
   :width: 400px

   Attribute propagation for new connecting edges (the vertical yellow edge).
   The final value is a mix of the values from the two middle blue edges.
   The darker maroon edges lower on the image are not used.

* New **vertices** have copied values from their original vertices.
* Vertical connecting **edges** get the average value
  from any connected extruded edges. For booleans, the edges are selected if any connected extruded
  edges were selected. (*Propagation rules are shown in the figure above*.)
* Horizontal duplicate **edges** have copied values from their original edges.
* New **faces** get the average values of all faces connected to the selected edge.
  For booleans, faces are selected if any connected original faces were selected.
* New **face corners** get the averaged value of corresponding corners in all faces connected to selected edges.
  For booleans, corners are selected if one of those corners are selected.

Face Mode
---------

.. figure:: /images/modeling_geometry-nodes_extrude-mesh_attributes-face-connecting-edges.png
   :align: center
   :width: 400px

   Attribute propagation for new connecting edges (the vertical yellow edge).
   The final value is a mix of the values from the two middle blue edges.
   The values from the darker maroon edges between unselected faces and
   on top of the extruded region are not used.

* New **vertices** have copied values from their original vertices.
* Vertical connecting **edges** get the average value from any connected extruded edges,
  not including the edges "on top" of extruded regions. For booleans,
  the edges are selected if any of those connected edges were selected.
  (*Propagation rules are shown in the figure above*.)
* Horizontal duplicate **edges** have copied values from their original edges.
* New **faces** have copied values from the corresponding extruded faces.
* New **face corners** have copied values from the corresponding corresponding corners of extruded faces.

Individual Face Mode
--------------------

.. figure:: /images/modeling_geometry-nodes_extrude-mesh_attributes-face-individual-connecting-edges.png
   :align: center
   :width: 400px

   Attribute propagation for new connecting edge. Each edge uses the average values of the two neighboring
   edges on its extruded face.

* New **vertices** have copied values from their original vertices.
* Vertical connecting **edges** get the average value of the two neighboring edges on each extruded face.
  For booleans, the edges are selected when at least one neighbor on the extruded face was selected.
* Horizontal duplicate **edges** have copied values from their original edges.
* New side **faces** have copied values from their corresponding selected face.
* New **face corners** have copied values from the corresponding corners of selected faces.


## Flip Faces

.. index:: Geometry Nodes; Flip Faces
.. _bpy.types.GeometryNodeFlipFaces:

***************
Flip Faces Node
***************

.. figure:: /images/node-types_GeometryNodeFlipFaces.webp
   :align: right
   :alt: Flip Faces node.

The *Flip Faces Node* reverses the order of the vertices and edges of each selected face.
The most common use of this node is to flip the normals of a face.
Any :ref:`face corner domain <attribute-domains>` attributes of selected faces are also reversed.

Though this node is usually used to affect normals, it is not called "Flip Normals" for an important reason.
The node does not actually interact with normals directly. Normals are defined by the
`right hande rule <https://en.wikipedia.org/wiki/Right-hand_rule#Curve_orientation_and_normal_vectors>`__,
so if a face's vertex list is reversed, then its normal will point in the opposite direction.


Inputs
======

Mesh
   Standard geometry input.

Selection
   Whether to flip the direction of each face.
   True values mean the face will be flipped, false means the face will be unaffected.


Properties
==========

This node has no properties.


Output
======

Mesh
   Standard geometry output.


## Index


########################
  Mesh Operation Nodes
########################

Nodes that only operate on meshes.

.. toctree::
   :maxdepth: 1

   dual_mesh.rst
   edge_paths_to_curves.rst
   edge_paths_to_selection.rst
   extrude_mesh.rst
   flip_faces.rst
   mesh_boolean.rst
   mesh_to_curve.rst
   mesh_to_points.rst
   mesh_to_volume.rst
   scale_elements.rst
   split_edges.rst
   subdivide_mesh.rst
   subdivision_surface.rst
   triangulate.rst


## Mesh Boolean

.. index:: Geometry Nodes; Mesh Boolean
.. _bpy.types.GeometryNodeMeshBoolean:

*****************
Mesh Boolean Node
*****************

.. figure:: /images/node-types_GeometryNodeMeshBoolean.webp
   :align: right
   :alt: Mesh Boolean node.

The *Mesh Boolean Node* allows you to cut, subtract, and join the geometry of two inputs.
This node offers the same operations as the :doc:`Boolean modifier </modeling/modifiers/generate/booleans>`.


Inputs
======

Mesh 1/2
   Standard geometry input.

Self Intersection
   Correctly calculates cases when one or both operands have self-intersections.
   This involves more calculations making the node slower.

Hole Tolerant
   Optimizes the Boolean output for :term:`Non-manifold` geometry
   at the cost of increased computational time.
   Because of the performance impact, this option should only be enabled
   when the solver demonstrates errors with non-manifold geometry.


Properties
==========

Operation
   :Intersect:
      Produce a new geometry containing only the volume inside of both geometry 1 and geometry 2.
   :Union:
      The two input meshes are joined, then any interior elements are removed.
   :Difference:
      Geometry 2 is subtracted from geometry 1 (everything outside of geometry 2 is kept).

Solver
   Algorithm used to calculate the Boolean intersections.

   :Fast:
      Uses a mathematically simple solver which offers the best performance;
      however, this solver lacks support for overlapping geometry.
   :Exact:
      Uses a mathematically complex solver which offers the best results
      and has full support for overlapping geometry;
      however, this solver is much slower than the *Fast Solver*.


Output
======

Mesh
   Standard geometry output.

Intersecting Edges :guilabel:`Exact Solver`
   A boolean attribute field with a selection of the edges that were created where the two inputs
   meet.


## Mesh To Curve

.. index:: Geometry Nodes; Mesh to Curve
.. _bpy.types.GeometryNodeMeshToCurve:

******************
Mesh to Curve Node
******************

.. figure:: /images/node-types_GeometryNodeMeshToCurve.webp
   :align: right
   :alt: Mesh to Curve node.

The *Mesh to Curve* node turns each string of connected mesh edges into a poly spline.
Whenever two or more strings cross each other, the splines will be split.

Loose vertices are ignored -- they will not be turned into single-point splines.

Attributes, both named and unnamed ones, are transferred to the resulting splines.
If there is a ``radius`` attribute, it will be applied as such,
although you may find it more convenient to use the
:doc:`/modeling/geometry_nodes/curve/write/set_curve_radius` for this.


Inputs
======

Mesh
   Standard mesh input.

Selection
   A field input evaluated on the edge domain to determine whether each edge will be included in the result.

   .. tip::

      Using this input is more efficient than deleting parts of the geometry before or after the conversion.


Properties
==========

This node has no properties.


Outputs
=======

Curve
   Generated curve.


## Mesh To Points

.. index:: Geometry Nodes; Mesh to Points
.. _bpy.types.GeometryNodeMeshToPoints:

*******************
Mesh to Points Node
*******************

.. figure:: /images/node-types_GeometryNodeMeshToPoints.webp
   :align: right
   :alt: Mesh to Points node.

The *Mesh to Points* node generates a point cloud from a mesh.


Inputs
======

Mesh
   Standard Mesh input.

Selection
   The meshes used to generate a point cloud.

Position
   Positions of generated points. By default, this input is the same as
   if the :doc:`/modeling/geometry_nodes/geometry/read/position` was connected.

Radius
   Radii of generated points.


Properties
==========

Mode
   :Vertices:
      Points are generated for each vertex.
   :Edges:
      Points are generated for each edge, at the middle of each edge, by default.
   :Faces:
      Points are generated for each face, at the average of all of each face's vertices, by default.
   :Corners:
      Points are generated for each corner. The points are all placed at the location of each
      corners vertex, so they will overlap by default.


Outputs
=======

Points
   Generated point cloud.


## Mesh To Volume

.. index:: Geometry Nodes; Mesh to Volume
.. _bpy.types.GeometryNodeMeshToVolume:

*******************
Mesh to Volume Node
*******************

.. figure:: /images/node-types_GeometryNodeMeshToVolume.webp
   :align: right
   :alt: Mesh to Volume node.

The *Mesh to Volume* node creates a fog volumes based on the shape of a mesh.
The volume is created with a grid of the name ``"density"``.


Inputs
======

Mesh
   Standard Mesh input.

Density
   Value of voxels inside the generated fog volume.

Voxel Amount
   Specify the approximate number of voxels along the diagonal.

Voxel Size
   Specify the voxel side length.

Interior Band Width
   The maximum distance of the included voxels to the surface on the inside of the mesh.


Properties
==========

Resolution
   How the voxel size is specified.

   :Amount:
      Specify the approximate number of voxels along the diagonal.
   :Size:
      Specify the voxel side length. It is recommended to be careful when tweaking this value,
      because small changes can have a large effect on the processing time.


Outputs
=======

Volume
   The generated volume grid.


## Scale Elements

.. index:: Geometry Nodes; Scale Elements
.. _bpy.types.GeometryNodeScaleElements:

*******************
Scale Elements Node
*******************

.. figure:: /images/node-types_GeometryNodeScaleElements.webp
   :align: right
   :alt: Scale Elements node.

The *Scale Elements Node* scales groups of connected edges and faces.
When multiple selected faces/edges share the same vertices, they are scaled together.
The center and scaling factor is averaged in this case.


Inputs
======

Mesh
   Standard geometry input.

Selection
   Whether to scale each edge or face.
   True values mean the element will be scaled, false means it will be unaffected.

Scale
   The factor used to scale elements or groups of elements.

Center
   Origin of the scaling for each element. If multiple elements are connected, their center is averaged.

Axis :guilabel:`Single Axis Mode Only`
   Axis in which to scale the element. This input is normalized internally, so the length does not matter.


Properties
==========

Domain
   The element type to transform.

   :Face: Scale individual faces or neighboring face islands.
   :Edge: Scale individual edges or neighboring edge islands.

Scale Mode
   :Uniform: Scale elements by the same factor in every direction.
   :Single Axis: Scale elements in a single direction defined by the *Direction* input.


Output
======

Mesh
   Standard geometry output.

Examples
========

.. figure:: /images/modeling_geometry-nodes_flip-faces_extrude.png
   :align: right

The node is useful when combined with the :doc:`/modeling/geometry_nodes/mesh/operations/extrude_mesh`,
especially in *Individual* mode, where face islands don't need to be scaled together.


## Split Edges

.. index:: Geometry Nodes; Edge Split
.. _bpy.types.GeometryNodeSplitEdges:

****************
Split Edges Node
****************

.. figure:: /images/node-types_GeometryNodeSplitEdges.webp
   :align: right
   :alt: Split Edges node.

Like the :doc:`/modeling/modifiers/generate/edge_split`, the *Split Edges* node splits and duplicates edges
within a mesh, breaking 'links' between faces around those split edges.


Inputs
======

Mesh
   Standard geometry input.

Selection
   A standard Boolean selection input to determine which edges will be split.

.. note::

   Because of mesh topology requirements, sometimes more or fewer edges than are selected will be split.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.


## Subdivide Mesh

.. index:: Geometry Nodes; Subdivide Mesh
.. _bpy.types.GeometryNodeSubdivideMesh:

*******************
Subdivide Mesh Node
*******************

.. figure:: /images/node-types_GeometryNodeSubdivideMesh.webp
   :align: right
   :alt: Subdivide Mesh Node.

The *Subdivide Mesh* node adds new faces to mesh geometry using a simple interpolation for deformation.


Inputs
======

Mesh
   Standard geometry input.

Level
   The number of subdivisions to apply to the input geometry.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.


## Subdivision Surface

.. index:: Geometry Nodes; Subdivision Surface
.. _bpy.types.GeometryNodeSubdivisionSurface:

************************
Subdivision Surface Node
************************

.. figure:: /images/node-types_GeometryNodeSubdivisionSurface.webp
   :align: right
   :alt: Subdivision Surface Node.

The *Subdivision Surface* node adds new faces to mesh geometry using a Catmull-Clark subdivision method.


Inputs
======

Mesh
   Standard geometry input.

Level
   The number of subdivisions to apply to the input geometry.

Edge Crease
   Controls how smooth edges should be with :ref:`modifiers-generate-subsurf-creases`.

Vertex Crease
   Controls how much the subdivision surface should be pulled towards the vertex.
   Similar to edge creases, but allows individual vertices to be creased.


Properties
==========

UV Smooth
   Controls how subdivision smoothing is applied to UVs.

   :None: UVs remain unchanged.
   :Keep Corners: UV islands are smoothed, but their boundary remain unchanged.
   :Keep Corners, Junctions:
      UVs are smoothed, corners on discontinuous boundary and junctions of three or more regions are kept sharp.
   :Keep Corners, Junctions, Concave:
      UVs are smoothed, corners on discontinuous boundary,
      junctions of three or more regions and darts and concave corners are kept sharp.
   :Keep Boundaries: UVs are smoothed, boundaries are kept sharp.
   :All: UVs and their boundaries are smoothed.

Boundary Smooth
   Controls how open boundaries (and corners) are smoothed.

   :All: Smooth boundaries, including corners.
   :Keep Corners: Smooth boundaries, but corners are kept sharp.


Outputs
=======

Mesh
   Standard geometry output.


## Triangulate

.. index:: Geometry Nodes; Triangulate
.. _bpy.types.GeometryNodeTriangulate:

****************
Triangulate Node
****************

.. figure:: /images/node-types_GeometryNodeTriangulate.webp
   :align: right
   :alt: Triangulate Node.

The *Triangulate* node converts all faces in a mesh (quads and n-gons) to triangular faces.
It functions the same as the :ref:`Triangulate <bpy.ops.mesh.quads_convert_to_tris>` tool in Edit Mode.


Inputs
======

Mesh
   Standard geometry input.

Selection
   A standard Boolean selection input to determine which faces will be triangulated.

Minimum Vertices
   Minimum number of vertices a face must have to be triangulated.
   For example, setting this value to 5, will prevent triangulation of :term:`Quads <Quad>`
   and only triangulate :term:`N-gons <N-gon>`.


Properties
==========

Quad Method
   :Beauty:
      Split the quads in nice triangles, slower method.
   :Fixed:
      Split the quads on their 1st and 3rd vertices.
   :Fixed Alternate:
      Split the quads on their 2nd and 4th vertices.
   :Shortest Diagonal:
      Split the quads along their shortest diagonal.
   :Longest Diagonal:
      Split the quads along their longest diagonal. This is the preferred mode for cloth simulations.

N-gon Method
   :Beauty:
      Arrange the new triangles nicely, slower method.
   :Clip:
      Split n-gons using an ear-clipping algorithm
      (the same method of tessellation used for viewport display).


Outputs
=======

Mesh
   Standard geometry output.


Example
=======

.. list-table::

   * - .. figure:: /images/modeling_modifiers_generate_triangulate_before.png
          :width: 320px

          Mesh before triangulation.

     - .. figure:: /images/modeling_modifiers_generate_triangulate_after.png
          :width: 320px

          Mesh after triangulation.


## Cone

.. index:: Geometry Nodes; Cone
.. _bpy.types.GeometryNodeMeshCone:

*********
Cone Node
*********

.. figure:: /images/node-types_GeometryNodeMeshCone.webp
   :align: right
   :alt: Cone node.

The *Cone* node generates a cone mesh that is optionally truncated.


Inputs
======

Vertices
   Number of points on the circle at the top and bottom.
   No geometry is generated if the number is below three.

Side Segments
   Number of edges running vertically along the side of the cone.
   No geometry is generated if the number is below one.

Fill Segments
   Number of concentric rings used to fill the round faces at the top and bottom.
   No geometry is generated if the number is below one.

Radius Top
   The distance of the vertices in the top circle from the Z axis.
   If this is zero, the vertices in the circle are merged into one.

Radius Bottom
   Same as *Radius Top* but for the bottom circle.

Depth
   Height of the generated cone.

.. note::

   If the top and bottom radii are zero, this node will output a single line.


Properties
==========

Fill Type
   How the circles at the top and bottom are filled with faces when their radius is larger than zero.

   :None: Do not fill the circles.
   :N-Gon: Fill the innermost segment of the circles with a single face.
   :Triangles: Fill the innermost segment of the circles with triangles connected to a new vertex on the Z axis.


Outputs
=======

Mesh
   Standard geometry output.

Top
   A boolean attribute field with a selection of the faces on the top of the cone. If the *Fill Type*
   property is set to none, then this will be a selection of the top edges instead. If *Radius Top*
   is zero, this will be a selection of the top vertex.

Side
   A boolean attribute field with a selection of the faces on the side of the cone.

Bottom
   A boolean attribute field with a selection of the faces on the bottom of the cone. If the *Fill Type*
   property is set to none, then this will be a selection of the bottom edges instead. If *Radius Bottom*
   is zero, this will be a selection of the bottom vertex.

UV Map
   A 2D vector representing the default X/Y coordinates of the :term:`UV Map` for the primitive's shape.
   This can be connected to the :doc:`/modeling/geometry_nodes/attribute/store_named_attribute`,
   to be used once the Geometry Nodes Modifier get applied.
   The UV map must be stored on the face corner in order to be accessed.


## Cube

.. index:: Geometry Nodes; Cube
.. _bpy.types.GeometryNodeMeshCube:

*********
Cube Node
*********

.. figure:: /images/node-types_GeometryNodeMeshCube.webp
   :align: right
   :alt: Cube Node.

The *Cube* node generates a cuboid mesh with variable side lengths and subdivisions.
The inside of the mesh is still hollow like a normal cube.


Inputs
======

Size
   Side lengths along each of the main axes.
Vertices X, Y, Z
   Number of vertices for each side of the cube.
   The number of vertices should be at least 1.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.
UV Map
   A 2D vector representing the default X/Y coordinates of the :term:`UV Map` for the primitive's shape.
   This can be connected to the :doc:`/modeling/geometry_nodes/attribute/store_named_attribute`,
   to be used once the Geometry Nodes Modifier get applied.
   The UV map must be stored on the face corner in order to be accessed.


## Cylinder

.. index:: Geometry Nodes; Cylinder
.. _bpy.types.GeometryNodeMeshCylinder:

*************
Cylinder Node
*************

.. figure:: /images/node-types_GeometryNodeMeshCylinder.webp
   :align: right
   :alt: Cylinder node.

The *Cylinder* node generates a cylinder mesh.
It is similar to the Cone node but always uses the same radius for the circles at the top and bottom.


Inputs
======

Vertices
   Number of vertices on the circle at the top and bottom.
   No geometry is generated if the number is below three.

Side Segments
   Number of edges running vertically along the side of the cone.
   No geometry is generated if the number is below one.

Fill Segments
   Number of concentric rings used to fill the round faces at the top and bottom.
   No geometry is generated if the number is below one.

Radius
   Distance of the vertices from the Z axis.
   If this is zero, the output will be a single line.

Depth
   Height of the cylinder.


Properties
==========

Fill Type
   How the circles at the top and bottom are filled with faces when their radius is larger than zero.

   :None: Do not fill the circles.
   :N-Gon: Fill the innermost segment of the circles with a single face.
   :Triangles: Fill the innermost segment of the circles with triangles connected to a new vertex on the Z axis.


Outputs
=======

Mesh
   Standard geometry output.

Top
   A boolean attribute field with a selection of the faces on the top of the cylinder. If the *Fill Type*
   property is *None*, then this will be a selection of the top edges instead. If the *Radius* is
   zero, this will be a selection of the top point.

Side
   A boolean attribute field with a selection of the faces on the side of the cylinder.

Bottom
   This is the same as the *Top* selection output, but on the bottom side of the geometry instead.

UV Map
   A 2D vector representing the default X/Y coordinates of the :term:`UV Map` for the primitive's shape.
   This can be connected to the :doc:`/modeling/geometry_nodes/attribute/store_named_attribute`,
   to be used once the Geometry Nodes Modifier get applied.
   The UV map must be stored on the face corner in order to be accessed.


## Grid

.. index:: Geometry Nodes; Grid
.. _bpy.types.GeometryNodeMeshGrid:

*********
Grid Node
*********

.. figure:: /images/node-types_GeometryNodeMeshGrid.webp
   :align: right
   :alt: Grid Node.

The *Grid* node generates a planar mesh on the XY plane.


Inputs
======

Size X
   Side length of the plane in the X direction.

Size Y
   Side length of the plane in the Y direction.

Vertices X
   Number of vertices in the X direction.
   If this is smaller than two, no mesh is generated.

Vertices Y
   Number of vertices in the Y direction.
   If this is smaller than two, no mesh is generated.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.

UV Map
   A 2D vector representing the default X/Y coordinates of the :term:`UV Map` for the primitive's shape.
   This can be connected to the :doc:`/modeling/geometry_nodes/attribute/store_named_attribute`,
   to be used once the Geometry Nodes Modifier get applied.
   The UV map must be stored on the face corner in order to be accessed.


## Icosphere

.. index:: Geometry Nodes; Ico Sphere
.. _bpy.types.GeometryNodeMeshIcoSphere:

**************
Icosphere Node
**************

.. figure:: /images/node-types_GeometryNodeMeshIcoSphere.webp
   :align: right
   :alt: Icosphere Node.

The *Icosphere* node generates a spherical mesh that consists of equally sized triangles.


Inputs
======

Radius
   Distance of the vertices from the origin.

Subdivisions
   Number of subdivisions on top of the most basic icosphere.
   The number of faces quadruple with every subdivision.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.

UV Map
   A 2D vector representing the default X/Y coordinates of the :term:`UV Map` for the primitive's shape.
   This can be connected to the :doc:`/modeling/geometry_nodes/attribute/store_named_attribute`,
   to be used once the Geometry Nodes Modifier get applied.
   The UV map must be stored on the face corner in order to be accessed.


## Index


########################
  Mesh Primitive Nodes
########################

Nodes that create a primitive mesh, e.g. a cube.

.. toctree::
   :maxdepth: 1

   cone.rst
   cube.rst
   cylinder.rst
   grid.rst
   icosphere.rst
   mesh_circle.rst
   mesh_line.rst
   uv_sphere.rst


## Mesh Circle

.. index:: Geometry Nodes; Mesh Circle
.. _bpy.types.GeometryNodeMeshCircle:

****************
Mesh Circle Node
****************

.. figure:: /images/node-types_GeometryNodeMeshCircle.webp
   :align: right
   :alt: Mesh Circle Node.

The *Mesh Circle* node generates a circular ring of edges that is optionally filled with faces.


Inputs
======

Vertices
   Number of vertices on the circle.
   No geometry is generated when the number is below three.

Radius
   Distance of the vertices from the origin.


Properties
==========

Fill Type
   How the circle is filled with faces.

   :None: Output just the edge ring without any faces.
   :N-Gon: Fill the circle with a single face.
   :Triangles: Fill the circle with triangles connected to a new vertex at the origin.


Outputs
=======

Mesh
   Standard geometry output.


## Mesh Line

.. index:: Geometry Nodes; Mesh Line
.. _bpy.types.GeometryNodeMeshLine:

**************
Mesh Line Node
**************

.. figure:: /images/node-types_GeometryNodeMeshLine.webp
   :align: right
   :alt: Mesh Line Node.

The *Mesh Line* node generates vertices in a line and connects them with edges.


Inputs
======

Count
   Number of vertices on the line.

Resolution
   Length of individual edges.
   The node tries to fit as many vertices as possible between the start and end point.
   The exact end point might not be hit.
   This is only available when the mode is set to *End Points* and the count mode is set to *Resolution*.

Start Location
   Position of the first vertex.

Offset
   Controls the direction of the line and distance between the vertices.
   This is only available when the mode is set to *Offset*.

End Location
   Position of the last vertex.
   This is only available when the mode is set to *End Points*.


Properties
==========

Mode
   Inputs to use to control the line.

   :Offset: Specify the offset from one vertex to the next.
   :End Points: Specify the start and end point of the line.

Count Mode
   Determines how the number of vertices is chosen.
   This is only available when the mode is set to *End Points*.

   :Count: Specify the total number of vertices.
   :Resolution: Specify the distance between vertices.


Outputs
=======

Mesh
   Standard geometry output.


## Uv Sphere

.. index:: Geometry Nodes; UV Sphere
.. _bpy.types.GeometryNodeMeshUVSphere:

**************
UV Sphere Node
**************

.. figure:: /images/node-types_GeometryNodeMeshUVSphere.webp
   :align: right
   :alt: UV Sphere Node.

The *UV Sphere* node generates a spherical mesh mostly out of quads except for triangles at the top and bottom.


Inputs
======

Segments
   Horizontal resolution of the sphere.
   If this is smaller than three, no mesh is generated.

Rings
   Vertical resolution of the sphere.
   If this is smaller than two, no mesh is generated.

Radius
   Distance of vertices to the origin.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.

UV Map
   A 2D vector representing the default X/Y coordinates of the :term:`UV Map` for the primitive's shape.
   This can be connected to the :doc:`/modeling/geometry_nodes/attribute/store_named_attribute`,
   to be used once the Geometry Nodes Modifier get applied.
   The UV map must be stored on the face corner in order to be accessed.


## Edges To Face Groups

.. index:: Geometry Nodes; Edges to Face Groups
.. _bpy.types.GeometryNodeEdgesToFaceGroups:

*************************
Edges to Face Groups Node
*************************

.. figure:: /images/node-types_GeometryNodeEdgesToFaceGroups.webp
   :align: right
   :alt: Edges to Face Groups Node.

The *Edges to Face Groups* node group faces into regions surrounded by the selected boundary edges.


Inputs
======

Boundary Edges
   Edges used to split faces into separate groups.


Properties
==========

This node has no properties.


Outputs
=======

Face Group ID
   Index of the face group inside each boundary edge region.


## Edge Angle

.. index:: Geometry Nodes; Edge Angle
.. _bpy.types.GeometryNodeInputMeshEdgeAngle:

***************
Edge Angle Node
***************

.. figure:: /images/node-types_GeometryNodeInputMeshEdgeAngle.webp
   :align: right
   :alt: Edge Angle Node.

The *Edge Angle* node calculates the angle in radians between two faces that meet at an edge.
For the Face, Face Corner, and Point :ref:`domains <attribute-domains>`,
the node uses simple domain interpolation to move values from the mesh's edges.

.. note::

   The output of this node depends on the density of the mesh. If there are more edges
   closer together and the curvature of the mesh stays the same, the edge angle will
   be different

Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Unsigned Angle
   The shortest angle in radians between two faces where they meet at an edge.
   The range of the data is from zero to PI. Flat edges and :term:`Non-manifold`
   edges have an angle of zero. An edge between two faces completely folded
   back on each other has an angle of PI, or 180 degrees.

   .. tip::

      Computing this value is slightly faster than the signed angle, so if there is no need to distinguish
      between convex and concave angles, using this value can provide a performance improvement.

Signed Angle
   The signed angle in radians between two faces where they meet at an edge. Flat edges
   and Non-manifold edges have an angle of zero. Concave angles are positive and convex
   angles are negative.


## Edge Neighbors

.. index:: Geometry Nodes; Edge Neighbors
.. _bpy.types.GeometryNodeInputMeshEdgeNeighbors:

*******************
Edge Neighbors Node
*******************

.. figure:: /images/node-types_GeometryNodeInputMeshEdgeNeighbors.webp
   :align: right
   :alt: Edge Neighbors Node.

The *Edge Neighbors* node outputs topology information relating to each edge of a mesh.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Face Count
    The number of faces that use the edge as one of their sides.
    When the value is one, the edge is a :term:`non-manifold <Non-manifold>` boundary edge.
    Alternatively, when the value is zero, the edge is a loose edge, not used by any faces.


Examples
========

.. figure:: /images/modeling_geometry-nodes_input_edge-vertices_boundary.png
   :align: center

   Using the *Face Count* output to create a curve on a mesh's boundary edges.


## Edge Vertices

.. index:: Geometry Nodes; Edge Vertices
.. _bpy.types.GeometryNodeInputMeshEdgeVertices:

******************
Edge Vertices Node
******************

.. figure:: /images/node-types_GeometryNodeInputMeshEdgeVertices.webp
   :align: right
   :alt: Edge Vertices Node.

The *Edge Vertices* node outputs the position and index of the two vertices of each of a mesh's edges.

.. note::

   The order of the two vertices of an edge is arbitrary. In some cases it may be predictable
   based on the internals of the algorithm that created the mesh, but in general the order should
   not be relied upon.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Vertex Index 1/2
   The :doc:`index </modeling/geometry_nodes/geometry/read/input_index>` of the two vertices of the edge.

Position 1/2
   The :doc:`position </modeling/geometry_nodes/geometry/read/position>` of each of the edge's vertices.
   This output is for convenience, it is the same as using index output to retrieve the position from the
   :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index`.


## Face Area

.. index:: Geometry Nodes; Face Area
.. _bpy.types.GeometryNodeInputMeshFaceArea:

**************
Face Area Node
**************

.. figure:: /images/node-types_GeometryNodeInputMeshFaceArea.webp
   :align: right
   :alt: Face Area Node.

The *Face Area* node outputs the surface area of a mesh's faces.
The units are in Blender units no matter the unit system,
equivalent to meters-squared at the default unit scale.

.. note::

   For :term:`quads <Quad>` and :term:`N-gons <N-gon>`, when the face's vertices are not planar,
   the output is not necessarily the same as the sum of every one of the face's triangles visible
   in the viewport. In this case it should only be used an approximation. In some cases,
   the :doc:`/modeling/geometry_nodes/mesh/operations/triangulate` can be used to get an exact value.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Area
   The surface area of each of the mesh's faces.


Examples
========

.. figure:: /images/modeling_geometry-nodes_input_face-area_surface-area.png
   :align: right

Combined with the :doc:`/modeling/geometry_nodes/attribute/attribute_statistic`,
this node can be used to calculate the total surface area of a mesh.


## Face Group Boundaries

.. index:: Geometry Nodes; Face Group Boundaries
.. _bpy.types.GeometryNodeMeshFaceSetBoundaries:

**************************
Face Group Boundaries Node
**************************

.. figure:: /images/node-types_GeometryNodeMeshFaceSetBoundaries.webp
   :align: right
   :alt: Face Group Boundaries node.

The *Face Group Boundaries Node* finds the edges which lie on the boundaries of
specified regions. These edges could be used to mark seams for UV unwrapping,
for example.


Inputs
======

Face Group ID
   Identifier for which group of faces this face belongs to. All contiguous faces
   with the same value are in the same region.


Properties
==========

This node has no properties.


Output
======

Boundary Edges
   Selection of the boundary edges of the different face sets. An edge is
   considered to be at the boundary if it lies on at least two faces with
   different identifiers.


Examples
========

.. figure:: /images/modeling_geometry-nodes_face-set-boundaries_voronoi-seams.png

Combined with the :doc:`UV Unwrap Node </modeling/geometry_nodes/mesh/uv/uv_unwrap>`,
this node is used to turn the face sets (right cube) into a UV map for a texture (left cube).


## Face Is Planar

.. index:: Geometry Nodes; Is Face Planar
.. _bpy.types.GeometryNodeInputMeshFaceIsPlanar:

*******************
Is Face Planar Node
*******************

.. figure:: /images/node-types_GeometryNodeInputMeshFaceIsPlanar.webp
   :align: right
   :alt: Is Face Planar Node.

The *Is Face Planar* node outputs whether every triangle of a
:term:`quads <Quad>` or :term:`N-gons <N-gon>` is on the same plane as all of the others, in
other words, if they have the same :doc:`normal </modeling/meshes/editing/mesh/normals>`.

For example, a non-planar face can be created by moving a single vertex in a face but not
the others. Triangles will always be planar.


Inputs
======

Threshold
    The distance a point can be from the surface before the face is no longer
    considered planar.


Properties
==========

This node has no properties.


Outputs
=======

Planar
   Whether each mesh face is planar.


Examples
========

.. figure:: /images/modeling_geometry-nodes_input_face-is-planar_simple.png
   :align: center

Combined with the :doc:`/modeling/geometry_nodes/material/set_material`,
this node is used to visualize all non-planar faces in a mesh.


## Face Neighbors

.. index:: Geometry Nodes; Face Neighbors
.. _bpy.types.GeometryNodeInputMeshFaceNeighbors:

*******************
Face Neighbors Node
*******************

.. figure:: /images/node-types_GeometryNodeInputMeshFaceNeighbors.webp
   :align: right
   :alt: Face Neighbors Node.

The *Face Neighbors* node outputs topology information relating to each face of a mesh.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Vertex Count
   This output is simply the number of sides of each face, or how many corners each face has.

Neighboring Face Count
   The number of faces that connect to this face with at least one edge. On a regular manifold
   mesh with only quads and triangles, this will be the same as the vertex count, otherwise it might
   be completely different.


## Face Set

.. index:: Geometry Nodes; Face Set
.. _bpy.types.GeometryNodeToolFaceSet:

*************
Face Set Node
*************

.. figure:: /images/node-types_GeometryNodeToolFaceSet.webp
   :align: right
   :alt: Face Set node.

The *Face Set Node* outputs which :ref:`face set <face_sets>` a face is in,
and whether or not face sets exist in the mesh at all.

The corresponding data flow node is the :doc:`/modeling/geometry_nodes/mesh/write/set_face_set`.

.. note::

   This node can only be used in the :ref:`Tool context <tool_context>`.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Output
======

Face Set
   Integer indicating which face set a face is in, or 0 when the mesh does not have face sets.
   When evaluated in the edge or point domain, outputs an interpolated value based on the connected faces.

Exists
   Boolean value that indicates whether the element's mesh has face sets.


## Index


###################
  Read Mesh Nodes
###################

.. toctree::
   :maxdepth: 1

   edge_angle.rst
   edge_neighbors.rst
   edge_vertices.rst
   edges_to_face_groups.rst
   face_area.rst
   face_group_boundaries.rst
   face_neighbors.rst
   face_set.rst
   face_is_planar.rst
   is_edge_smooth.rst
   is_face_smooth.rst
   mesh_island.rst
   shortest_edge_paths.rst
   vertex_neighbors.rst


## Is Edge Smooth

.. index:: Geometry Nodes; Is Edge Smooth
.. _bpy.types.GeometryNodeInputEdgeSmooth:

*******************
Is Edge Smooth Node
*******************

.. figure:: /images/node-types_GeometryNodeInputEdgeSmooth.webp
   :align: right
   :alt: Is Edge Smooth Node.

The *Is Edge Smooth* node outputs true for each edge of the mesh that is *not* marked as sharp. Otherwise, if the edge
*is* marked as sharp, then the node outputs false.

.. seealso::

   :ref:`Mark Sharp & Clear Sharp <bpy.ops.mesh.mark_sharp>`


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Smooth
   Boolean value that indicates whether the edges of the mesh are *not* marked as sharp.


## Is Face Smooth

.. index:: Geometry Nodes; Is Face Smooth
.. _bpy.types.GeometryNodeInputShadeSmooth:

*******************
Is Face Smooth Node
*******************

.. figure:: /images/node-types_GeometryNodeInputShadeSmooth.webp
   :align: right
   :alt: Is Face Smooth Node.

The *Is Face Smooth* node outputs true for each face of the mesh if that face
is marked to render smooth shaded. Otherwise, if the face is marked to render as flat
shaded, then the node outputs false.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Smooth
   Boolean value that indicates whether the normals of each face corner on the final mesh
   are smoothed with normal of all adjacent faces or not.


## Mesh Island

.. index:: Geometry Nodes; Mesh Island
.. _bpy.types.GeometryNodeInputMeshIsland:

****************
Mesh Island Node
****************

.. figure:: /images/node-types_GeometryNodeInputMeshIsland.webp
   :align: right
   :alt: Mesh Island Node.

The *Mesh Island* node outputs information about separate connected regions, or "islands" of a mesh.
Whenever two vertices are connected together by an edge, they are considered as part of the same island,
and will have the same *Island Index* output.

This node's behavior is similar to the :ref:`Select Linked <bpy.ops.mesh.select_linked>` operator
in edit mode, or the *Random per Island* output of the
:doc:`Geometry shader node </render/shader_nodes/input/geometry>`.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Island Index
   The index of each vertex's island. Indices are decided based on the
   lowest vertex index contained in each island.

Island Count
   The total number of mesh islands. This is a single value, and does not vary per element.


## Shortest Edge Paths

.. index:: Geometry Nodes; Shortest Edge Paths
.. _bpy.types.GeometryNodeInputShortestEdgePaths:

************************
Shortest Edge Paths Node
************************

.. figure:: /images/node-types_GeometryNodeInputShortestEdgePaths.webp
   :align: right
   :alt: Shortest Edge Paths Node.

The *Shortest Edge Paths* node finds paths along mesh edges to a selection of end vertices.
The cost used to define "shortest" can be set to anything. By default there is a constant cost
for every edge, but a typical input would be the length of each edge.

The output is encoded with vertex indices, and is meant to be used on the vertex domain.
For each vertex, the *Next Vertex Input* output stores the index of the following vertex
in the path to the "closest" endpoint.

The node is implemented with `Dijkstra's algorithm <https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>`__.

.. tip::

   .. figure:: /images/modeling_geometry-nodes_mesh_shortest-edge-paths_distance.png
      :align: center

   The edge length is a natural input to the *Edge Cost*. It can be implemented with the
   :doc:`/modeling/geometry_nodes/mesh/read/edge_vertices` and the
   :doc:`/modeling/geometry_nodes/utilities/vector/vector_math` set to the *Distance* operation.

.. seealso::

   This node can be used with the :doc:`/modeling/geometry_nodes/mesh/operations/edge_paths_to_selection`
   or the :doc:`/modeling/geometry_nodes/mesh/operations/edge_paths_to_curves` to generate new geometry
   based on the paths.


Inputs
======

End Vertex
   A selection of the goal vertices that terminate the edge paths.

Edge Cost
   The weight for each edge, used to determine the meaning of "shortest."


Properties
==========

This node has no properties.


Outputs
=======

Next Vertex Index
   The following vertex on the shortest path from every vertex to the closest endpoint
   (as defined by the cost input).

Total Cost
   The remaining cost before an end vertex is reached by following the next vertex indices


## Vertex Neighbors

.. index:: Geometry Nodes; Vertex Neighbors
.. _bpy.types.GeometryNodeInputMeshVertexNeighbors:

*********************
Vertex Neighbors Node
*********************

.. figure:: /images/node-types_GeometryNodeInputMeshVertexNeighbors.webp
   :align: right
   :alt: Vertex Neighbors Node.

The *Vertex Neighbors* node outputs topology information relating to each vertex of a mesh.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Vertex Count
   The number of vertices connected to this vertex with an edge, equal to the number of connected edges.

Face Count
   The number of faces that contain the vertex.


## Index


#####################
  Mesh Sample Nodes
#####################

.. toctree::
   :maxdepth: 1

   sample_nearest_surface.rst
   sample_uv_surface.rst


## Sample Nearest Surface

.. index:: Geometry Nodes; Sample Nearest Surface
.. _bpy.types.GeometryNodeSampleNearestSurface:

***************************
Sample Nearest Surface Node
***************************

.. figure:: /images/node-types_GeometryNodeSampleNearestSurface.webp
   :align: center
   :alt: Sample Nearest Surface node.

The *Sample Nearest Surface* node finds values at the closest points on
the surface of a source mesh geometry. Non-face attributes are interpolated
across the surface.

This node is similar to the :doc:`/modeling/geometry_nodes/geometry/sample/geometry_proximity`,
but it gives the value of any attribute at the closest surface point, not just its position.

.. warning::

   Because the node samples the *surface* of a mesh rather than its edges or vertices,
   values from loose points and edges are ignored.


Inputs
======

Mesh
   The geometry to retrieve the attribute from.

Value
   A field to evaluate on the *Source* geometry for use with the transfer method.

Sample Position
   The position to start from when finding the closest location on the target mesh.
   By default, this is the same as if the :doc:`/modeling/geometry_nodes/geometry/read/position` was connected.


Properties
==========

Data Type
   The :ref:`data type <attribute-data-types>` to use for the retrieved values.


Outputs
=======

Value
   The data retrieved and interpolated from the *Source* geometry, mapped based on the node's settings and inputs.


## Sample Uv Surface

.. index:: Geometry Nodes; Sample UV Surface
.. _bpy.types.GeometryNodeSampleUVSurface:

**********************
Sample UV Surface Node
**********************

.. figure:: /images/node-types_GeometryNodeSampleUVSurface.webp
   :align: center
   :alt: Sample UV Surface node.

The *Sample UV Surface* node finds values on a mesh's surface at specific UV locations.
Internally the process is a "reverse UV lookup" from a location in 2D space. The node then
finds the face that corresponds to each UV coordinate, and the location within that face.

.. warning::

   Because of the node's method of computation, the UV map should not have any overlapping faces.
   If the UV map is sampled at a location with no faces or overlapping faces, the node will
   output the default value for the data type, which is zeros for most types.


Inputs
======

Mesh
   A geometry containing the mesh with a UV map for sampling.

Value
   A field to evaluate on the target *Mesh* geometry for later sampling at the surface positions.

UV Map
   The mesh UV map to sample, evaluated on the *Mesh* input. Should not have overlapping faces.

Sample UV
   The coordinates to sample within the UV map.


Properties
==========

Data Type
   The :ref:`data type <attribute-data-types>` to use for the retrieved values.


Outputs
=======

Value
   The data retrieved and interpolated from the *Mesh* geometry, mapped based on the node's settings and inputs.

Is Valid
   Whether the node could find a single face to sample at the UV coordinate.


## Corners Of Edge

.. index:: Geometry Nodes; Corners of Edge
.. _bpy.types.GeometryNodeCornersOfEdge:

********************
Corners of Edge Node
********************

.. figure:: /images/node-types_GeometryNodeCornersOfEdge.webp
   :align: right
   :alt: Corners of Edge node.

Selects a neighboring face corner of an edge and outputs its index.

This node is a bit special because it operates in two different domains.
First, it evaluates a *Weight* for each corner in the geometry.
Then, for each item in the context domain, it will:

- Pick an edge from the geometry based on the *Edge Index*.
- Find *some* (not all) face corners connected to this edge -- see below.
- Sort these corners by their associated weight.
- Pick a corner from the above sorted list based on the *Sort Index*,
  where 0 means the corner with the lowest weight,
  1 means the corner with the second-lowest weight and so on.
- Output the geometry-wide index of this corner.

.. warning::

   As illustrated below, the node only looks at one corner per connected face.
   Even though the edge has four neighboring corners, *Corner Index* can only return the
   indexes of two of them, and *Total* will similarly return 2.

   You can use the :doc:`/modeling/geometry_nodes/mesh/topology/offset_corner_in_face`
   to retrieve the indexes of the other corners.

.. figure:: /images/modeling_geometry-nodes_corners-of-edge_explanation.png
   :align: center
   :width: 400px

   A graphic for which corners are returned for a given edge

* Red: selected edge.
* Blue: the corners whose index can be retrieved using this node.
* Purple: the corners that can be retrieved by offsetting the blue corner indices using
  the :doc:`/modeling/geometry_nodes/mesh/topology/offset_corner_in_face`.

Inputs
======

Edge Index
   The index of the edge for which to find connected corners.

   .. note::

      If this input is not connected, it uses the
      :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      of the context item, which means it's important that the node is evaluated
      in the Edge domain.

Weights
   The weights of the corners in the geometry. Unlike the other inputs which follow
   the context domain, this one is always evaluated in the Face Corner domain.

   The corners are sorted by their associated weight in ascending order.
   Corners with the same weight are sorted by their index.

Sort Index
   The 0-based index of the corner to select from the edge's sorted corners.
   If this value is outside the range of valid indices, it wraps around.


Properties
==========

This node has no properties.


Outputs
=======

Corner Index
   The geometry-wide index of the selected corner. You can pass this to the
   :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index` or the
   :doc:`/modeling/geometry_nodes/geometry/sample/sample_index` (with the domain set to Face Corner)
   to retrieve details about the corner.

   If the edge has no connected corners, *Corner Index* will be zero.

Total
   The number of faces (not face corners!) connected to the edge.

.. seealso::

   The page for the :doc:`/modeling/geometry_nodes/mesh/topology/edges_of_vertex` has an example
   of how to work with the different domains.


## Corners Of Face

.. index:: Geometry Nodes; Corners of Face
.. _bpy.types.GeometryNodeCornersOfFace:

********************
Corners of Face Node
********************

.. figure:: /images/node-types_GeometryCornersOfFace.webp
   :align: right
   :alt: Corners of Face node.

Selects a corner of a face and outputs its index.

This node is a bit special because it operates in two different domains.
First, it evaluates a *Weight* for each corner in the geometry.
Then, for each item in the context domain, it will:

- Pick a face from the geometry based on the *Face Index*.
- Find the corners of this face.
- Sort these corners by their associated weight.
- Pick a corner from the above sorted list based on the *Sort Index*,
  where 0 means the corner with the lowest weight,
  1 means the corner with the second-lowest weight and so on.
- Output the geometry-wide index of this corner.

Inputs
======

Face Index
   The index of the face for which to find the corners.

   .. note::

      If this input is not connected, it uses the
      :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      of the context item, which means it's important that the node is evaluated
      in the Face domain.

Weights
   The weights of the corners in the geometry. Unlike the other inputs which follow
   the context domain, this one is always evaluated in the Face Corner domain.

   The corners are sorted by their associated weight in ascending order.
   Corners with the same weight are sorted by their index.

Sort Index
   The 0-based index of the corner to select from the face's sorted corners.
   If this value is outside the range of valid indices, it wraps around.


Properties
==========

This node has no properties.


Outputs
=======

Corner Index
   The geometry-wide index of the selected corner. You can pass this to the
   :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index` or the
   :doc:`/modeling/geometry_nodes/geometry/sample/sample_index` (with the domain set to Face Corner)
   to retrieve details about the corner.

Total
   The number of corners in the face, which is also its number of edges.

.. seealso::

   The page for the :doc:`/modeling/geometry_nodes/mesh/topology/edges_of_vertex` has an example
   of how to work with the different domains.


## Corners Of Vertex

.. index:: Geometry Nodes; Corners of Vertex
.. _bpy.types.GeometryNodeCornersOfVertex:

**********************
Corners of Vertex Node
**********************

.. figure:: /images/node-types_GeometryNodeCornersOfVertex.webp
   :align: right
   :alt: Corners of Vertex node.

Selects a neighboring face corner of a vertex and outputs its index.

This node is a bit special because it operates in two different domains.
First, it evaluates a *Weight* for each corner in the geometry.
Then, for each item in the context domain, it will:

- Pick a vertex from the geometry based on the *Vertex Index*.
- Find the face corners adjacent to this vertex.
- Sort these corners by their associated weight.
- Pick a corner from the above sorted list based on the *Sort Index*,
  where 0 means the corner with the lowest weight,
  1 means the corner with the second-lowest weight and so on.
- Output the geometry-wide index of this corner.


Inputs
======

Vertex Index
   The index of the vertex for which to find the corners.

   .. note::

      If this input is not connected, it uses the
      :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      of the context item, which means it's important that the node is evaluated
      in the Point domain.

Weights
   The weights of the corners in the geometry. Unlike the other inputs which follow
   the context domain, this one is always evaluated in the Face Corner domain.

   The corners are sorted by their associated weight in ascending order.
   Corners with the same weight are sorted by their index.

Sort Index
   The 0-based index of the corner to select from the vertex's sorted corners.
   If this value is outside the range of valid indices, it wraps around.


Properties
==========

This node has no properties.


Outputs
=======

Corner Index
   The geometry-wide index of the selected corner. You can pass this to the
   :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index` or the
   :doc:`/modeling/geometry_nodes/geometry/sample/sample_index` (with the domain set to Face Corner)
   to retrieve details about the corner.

Total
   The number of adjacent corners, which is also the number of faces.

.. seealso::

   The page for the :doc:`/modeling/geometry_nodes/mesh/topology/edges_of_vertex` has an example
   of how to work with the different domains.


## Edges Of Corner

.. index:: Geometry Nodes; Edges of Corner
.. _bpy.types.GeometryNodeEdgesOfCorner:

********************
Edges of Corner Node
********************

.. figure:: /images/node-types_GeometryNodeEdgesOfCorner.webp
   :align: right
   :alt: Edges of Corner node.

The *Edges of Corner* node retrieves the edges on both sides of a face corner.


Inputs
======

Corner Index
   The index of the input face corner.

   .. note::

      By default this uses the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      from the field context, which makes it important that the node is evaluated on
      the face corner domain.


Properties
==========

This node has no properties.


Outputs
=======

Next Edge Index
   The index of the neighboring edge in the face, in the direction of increasing face corner indices.

Previous Edge Index
   The index of the neighboring edge in the face, in the direction of decreasing face corner indices.


## Edges Of Vertex

.. index:: Geometry Nodes; Edges of Vertex
.. _bpy.types.GeometryNodeEdgesOfVertex:

********************
Edges of Vertex Node
********************

.. figure:: /images/node-types_GeometryNodeEdgesOfVertex.webp
   :align: right
   :alt: Edges of Vertex node.

Selects a neighboring edge of a vertex and outputs its index.

This node is a bit special because it operates in two different domains.
First, it evaluates a *Weight* for each edge in the geometry.
Then, for each item in the context domain, it will:

- Pick a vertex from the geometry based on the *Vertex Index*.
- Find the edges connected to this vertex.
- Sort these edges by their associated weight.
- Pick an edge from the above sorted list based on the *Sort Index*,
  where 0 means the edge with the lowest weight,
  1 means the edge with the second-lowest weight and so on.
- Output the geometry-wide index of this edge.

Inputs
======

Vertex Index
   The index of the vertex for which to find the edges.

   .. note::

      If this input is not connected, it uses the
      :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      of the context item, which means it's important that the node is evaluated
      in the Point domain.

Weights
   The weights of the edges in the geometry. Unlike the other inputs which follow
   the context domain, this one is always evaluated in the Edge domain.

   The edges are sorted by their associated weight in ascending order.
   Edges with the same weight are sorted by their index.

Sort Index
   The 0-based index of the edge to select from the vertex's sorted edges.
   If this value is outside the range of valid indices, it wraps around.


Properties
==========

This node has no properties.


Outputs
=======

Edge Index
   The geometry-wide index of the selected edge. You can pass this to the
   :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index` or the
   :doc:`/modeling/geometry_nodes/geometry/sample/sample_index` (with the domain set to Edge)
   to retrieve details about the edge.

   If the vertex has no connected edges, *Edge Index* will be zero.

Total
   The number of edges connected to the selected vertex.


Example
=======

The example below creates a cone at each vertex of a "cube," aligned to the neighboring edge
that's the most vertical.

First, we calculate a "verticality score" for each of the cube's edges. To do this, we subtract the
positions of its vertices to get its direction vector, which we normalize and use to calculate
the dot product with the Z axis. The absolute value of that gives us a number between 0 and 1,
where 0 means fully horizontal and 1 means fully vertical.

Because the edges will be sorted by ascending weight, we set weight = 1 - verticality.
This way, the most vertical connected edge of each vertex will have the lowest weight
and come first in the list.

Next, in the point domain, we need to calculate the rotation of each cone.
By using the :doc:`/modeling/geometry_nodes/utilities/rotation/align_euler_to_vector`,
the problem gets simplified and we only need to calculate a direction vector.

The direction vector of each cone is the centerpoint of the most vertical neighboring edge
minus the position of the vertex. Finding that most vertical neighboring edge is where the
*Edges of Vertex* node comes in: for each vertex, it sorts the connected edges by their
weight and pick the first one (because the Sort Index is 0). Once we have the edge's index,
we use the :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index` to retrieve its
centerpoint.

With the rotations of the cones calculated, we use the
:doc:`/modeling/geometry_nodes/instances/instance_on_points` to create them.

.. figure:: /images/modeling_geometry-nodes_mesh_topology_edges-of-vertex_example-setup.png

   Example node setup. (Rightclick and choose "Open image in new tab" to see a larger version.)

.. figure:: /images/modeling_geometry-nodes_mesh_topology_edges-of-vertex_example-result.png

   The resulting geometry.


## Face Of Corner

.. index:: Geometry Nodes; Face of Corner
.. _bpy.types.GeometryNodeFaceOfCorner:

*******************
Face of Corner Node
*******************

.. figure:: /images/node-types_GeometryNodeFaceOfCorner.webp
   :align: right
   :alt: Face of Corner node.

Retrieves the face that a face corner is part of.


Inputs
======

Corner Index
   The geometry-wide index of the corner.

   .. note::

      If this input is not connected, it uses the
      :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      of the context item, which means it's important that the node is evaluated
      in the Face Corner domain.


Properties
==========

This node has no properties.


Outputs
=======

Face Index
   The geometry-wide index of the face which the corner belongs to.

Index in Face
   The face-local index of the corner. This is 0 for the first corner of the face,
   1 for the next corner, and so on up to (number of corners - 1) for the last corner.


## Index


#######################
  Mesh Topology Nodes
#######################

Nodes that retrieve information about the connectivity between mesh elements.

.. toctree::
   :maxdepth: 1

   corners_of_edge.rst
   corners_of_face.rst
   corners_of_vertex.rst
   edges_of_corner.rst
   edges_of_vertex.rst
   face_of_corner.rst
   offset_corner_in_face.rst
   vertex_of_corner.rst


## Offset Corner In Face

.. index:: Geometry Nodes; Offset Corner in Face
.. _bpy.types.GeometryNodeOffsetCornerInFace:

**************************
Offset Corner in Face Node
**************************

.. figure:: /images/node-types_GeometryNodeOffsetCornerInFace.webp
   :align: right
   :alt: Offset Corner in Face node.

Retrieves another corner in the same face as the input corner.
This is like "rotating" the input corner around in its face.

Conceptually the operation is similar to the
:doc:`/modeling/geometry_nodes/curve/topology/offset_point_in_curve`.


Inputs
======

Corner Index
   The index of the input face corner.

   .. note::

      If this input is not connected, it uses the
      :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      of the context item, which means it's important that the node is evaluated
      in the Face Corner domain.

Offset
   The number of corners to move around the face before finding the result,
   circling back to the first corner if necessary.


Properties
==========

This node has no properties.


Outputs
=======

Corner Index
   The index of the offset face corner.


## Vertex Of Corner

.. index:: Geometry Nodes; Vertex of Corner
.. _bpy.types.GeometryNodeVertexOfCorner:

*********************
Vertex of Corner Node
*********************

.. figure:: /images/node-types_GeometryNodeVertexOfCorner.webp
   :align: right
   :alt: Vertex of Corner node.

Outputs the index of the vertex that a face corner is attached to.


Inputs
======

Corner Index
   The index of the face corner.

   .. note::

      If this input is not connected, it uses the
      :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`
      of the context item, which means it's important that the node is evaluated
      in the Face Corner domain.


Properties
==========

This node has no properties.


Outputs
=======

Vertex Index
   The index of the vertex that the face corner is attached to.


## Index


############
  UV Nodes
############

Nodes for creating or modifying :term:`UV Maps <UV Map>`.

.. toctree::
   :maxdepth: 1

   pack_uv_islands.rst
   uv_unwrap.rst


## Pack Uv Islands

.. index:: Geometry Nodes; Pack UV Islands
.. _bpy.types.GeometryNodeUVPackIslands:

********************
Pack UV Islands Node
********************


.. figure:: /images/node-types_GeometryNodeUVPackIslands.webp
   :align: right
   :alt: Pack UV Islands node.

The *Pack UV Islands Node* scales islands of a UV map and moves them so they fill the UV space as much as possible.


.. seealso::

   The :ref:`bpy.ops.uv.pack_islands` operator performs a similar operation in the UV editor.


Inputs
======

UV
   The UV map to modify.

Selection
   Faces to consider when packing islands.
   UVs that are part of any other face will not be affected.

Margin
   The distance to leave between UV islands.

Rotate
   Allow Rotating islands for best fit.


Properties
==========

This node has no properties.


Output
======

UV
   The modified UVs.


## Uv Unwrap

.. index:: Geometry Nodes; UV Unwrap
.. _bpy.types.GeometryNodeUVUnwrap:

**************
UV Unwrap Node
**************


.. figure:: /images/node-types_GeometryNodeUVUnwrap.webp
   :align: right
   :alt: UV Unwrap node.

The *UV Unwrap Node* generates a UV map islands based on a selection of seam edges.
The node implicitly performs a :doc:`Pack Islands </modeling/geometry_nodes/mesh/uv/pack_uv_islands>`
operation upon completion, because the results may not be generally useful otherwise.

.. seealso::

   The :ref:`bpy.ops.uv.unwrap` operator performs a similar operation in the UV editor.
   Unlike the Unwrap operator, the node doesn't perform aspect ratio correction,
   because it is trivial to implement with a :doc:`/modeling/geometry_nodes/utilities/vector/vector_math`.


Inputs
======

Selection
   Faces to participate in the unwrap operation.
   UVs that are part of any other face will not be affected.

Seam
   Edges to mark where the mesh is "cut" for the purposes of unwrapping.

Margin
   The distance to leave between UV islands.

Fill Holes
   Virtually fill holes in mesh before unwrapping, to better avoid overlaps and preserve symmetry.


Properties
==========

Method
   :Angle Based:
      This method gives a good 2D representation of a mesh
   :Conformal:
      Uses LSCM (Least Squares Conformal Mapping). This usually gives a less accurate UV
      mapping than Angle Based, but works better for simpler objects


Output
======

UV
   The generated UV coordinates between 0 and 1 for each face corner in the selected faces.

.. note::

   In order for Blender to recognize the created attribute as a UV map,
   it must be created with the :doc:`/modeling/geometry_nodes/attribute/store_named_attribute`
   on the :ref:`Face Corner <attribute-domains>` domain with the :ref:`2D Vector <attribute-data-types>` data type.
   This is necessary because there is no 2D Vector socket type.


## Index


####################
  Write Mesh Nodes
####################

.. toctree::
   :maxdepth: 1

   set_face_set.rst
   set_shade_smooth.rst


## Set Face Set

.. index:: Geometry Nodes; Set Face Set
.. _bpy.types.GeometryNodeToolSetFaceSet:

*****************
Set Face Set Node
*****************

.. figure:: /images/node-types_GeometryNodeToolSetFaceSet.webp
   :align: right
   :alt: Set Face Set node.

The *Set Face Set* node controls which :ref:`face set <face_sets>` that faces are in.

The input node for this data is the :doc:`/modeling/geometry_nodes/mesh/read/face_set`.

.. note::

   This node can only be used in the :ref:`Tool context <tool_context>`.


Inputs
======

Mesh
   Standard geometry input.

Selection
   Boolean field that controls which faces will have the Face Set value applied.

Face Set
   Integer field for specifying which face set each selected face should be moved to.
   Ignored for faces where the value of Selection is false.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.


## Set Shade Smooth

.. index:: Geometry Nodes; Set Shade Smooth
.. _bpy.types.GeometryNodeSetShadeSmooth:

*********************
Set Shade Smooth Node
*********************

.. figure:: /images/node-types_GeometryNodeSetShadeSmooth.webp
   :align: right
   :alt: Set Shade Smooth node.

The *Set Shade Smooth* node controls whether the mesh's faces look smooth in the viewport and renders.
The smooth status of both edges and faces can be controlled, corresponding to the ``sharp_edge`` and
``sharp_face`` attributes.
The input node for this data is the :doc:`/modeling/geometry_nodes/mesh/read/is_face_smooth`.


Inputs
======

Mesh
   Standard geometry input.

Shade Smooth
   When true, the selected faces will be marked to render smooth shaded.
   Otherwise the faces will be rendered flat shaded.

Selection
   Boolean input for selecting which faces will have the Shade Smooth value applied.


Properties
==========

Domain
   Whether to write smoothness of mesh faces or edges.


Outputs
=======

Mesh
   Standard geometry output.


## Index


#################
  Normals Nodes
#################

.. toctree::
   :maxdepth: 1

   smooth_by_angle.rst


## Smooth By Angle


**************************
Smooth By Angle Node Group
**************************

Set the sharpness of mesh edges based on the angle between the neighboring faces.

.. note::

   This is a node group asset that is included in the bundled :ref:`"Essentials" asset library <assets-bundled>`.


Inputs
======

Mesh
   Standard geometry input.
Angle
   Maximum angle between face normals that will be considered as smooth.
Ignore Sharpness
   Smooth all edges, even if they have been marked as sharp.


Properties
==========

This node has no properties.


Outputs
=======

Mesh
   Standard geometry output.


## Index


################
  Output Nodes
################

Nodes that output to outside the node tree.

.. toctree::
   :maxdepth: 1

   viewer.rst


## Viewer

.. index:: Geometry Nodes; Viewer
.. _bpy.types.GeometryNodeViewer:

***********
Viewer Node
***********

.. figure:: /images/node-types_GeometryNodeViewer.webp
   :align: right
   :alt: The Viewer node.

The *Viewer* node allows viewing data from inside a geometry node group in the
:doc:`Spreadsheet Editor </editors/spreadsheet>` and the 3D Viewport.

Any geometry connected can be visualized in the viewport and its attribute values
can be read in the spreadsheet.

.. note::

   This node cannot be used in the :ref:`Tool context <tool_context>`—only in the *Modifier* context.


Usage
=====

Activation and Deactivation
---------------------------

Using :kbd:`Shift-Ctrl-LMB` on any node or socket connects it to the viewer and makes it active.
Using the same shortcut on empty space in the node editor makes deactivates the active viewer.
When the active viewer is not visible anymore (e.g. another object is selected, or the current
node group is exited), it is deactivated. The icon in the viewer node header can also be used
to activate and deactivate it.

.. _bpy.types.SpaceView3D.show_viewer:

In the viewport, the *Show Viewer* option can turn off the viewer node visualization completely
in order to see the final output of the object's evaluation instead.


Attribute Visualization
-----------------------

When the viewer has a geometry and a separate value input connected, the values can be visualized
with a :ref:`viewport overlays <3dview-overlays-view_node>`. When possible, the
:ref:`attribute domain <attribute-domains>` is used to visualize the data is determined automatically.
Otherwise, the viewer node falls back to the face corner domain on meshes and the point domain
on curves. When necessary, the domain can be chosen manually.

The spreadsheet now only shows the "Viewer" column for the domain that is selected in the Viewer node.


Pinning
-------

It can be helpful to pin a specific viewer node in the spreadsheet. When pinned, the spreadsheet
still references the viewer node even when it becomes inactive.


Inputs
======

Geometry
   Geometry that will be displayed in the Spreadsheet.

Value
   Field to be evaluated on the geometry.
   The type for this value is chosen automatically when the keyboard shortcut to link
   an output is pressed. However, if the type must be adjusted manually,
   it is available in the node editor Sidebar.


Properties
==========

Data Type
   The data type used to evaluate the *Value* input, visible in the node side-bar.

Domain
   The :ref:`attribute domain <attribute-domains>` used to evaluate the *Value* input.
   The *Auto* option chooses the domain automatically based on the connected nodes.


Outputs
=======

This node has no outputs.


## Distribute Points In Volume

.. index:: Geometry Nodes; Distribute Points in Volume
.. _bpy.types.GeometryNodeDistributePointsInVolume:

***************************
Distribute Points in Volume
***************************

.. figure:: /images/node-types_GeometryNodeDistributePointsInVolume.webp
   :align: center
   :alt: Distribute Points in Volume node.


The *Distribute Points in Volume* node creates points inside of volume grids.
The node has two basic modes of operation: distributing points randomly, or in
a regular grid. Both methods operate on all of the float grids in the volume.


Inputs
======

Volume
   Standard volume geometry input.

Density
   Number of points to sample per unit volume.

Spacing
   Spacing between grid points.

Threshold
   Minimum value of a volume cell to contain a grid point


Properties
==========

Distribution Method
   :Random:
      Distribute points randomly inside of the volume. The local point count is implicitly
      defined as a product of the global from the *Density* input and the local voxel value.
      This method creates a distribution that is not stable as the input volume deforms.
   :Grid:
      Distribute the points in a grid pattern inside of the volume. At each grid point, the voxel
      value is used to determine whether to add a point.


Outputs
=======

Points
   Standard point cloud geometry output.


## Distribute Points On Faces

.. index:: Geometry Nodes; Distribute Points on Faces
.. _bpy.types.GeometryNodeDistributePointsOnFaces:

**************************
Distribute Points on Faces
**************************

.. figure:: /images/node-types_GeometryNodeDistributePointsOnFaces.webp
   :align: right
   :alt: Distribute Points on Faces node.

The *Distribute Points on Faces* node places points on the surface of the input geometry object.
Point, corner, and polygon attributes of the input geometry are transferred to the generated points.
That includes vertex weights and UV maps.
Additionally, the node has *Normal* and *Rotation* outputs.

The node also generates a stable ID, stored in the built-in ``id`` attribute, used as
a stable identifier for each point. When the mesh is deformed or the density changes
the values will be consistent for each remaining point. This attribute is used in
the :doc:`Random Value </modeling/geometry_nodes/utilities/random_value>` and
:doc:`Instance on Points </modeling/geometry_nodes/instances/instance_on_points>` nodes.


Inputs
======

Mesh
   Standard geometry input.

   .. note::

      The input geometry must contain a mesh with faces.

Selection
   The selection of which face corners should be considered for point distribution.

Distance Min
   The minimal distance points can have to each other.
   This option is only available for the *Poisson Disk* distribution method.
   At its default value of zero, the node's behavior is the same as it is in *Random* mode,
   because none of the internally generated points are removed.

Density Max
   The point density for the point distribution. The unit is in number of points per square meter.
   This value is multiplied by the values from the *Density* input. Only available in *Poisson Disk* mode.

   .. note::

      This will be capped on distributions by the *Distance Min* option.
      If the density is greater than what the minimal distance allows,
      no new points will be added after this threshold has been passed.

Density
   The number of points to distribute per square meter on each mesh face.
   This value is multiplied by the values from the *Density Attribute*.

   In *Poisson Disk* mode, this value is multiplied by the *Density Max* input for the final density.

Seed
   The random :term:`Seed` to use when generating points.


Properties
==========

Distribution Method
   :Random:
      Distribute points randomly on the surface. This is the fastest distribution method.
   :Poisson Disk:
      Distribute points randomly on the surface while taking a minimum distance into account.

Legacy Normal
   By default, the node uses smooth and custom normals for the *Normal* and *Rotation* values .
   An earlier version of this node only uses "true" normals,
   this option brings back this behavior of only using "true" normals.

   This option can only be available in the Sidebar.


Outputs
=======

Points
   Generated points. Named attributes are copied to the result mesh, along with the data in the other
   attribute field outputs.

Normal
   The :term:`Normal` of the triangle on which each point is scattered.

Rotation
   An XYZ :term:`Euler` rotation built from the normal attribute for convenience. Such a value can also be
   built from the normal with the :doc:`/modeling/geometry_nodes/utilities/rotation/euler_to_rotation`.
   Keep in mind that the Z axis of the result rotation will be arbitrary, since the mesh normal used
   to create the rotation does not have enough information to set all three rotation axes.


## Index


###############
  Point Nodes
###############

Nodes generate or modify point clouds.

.. toctree::
   :maxdepth: 1

   distribute_points_in_volume.rst
   distribute_points_on_faces.rst
   points.rst
   points_to_curves.rst
   points_to_vertices.rst
   points_to_volume.rst

----

.. toctree::
   :maxdepth: 1

   set_point_radius.rst


## Points

.. index:: Geometry Nodes; Points
.. _bpy.types.GeometryNodePoints:

***********
Points Node
***********

.. figure:: /images/node-types_GeometryNodePoints.webp
   :align: right
   :alt: Points node.

The *Points* node generate a point cloud with positions and radii defined by
:doc:`fields </modeling/geometry_nodes/fields>`.


Inputs
======

Count
   The number of points to create.

Position
   The position of each generated point.

Radius
   The :doc:`radius </modeling/geometry_nodes/geometry/read/radius>` of each point.

.. note::

   Since the point cloud is created from scratch, the *Position* and *Radius* inputs can only depend on
   the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>` node. Regular input nodes like
   the :doc:`position </modeling/geometry_nodes/geometry/read/position>` won't work.


Properties
==========

This node has no properties.


Outputs
=======

Points
   Standard geometry output.


## Points To Curves

.. index:: Geometry Nodes; Points to Curves
.. _bpy.types.GeometryNodePointsToCurves:

*********************
Points to Curves Node
*********************

.. figure:: /images/node-types_GeometryNodePointsToCurves.webp
   :align: right
   :alt: Points to Curves node.
   :width: 250px

The *Points to Curves* node generates a :doc:`Curves </modeling/curves/introduction>` geometry by taking all
points and inserting them to new curves. All :doc:`Attributes </modeling/geometry_nodes/attributes_reference>`
from points are propagated to :ref:`Curve Points <attribute-domains>`.
:ref:`Built-in <geometry-nodes_builtin-attributes>` curves attributes stored in points will be ignored.

.. tip::

   To simplify thinking about points, attributes and their positions in each curve,
   The weight of each point in curve can be associated with a point attributes value.
   The sorting and grouping will be reflected on the attributes as like on the Weight and Group ID.


Inputs
======

Points
   The Point Cloud geometry component.

Curve Group ID
   All points with the same Group ID value will be joined in the same curve.
   The value of Group ID can be any value (negative, zero, or infinity, etc.).
   All created curves must have at least a single point.
   The order of curves depends both on Group ID value and on the order of Group ID values in the Point Cloud.

Weight
   If the curve contains more than one Point, the Weight of each Point is used to define the
   order of all points in curve via sorting. The goal of sorting is to have points with the minimal
   Weight value at the start of curve and the maximum Weight at the end of curve.

.. note::

   If points of curve have the same Weight value, the order will be the same as its original relative location.
   Without any Weight and Group ID inputs, each point will have the same indices in the curve.


Properties
==========

This node has no properties.


Outputs
=======

Curves
   The curves with all copied points from the Point Cloud,
   but joined in curves. All other components aren't saved.
   The resulting curves are always non-cyclic.


Examples
========

.. figure:: /images/modeling_geometry-nodes_points-to-curves.png

The above example creates a curve Array with connections between curves.
This is created by duplicating the :doc:`Arc primitive </modeling/geometry_nodes/curve/primitives/arc>`
curve with the :doc:`/modeling/geometry_nodes/geometry/operations/duplicate_elements`.
Each curve is shifted in a top direction based on its index value.
All the curves are converted to the Point Cloud by the
:doc:`/modeling/geometry_nodes/curve/operations/curve_to_points`.
Finally, the points are converted to curves by the Points to Curves node.

All the Points of the resulting Curves geometry have the same
attributes as points on the initial Arc primitive.


## Points To Vertices

.. index:: Geometry Nodes; Points to Vertices
.. _bpy.types.GeometryNodePointsToVertices:

***********************
Points to Vertices Node
***********************

.. figure:: /images/node-types_GeometryNodePointsToVertices.webp
   :align: center
   :alt: Points to Vertices node.

The *Points to Vertices* node generate a mesh vertex in the output geometry for
each point cloud point in the input geometry.


Inputs
======

Geometry
   Standard geometry input.

Selection
   Boolean field used to determine if each point will be converted to a vertex.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Points To Volume

.. index:: Geometry Nodes; Points to Volume
.. _bpy.types.GeometryNodePointsToVolume:

*********************
Points to Volume Node
*********************

.. figure:: /images/node-types_GeometryNodePointsToVolume.webp
   :align: center
   :alt: Points to Volume node.

The *Points to Volume* node generates a fog volume sphere around every point in the input geometry.
The new volume grid is named "density".

It usually makes sense to combine this node with the
:doc:`/modeling/geometry_nodes/volume/operations/volume_to_mesh`.

.. warning::

   This node expects that point positions are not extremely large.
   For position values of many billions, the behavior isn't guaranteed, and it may be unstable.


Inputs
======

Points
   Standard geometry input.

Density
   Value of voxels inside the generated fog volume.

Voxel Amount
   Specify the approximate number of voxels along the diagonal.

Voxel Size
   Specify the voxel side length.

Radius
   Specify the radius of the sphere generated at each point.


Properties
==========

Resolution
   How the voxel size is specified.

   :Amount:
      Specify the approximate number of voxels along the diagonal.
   :Size:
      Specify the voxel side length. It is recommended to be careful when tweaking this value,
      because small changes can have a large effect on the processing time.


Outputs
=======

Volume
   Standard geometry output.


## Set Point Radius

.. index:: Geometry Nodes; Set Point Radius
.. _bpy.types.GeometryNodeSetPointRadius:

*********************
Set Point Radius Node
*********************

.. figure:: /images/node-types_GeometryNodeSetPointRadius.webp
   :align: right
   :alt: Set Point Radius node.

The *Set Point Radius* node controls the size each selected point cloud point should display with in the viewport.

The input node for this data is the :doc:`/modeling/geometry_nodes/geometry/read/radius`.


Inputs
======

Geometry
   Standard geometry input.

Radius
   Float value indicating the radius of the point geometry at each point.

Selection
   Boolean input for selecting which points will have the radius value applied.


Properties
==========

This node has no properties.


Outputs
=======

Geometry
   Standard geometry output.


## Simulation Zone

.. index:: Geometry Nodes; Simulation Zone
.. _bpy.types.GeometryNodeSimulationInput:
.. _bpy.types.GeometryNodeSimulationOutput:

***************
Simulation Zone
***************

Simulation zones allow the result of one frame to influence the next one.
That way even a set of simple rules can lead to complex results, with the passing of time.
The most common type of them is physics simulation, with specific solvers for physical phenomena.

.. figure:: /images/modeling_geometry-nodes_simulation_zone.png
   :align: center

   Initial simulation nodes and simulation zone.

When adding a simulation, two nodes are added, defining between them a "Simulation Zone".

The inputs that are connected to the Simulation Input node are evaluated only once,
at the beginning of the simulation, passed to the next simulation state and eventually outputted.
Other nodes can be linked inside the simulation region from the outside.
Those are re-evaluated every step based on their value at the given frame.

It is not possible to have any link going towards outside.
The result of the simulation can only be accessed via the Simulation Output node.
This also allows sub-frame interpolation for motion blur.

.. note::

   This node cannot be used in the :ref:`Tool context <tool_context>`—only in the *Modifier* context.


Clock
=====

The simulation is tied to the animation system, with support for sub-steps.
It will only be evaluated while the animation frame changes, and is cached like
the existing physics simulations in Blender.


Properties
==========

In the Node Editor the inputs can be renamed, shuffled and removed.
This is also the place where sub-steps can be defined for a simulation.


Inputs
------

Delta Time
   The time in seconds between frames.
   Essentially this the inverse of the render :ref:`Frame Rate <bpy.types.RenderSettings.fps>`.

   This delta is used to drive the simulation by connecting it node setups that depend on a rate.
   This will keep the simulation playback consistent when the frame rate changes.

Skip
   Forward the output of the simulation input node directly
   to the output node and ignore the nodes in the simulation zone.


.. _geometry_nodes-simulation-baking:

Baking
======

The simulation is automatically cached during playback.
The valid cache can be seen as a strong yellow line in the timeline editor.
This allows for animators to quickly inspect all the previous frames of a simulation.

.. figure:: /images/modeling_geometry-nodes_simulation_baking_timeline.png
   :align: center

   Cached frames in the Timeline.

For the cases where the current frame is the only one relevant, users can opt-out of "Cache" to save memory.

When the result is ready to be sent to a render-farm, it can be baked to disk.
This allows for the simulation to be rendered in a non-sequential order.

.. figure:: /images/modeling_geometry-nodes_simulation_baking.png
   :align: center

   Simulation and Physics, Simulation Nodes user interface.

.. note::

   Baking the simulation will bake all the simulations in all modifiers for the selected objects.


Examples
========

Combined with the :doc:`/modeling/geometry_nodes/geometry/sample/index_of_nearest`,
this can be used for a number of sphere-based simulations.

.. figure:: /images/modeling_geometry-nodes_simulation_example.png
   :align: center

   Index of Nearest sample file CC-BY Sean Christofferson.


## Brick

.. index:: Geometry Nodes; Brick Texture

******************
Brick Texture Node
******************

.. note::

   This node is ported from shader nodes. The manual and images are
   referencing the shader version of the node.
   This node accepts field inputs and outputs.
   When not connected the Vector input has an implicit ``position`` attribute value.

.. tip::

   Texture nodes can produce details at a higher frequency
   than geometry can show. This may cause artifacts such
   as Moiré type patterns or a lack of detail due to
   insufficient sampling points.

.. figure:: /images/node-types_ShaderNodeTexBrick.webp
   :align: right
   :alt: Brick Texture node.

The *Brick Texture* is used to add a procedural texture producing bricks.


Inputs
======

Color 1/2
   Color of the bricks.
Mortar
   The color of the area between bricks.
Scale
   Overall texture scale.
Mortar Size
   The size of the filling between the bricks known as "mortar"; 0 means no mortar.
Mortar Smooth
   Blurs/softens the edge between the mortar and the bricks.
   This can be useful with a texture and displacement textures.
Bias
   The color variation between *Color 1/2*.
   Values of -1 and 1 only use one of the two colors; values in between mix the colors.
Brick Width
   The width of the bricks.
Row Height
   The height of the brick rows.


Properties
==========

Offset
   Determines the brick offset of the various rows.
Frequency
   Determines the offset frequency. A value of 2 gives an even/uneven pattern of rows.
Squash
   Amount of brick squashing.
Frequency
   Brick squashing frequency.


Outputs
=======

Color
   Texture color output.
Factor
   Mortar mask (1 = mortar).


Examples
========

.. figure:: /images/render_shader-nodes_textures_brick_example.jpg
   :width: 200px

   Brick texture: Colors changed, Squash 0.62, Squash Frequency 3.


## Checker

.. index:: Geometry Nodes; Checker Texture

********************
Checker Texture Node
********************

.. note::

   This node is ported from shader nodes. The manual and images are
   referencing the shader version of the node.
   This node accepts field inputs and outputs.
   When not connected the Vector input has an implicit ``position`` attribute value.

.. tip::

   Texture nodes can produce details at a higher frequency
   than geometry can show. This may cause artifacts such
   as Moiré type patterns or a lack of detail due to
   insufficient sampling points.

.. figure:: /images/node-types_ShaderNodeTexChecker.webp
   :align: right
   :alt: Checker Texture node.

The *Checker Texture* is used to add a checkerboard texture.

Inputs
======

Vector
   Texture coordinate to sample texture at;
   defaults to Generated texture coordinates if the socket is left unconnected.

   .. warning::

      This node can have precision issues with some vector inputs.
      See the notes for the :doc:`White Noise Texture </render/shader_nodes/textures/white_noise>`
      for ways to mitigate this issue.

Color1, Color 2
   Color of the checkers.
Scale
   Overall texture scale. The scale is a factor of the bounding box of the face divided by the scale.
   For example, a scale of 15 will result in 15 alternate patterns over the overall UV bounding box.
   Different patterns could be achieved using other nodes to give different input patterns to this socket.
   For example, using the Math node.


Properties
==========

This node has no properties.


Outputs
=======

Color
   Texture color output.
Factor
   Checker 1 mask (1 = Checker 1).


Examples
========

.. figure:: /images/render_shader-nodes_textures_checker_example.jpg
   :width: 200px

   Default Checker texture.


## Gradient

.. index:: Geometry Nodes; Gradient Texture

*********************
Gradient Texture Node
*********************

.. note::

   This node is ported from shader nodes. The manual and images are
   referencing the shader version of the node.
   This node accepts field inputs and outputs.
   When not connected the Vector input has an implicit ``position`` attribute value.

.. figure:: /images/node-types_ShaderNodeTexGradient.webp
   :align: right
   :alt: Gradient Texture Node.

The *Gradient Texture* node generates interpolated color and intensity values based on the input vector.


Inputs
======

Vector
   Texture coordinate to sample texture at;
   defaults to Generated texture coordinates if the socket is left unconnected.


Properties
==========

Type
   Controls the type of gradient generated.

   :Linear: Directly outputs the input X coordinate.
   :Quadratic: Interpolates the input X coordinate quadratically.
   :Easing: Uses a combination of quadratic and linear interpolation
      to generate a smooth gradient from the input X coordinate.
   :Diagonal: Averages the input X and Y coordinates.
   :Spherical: Creates an inverse gradient using the length of the input vector; the maximum value is at (0, 0, 0).
   :Quadratic Sphere: The same as Spherical, except interpolated quadratically.
   :Radial: Outputs a value based on the angle of the input around the Z axis.


Outputs
=======

Color
   Texture color output.
Factor
   Texture intensity output.


Examples
========

.. figure:: /images/render_shader-nodes_textures_gradient_example.jpg
   :width: 200px

   Gradient texture using object coordinates.


## Image

.. index:: Geometry Nodes; Image Texture
.. _bpy.types.GeometryNodeImageTexture:

******************
Image Texture Node
******************

.. note::

   Unlike the other texture nodes, this node operates differently
   in geometry nodes compared to the equivalent shader node.
   When not connected the Vector input has an implicit ``position`` attribute value.

.. figure:: /images/node-types_GeometryNodeImageTexture.webp
   :align: right
   :alt: Image Texture node.

The *Image Texture* node is used to add an image file as a texture.
The image data is sampled with the input Vector and outputs a Color and Alpha value.


Inputs
======

Image
   The image socket can be used to connect to the Group Input node.
   If this is not connected the image can be opened or selected from the node.

Vector
   Texture coordinate for texture look-up. If this socket is left unconnected,
   the Position attribute is used.

Frame
   If the Image supports animation, the frame can be set here.
   This can be keyframed so that the image changes between frames.


Properties
==========

Interpolation
   Method to scale images up or down for sampling.

   :Linear: Regular quality interpolation.
   :Cubic: Smoother, better quality interpolation. For bump maps this should be used to get best results.
   :Closest: No interpolation, use only closest pixel for rendering pixel art.

Extension
   Extension defines how the image is extrapolated past the original bounds:

   :Repeat: Will repeat the image horizontally and vertically giving tiled-looking result.
   :Extend: Will extend the image by repeating pixels on its edges.
   :Clip: Clip to the original image size and set all the exterior pixels values to transparent black.
   :Mirror: Repeatedly flip the image horizontally and vertically.


Outputs
=======

Color
   RGBA color from the image.
Alpha
   Alpha channel from image.

Examples
========

.. figure:: /images/modeling_geometry-nodes_texture-nodes_image_texture_node_example.jpg

   Image Texture displacing a plane.


## Index


#################
  Texture Nodes
#################

Nodes to add textures.

.. tip::

   Texture nodes can produce details at a higher frequency
   than geometry can show. This is more evident with textures
   that produce abrupt changes such as brick and checker.
   This may cause artifacts such as Moiré type patterns
   or a lack of detail due to insufficient sampling points.

.. toctree::
   :maxdepth: 1

   brick.rst
   checker.rst
   gradient.rst
   image.rst
   magic.rst
   musgrave.rst
   noise.rst
   voronoi.rst
   wave.rst
   white_noise.rst


## Magic

.. index:: Geometry Nodes; Magic Texture

******************
Magic Texture Node
******************

.. note::

   This node is ported from shader nodes. The manual and images are
   referencing the shader version of the node.
   This node accepts field inputs and outputs.
   When not connected the Vector input has an implicit ``position`` attribute value.

.. figure:: /images/node-types_ShaderNodeTexMagic.webp
   :align: right
   :alt: Magic Texture Node.

The *Magic Texture* node is used to add a psychedelic color texture.


Inputs
======

Vector
   Texture coordinate to sample texture at;
   defaults to Generated texture coordinates if the socket is left unconnected.
Scale
   Scale of the texture.
Distortion
   Amount of distortion.


Properties
==========

Depth
   Number of iterations.


Outputs
=======

Color
   Texture color output.
Factor
   Texture intensity output.


Examples
========

.. figure:: /images/render_shader-nodes_textures_magic_example.jpg
   :width: 200px

   Magic texture: Depth 10, Distortion 2.0.


## Musgrave

.. index:: Geometry Nodes; Musgrave Texture

*********************
Musgrave Texture Node
*********************

The Musgrave texture node was replaced by the
:doc:`Noise Texture </modeling/geometry_nodes/texture/noise>` node,
which includes all the same functionality.

* The Dimension input was replaced by a Roughness input, where :math:`Roughness = Lacunarity^{-Dimension}`.
* The Detail input value must be subtracted by 1 compared to the old Musgrave Texture node.



## Noise

.. index:: Geometry Nodes; Noise Texture

******************
Noise Texture Node
******************

.. note::

   This node is ported from shader nodes. The manual and images are
   referencing the shader version of the node.
   This node accepts field inputs and outputs.
   When not connected the Vector input has an implicit ``position`` attribute value.

.. figure:: /images/node-types_ShaderNodeTexNoise.webp
   :align: right
   :alt: Noise Texture Node.

The *Noise Texture* node evaluates a fractal Perlin noise at the input texture coordinates.
It can be used for a single Perlin noise evaluation, or for combining multiple octaves
(layers) with increasingly finer detail.


Inputs
======

The inputs are dynamic, they become available if needed depending on the node properties.

Vector
   Texture coordinate to evaluate the noise at;
   defaults to *Generated* texture coordinates if the socket is left unconnected.
W
   Texture coordinate to evaluate the noise at.
Scale
   Scale of the base noise octave.
Detail
   Number of noise octaves.
   The fractional part of the input is multiplied by the magnitude of the highest octave.
   Higher number of octaves corresponds to a higher render time.
Roughness
   Blend between a smoother noise pattern, and rougher with sharper peaks.
Lacunarity
   The difference between the scale of each two consecutive octaves.
   Larger values corresponds to larger scale for higher octaves.
Offset
   An added offset to each octave, determines the level where the highest octave will appear.
Gain
   An extra multiplier to tune the magnitude of octaves.
Distortion
   Amount of distortion.


Properties
==========

Dimensions
   The dimensions of the space to evaluate the noise in.

   :1D: Evaluate the noise in 1D space at the input *W*.
   :2D: Evaluate the noise in 2D space at the input *Vector*. The Z component is ignored.
   :3D: Evaluate the noise in 3D space at the input *Vector*.
   :4D: Evaluate the noise in 4D space at the input *Vector* and the input *W* as the fourth dimension.

   .. note::

      Higher dimensions corresponds to higher render time,
      so lower dimensions should be used unless higher dimensions are necessary.

Normalize
   If enabled, ensures that the output values stay in the range 0.0 to 1.0.
   When disabled, output values are in the range -1.0 to 1.0.


Type
   Type of Noise texture, with different ways to combine octaves.

   :FBM:
      Fractal Brownian motion, produces a homogeneous and isotropic result.
      Values from octaves are added together.
   :Multifractal:
      More uneven, varying by location similar to real terrain.
      Values from octaves are multiplied together.
   :Hybrid Multifractal:
      Creates peaks and valleys with different roughness values, like real mountains rise out of flat plains.
      Combines octaves using both addition and multiplication.
   :Ridged Multifractal:
      Creates sharp peaks. Calculates the absolute value of the noise,
      creating "canyons", and then flips the surface upside down.
   :Hetero Terrain:
      Similar to *Hybrid Multifractal* creates a heterogeneous terrain, but with the likeness of river channels.


Outputs
=======

Factor
   Value of fractal noise.
Color
   Color with different fractal noise in each component.


Examples
========

.. figure:: /images/render_shader-nodes_textures_noise_example.jpg

   Noise Texture with high detail.

.. list-table:: Different Noise types with the same parameters.

   * - .. figure:: /images/render_shader-nodes_textures_musgrave_example-type-fbm.jpg
          :width: 320px

          fBM (fractal Brownian Motion).

     - .. figure:: /images/render_shader-nodes_textures_musgrave_example-type-multifractal.jpg
          :width: 320px

          Multifractal.

   * - .. figure:: /images/render_shader-nodes_textures_musgrave_example-type-hybrid.jpg
          :width: 320px

          Hybrid Multifractal.

     - .. figure:: /images/render_shader-nodes_textures_musgrave_example-type-terrain.jpg
          :width: 320px

          Heterogeneous Terrain.

   * - .. figure:: /images/render_shader-nodes_textures_musgrave_example-type-ridged.jpg
          :width: 320px

          Ridged Multifractal.

     - ..


Notes
=====

While the noise is random in nature, it follows a certain pattern that might not evaluate to
random values in some configurations. For instance, consider the following configuration
where a grid of objects have a material that evaluates a noise texture at their locations.
One might expect the objects to have random values since they have different locations,
but this is not the case.

.. figure:: /images/render_shader-nodes_textures_noise_issue-constant-value.png

   An example configuration where the noise evaluates to a constant value.

It seems all objects have a value of 0.5. To understand why this happens, let us
look at the following plot of a 1D noise texture.

.. figure:: /images/render_shader-nodes_textures_noise_1d-noise-plot.png

   A plot of a 1D noise with zero details and zero distortion.

The horizontal line denotes a value of 0.5 and the vertical lines denotes whole numbers assuming
a noise scale of 1. As can be seen, the noise always intersects the 0.5 line at whole numbers.
Since the aforementioned objects were distributed on a grid and have whole number locations,
they all evaluate to 0.5. Which explains the issue at hand.

Generally, any discrete evaluation of noise at integer multiples of the reciprocal of
the noise scale will always evaluate to 0.5. It also follows that evaluations closer to
that will have values close to 0.5. In such cases, it is almost always preferred to use
the White Noise Texture.

Regardless, one can mitigate this issue in a number of ways:

- Adjust the scale of the noise to avoid aligning the noise with the evaluation domain.
- Add an arbitrary offset to the texture coordinates to break the alignment with the evaluation domain.
- Evaluate the noise at a higher dimension and adjust the extra dimension
  until a satisfactory result is achieved.

.. list-table::

   * - .. figure:: /images/render_shader-nodes_textures_noise_issue-constant-value.png

          Constant value issue.

     - .. figure:: /images/render_shader-nodes_textures_noise_solution1-constant-value.png

          Mitigating the issue by adjusting the scale.

   * - .. figure:: /images/render_shader-nodes_textures_noise_solution2-constant-value.png

          Mitigating the issue by adding an arbitrary offset.

     - .. figure:: /images/render_shader-nodes_textures_noise_solution3-constant-value.png

          Mitigating the issue by evaluating at a higher dimension.

Similarly, in other configurations, one might experience some banding patterns in the noise,
where there are bands of high contrast areas followed by banding of low contrast areas.
For instance, planar surfaces that are slightly tilted along one of the axis
will have such a banding pattern.

.. figure:: /images/render_shader-nodes_textures_noise_issue-banding.png

   An example configuration where the noise have a banding pattern.

This happens because the slight tilt along one of the axis causes values along
the perpendicular axis to change very slowly making the grid structure of
the noise more apparent. The easiest way to mitigate this issue to rotate
the coordinates by an arbitrary amount.

.. figure:: /images/render_shader-nodes_textures_noise_solution-banding.png

   Mitigating the issue by rotating the coordinates by an arbitrary amount.


## Voronoi

.. index:: Geometry Nodes; Voronoi Texture

********************
Voronoi Texture Node
********************

.. note::

   This node is ported from shader nodes. The manual and images are
   referencing the shader version of the node.
   This node accepts field inputs and outputs.
   When not connected the Vector input has an implicit ``position`` attribute value.

.. figure:: /images/node-types_ShaderNodeTexVoronoi.webp
   :align: right
   :alt: Voronoi Texture Node.

The *Voronoi Texture* node evaluates a `Worley Noise <https://en.wikipedia.org/wiki/Worley_noise>`__ at
the input texture coordinates.


Inputs
======

The inputs are dynamic, they become available if needed depending on the node properties.

Vector
   Texture coordinate to evaluate the noise at;
   defaults to *Generated* texture coordinates if the socket is left unconnected.
W
   Texture coordinate to evaluate the noise at.
Scale
   Scale of the noise.
Detail
   Number of noise octaves.
   The fractional part of the input is multiplied by the magnitude of the highest octave.
   Higher number of octaves corresponds to a higher evaluation time.
Roughness
   Blend between a smoother noise pattern, and rougher with sharper peaks.
Lacunarity
   The difference between the scale of each two consecutive octaves.
   Larger values corresponds to larger scale for higher octaves.
Smoothness
   The smoothness of the noise.

   .. list-table::

      * - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-distance-zero.png

             Smoothness: 0.0.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-distance-quarter.png

             Smoothness: 0.25.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-distance-half.png

             Smoothness: 0.5.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-distance-one.png

             Smoothness: 1.0.

      * - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-color-zero.png

             Smoothness: 0.0.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-color-quarter.png

             Smoothness: 0.25.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-color-half.png

             Smoothness: 0.5.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-color-one.png

             Smoothness: 1.0.

Exponent
   Exponent of the Minkowski distance metric.

   .. list-table::

      * - .. figure:: /images/render_shader-nodes_textures_voronoi_minkowski-half.png

             Exponent: 0.5.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_minkowski-one.png

             Exponent: 1.0.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_minkowski-two.png

             Exponent: 2.0.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_minkowski-32.png

             Exponent: 32.0.

Randomness
   The randomness of the noise.

   .. list-table::

      * - .. figure:: /images/render_shader-nodes_textures_voronoi_randomness-one.png

             Randomness: 1.0.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_randomness-half.png

             Randomness: 0.5.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_randomness-quarter.png

             Randomness: 0.25.

        - .. figure:: /images/render_shader-nodes_textures_voronoi_randomness-zero.png

             Randomness: 0.0.


Properties
==========

Dimensions
   The dimensions of the space to evaluate the noise in.

   :1D: Evaluate the noise in 1D space at the input W.
   :2D: Evaluate the noise in 2D space at the input Vector. The Z component is ignored.
   :3D: Evaluate the noise in 3D space at the input Vector.
   :4D: Evaluate the noise in 4D space at the input Vector and the input W as the fourth dimension.

   Higher dimensions corresponds to higher render time,
   so lower dimensions should be used unless higher dimensions are necessary.

Feature
   The Voronoi feature that the node will compute.

   :F1:
      The distance to the closest feature point as well as its position and color.

      .. list-table::

         * - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-distance-zero.png

                Distance.

           - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-color-zero.png

                Color.

           - .. figure:: /images/render_shader-nodes_textures_voronoi_f1-position.png

                Position.

   :F2:
      The distance to the second closest feature point as well as its position and color.

      .. list-table::

         * - .. figure:: /images/render_shader-nodes_textures_voronoi_f2-distance.png

                Distance.

           - .. figure:: /images/render_shader-nodes_textures_voronoi_f2-color.png

                Color.

           - .. figure:: /images/render_shader-nodes_textures_voronoi_f2-position.png

                Position.

   :Smooth F1:
      A smooth version of F1.

      .. list-table::

         * - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-distance-one.png

                Distance.

           - .. figure:: /images/render_shader-nodes_textures_voronoi_smoothness-color-one.png

                Color.

           - .. figure:: /images/render_shader-nodes_textures_voronoi_smooth-f1-position.png

                Position.

   :Distance to Edge:
      The distance to the edges of the Voronoi cells.

      .. list-table::

         * - .. figure:: /images/render_shader-nodes_textures_voronoi_distance-to-edge.png

                Distance.

           - .. figure:: /images/render_shader-nodes_textures_voronoi_distance-to-edge-less-than.png

                Distance smaller than 0.05.

   :N-Sphere Radius:
      The radius of the n-sphere inscribed in the Voronoi cells.
      In other words, it is half the distance between the closest feature point and the feature point closest to it.

      .. list-table::

         * - .. figure:: /images/render_shader-nodes_textures_voronoi_n-sphere-radius.png

                The n-sphere radius can be used to create tightly packed n-spheres.

           - .. figure:: /images/render_shader-nodes_textures_voronoi_n-sphere-radius-nodetree.png

                Node tree for the shader to the left.

Distance Metric
   The distance metric used to compute the texture.

   :Euclidean:
      Use the `Euclidean distance metric <https://en.wikipedia.org/wiki/Euclidean_distance>`__.
   :Manhattan:
      Use the `Manhattan distance metric <https://en.wikipedia.org/wiki/Taxicab_geometry>`__.
   :Chebychev:
      Use the `Chebychev distance metric <https://en.wikipedia.org/wiki/Chebyshev_distance>`__.
   :Minkowski:
      Use the `Minkowski distance metric <https://en.wikipedia.org/wiki/Minkowski_distance>`__.
      The Minkowski distance is a generalization of the aforementioned metrics with an *Exponent* as a parameter.
      Minkowski with an exponent of one is equivalent to the *Manhattan* distance metric.
      Minkowski with an exponent of two is equivalent to the *Euclidean* distance metric.
      Minkowski with an infinite exponent is equivalent to the *Chebychev* distance metric.

   .. list-table::

      * - .. figure:: /images/render_shader-nodes_textures_voronoi_minkowski-half.png

             Minkowski Exponent: 0.5 (Minkowski 1/2).

        - .. figure:: /images/render_shader-nodes_textures_voronoi_minkowski-one.png

             Minkowski Exponent: 1.0 (Manhattan).

        - .. figure:: /images/render_shader-nodes_textures_voronoi_minkowski-two.png

             Minkowski Exponent: 2.0 (Euclidean).

        - .. figure:: /images/render_shader-nodes_textures_voronoi_minkowski-32.png

             Minkowski Exponent: 32.0 (approximation of Chebychev).

Normalize
   If enabled, ensures that the output values stay in the range 0.0 to 1.0.
   In rare cases, the output value may be outside that range when *Feature* is *F2*.


Outputs
=======

Distance
   Distance.
Color
   Cell color. The color is arbitrary.
Position
   Position of feature point.
W
   Position of feature point.
Radius
   N-Sphere radius.


Notes
=====

In some configurations of the node, especially for low values of *Randomness*,
rendering artifacts may occur. This happens due to the same reasons described
in the :ref:`Notes section <shader-white-noise-notes>` in the White Noise Texture page
and can be fixed in a similar manner as described there.


Examples
========

.. figure:: /images/render_shader-nodes_textures_voronoi_example-beveled-cells.png

   The difference between *F1* and *Smooth F1* can be used to create beveled Voronoi cells.

.. figure:: /images/render_shader-nodes_textures_voronoi_example-hammered-metal.jpg

   Creating a hammered metal shader using the *Voronoi Texture* node.


## Wave

.. index:: Geometry Nodes; Wave Texture

*****************
Wave Texture Node
*****************

.. note::

   This node is ported from shader nodes. The manual and images are
   referencing the shader version of the node.
   This node accepts field inputs and outputs.
   When not connected the Vector input has an implicit ``position`` attribute value.

.. figure:: /images/node-types_ShaderNodeTexWave.webp
   :align: right
   :alt: Wave Texture Node.

The *Wave Texture* node adds procedural bands or rings with noise distortion.

.. hint::

   In general, textures can be distorted by mixing their texture coordinates with another texture.
   The distortion built into the *Wave Texture Node* uses the *Color* output of the
   :doc:`Noise Texture Node </render/shader_nodes/textures/noise>`.

   To replicate this, center its value range around zero, multiply it by a factor proportional to
   *Distortion*/*Scale* and add the result onto the texture coordinates.
   *Detail*, *Detail Scale* and *Roughness* of the *Wave Texture Node* correspond to the inputs on the
   :doc:`Noise Texture Node </render/shader_nodes/textures/noise>`.


Inputs
======

Vector
   Texture coordinate to sample texture at;
   defaults to Generated texture coordinates if the socket is left unconnected.
Scale
   Overall texture scale.
Distortion
   Amount of distortion of the wave.

   .. hint::

      In general, textures can be distorted by mixing their texture coordinates with another texture.
      The distortion built into the *Wave Texture Node* uses the *Color* output of the
      :doc:`Noise Texture Node </render/shader_nodes/textures/noise>`.

      To replicate this, center its value range around zero, multiply it by a factor proportional to
      *Distortion*/*Scale* and add the result onto the texture coordinates.
      *Detail*, *Detail Scale*, and *Roughness* of the *Wave Texture Node* correspond to the inputs on the
      :doc:`Noise Texture Node </render/shader_nodes/textures/noise>`.
Detail
   Amount of distortion noise detail.
Detail Scale
   Scale of distortion noise.
Roughness
   Blend between a smoother noise pattern, and rougher with sharper peaks.
Phase Offset
   Position of the wave along the *Bands Direction*.
   This can be used as an input for more control over the distortion.


Properties
==========

Type
   *Bands* or *Rings* shaped waves.
Bands/Rings Direction
   The axis the bands or rings propagate from i.e. which axis they are perpendicular to.
   When using *Bands* a *Diagonal* axis is an option and when using *Rings* the rings
   can propagate outwards from a single point by using *Spherical* direction.
Wave Profile
   Controls the look of the wave type.

   :Saw: Uses a sawtooth profile.
   :Sine: Uses the standard sine profile.


Outputs
=======

Color
   Texture color output.
Factor
   Texture intensity output.


Examples
========

.. figure:: /images/render_shader-nodes_textures_wave_example.png

   Wave Texture.


## White Noise

.. index:: Geometry Nodes; White Noise Texture

************************
White Noise Texture Node
************************

.. note::

   This node is ported from shader nodes. The manual and images are
   referencing the shader version of the node.
   This node accepts field inputs and outputs.
   When not connected the Vector input has an implicit ``position`` attribute value.

The *White Noise Texture* node returns a random number based on an input :term:`Seed`.
The seed can be a number, a 2D vector, a 3D vector, or a 4D vector; depending on the *Dimensions* property.
The output number ranges between zero and one.

.. figure:: /images/node-types_ShaderNodeTexWhiteNoise.webp
   :align: right
   :alt: White Noise Texture Node.


Inputs
======

The inputs are dynamic, they become available if needed depending on the node properties.

Vector
   Vector used as seed in 2D, 3D, and 4D dimensions.
W
   Value used as seed in 1D and 4D dimensions.


Properties
==========

Dimensions
   The dimensions of the space to evaluate the noise in.

   :1D: The *W* input is used as seed.
   :2D: The X and Y components of the *Vector* input are used as seed.
   :3D: The *Vector* input is used as seed.
   :4D: Both the *Vector* input and the *W* input are used as seed.


Outputs
=======

Value
   Output random value.
Color
   Output random color.


Notes
=====

The slightest difference in seed values would result in completely different outputs.
Consequently, bad precision may have significant impact on the output.
Usually, we can mitigate this issue by:

- Eliminating the problematic seed value. If the problematic seed value is constant,
  it should be eliminated by choosing a lower dimension or multiplying it by zero.
- Adding an arbitrary value to the seed. The issue might only happen at certain boundaries,
  like unit boundaries, so simply adding an arbitrary value might solve the issue.
- Taking the absolute value of the seed. In computing, zero may be positive or negative,
  so taking the absolute values unifies the zero into a single value.

.. list-table::

   * - .. figure:: /images/render_shader-nodes_textures_white-noise_issue.png

          Precision issue due to signed zeros on the Z axis.

     - .. figure:: /images/render_shader-nodes_textures_white-noise_solution1.png

          Mitigating the issue by eliminating the Z axis.

   * - .. figure:: /images/render_shader-nodes_textures_white-noise_solution2.png

          Mitigating the issue by adding an arbitrary value.

     - .. figure:: /images/render_shader-nodes_textures_white-noise_solution3.png

          Mitigating the issue by taking the absolute value.


Examples
========

.. figure:: /images/render_shader-nodes_textures_white-noise_solution1.png

   Generating cell noise using the *Snap* vector operation and the *White Noise* node.


## Index


###################
  Utilities Nodes
###################

General purpose nodes for modifying data.

.. toctree::
   :maxdepth: 2

   Color <color/index.rst>
   Text <text/index.rst>
   Vector <vector/index.rst>

-----

.. toctree::
   :maxdepth: 2

   Field <field/index.rst>
   Math <math/index.rst>
   Rotation <rotation/index.rst>

-----

.. toctree::
   :maxdepth: 1

   index_switch.rst
   menu_switch.rst
   random_value.rst
   repeat_zone.rst
   switch.rst


## Index Switch

.. index:: Geometry Nodes; Index Switch
.. _bpy.types.GeometryNodeIndexSwitch:

*****************
Index Switch Node
*****************

.. figure:: /images/node-types_GeometryNodeIndexSwitch.webp
   :align: right
   :alt: Index Switch Node.


The *Index Switch* node outputs one of its inputs depending on an index value.
Only the input that is passed through the node is computed.

.. seealso::

   The :doc:`/modeling/geometry_nodes/utilities/menu_switch` is similar but it exposes the choices as a menu.


Inputs
======

Index
   Determines which of the input options below will be passed through.

Item Inputs
   One input is created for every menu entry. The input is used when the
   matching option is selected.


Properties
==========

Type
   Determines the type of the data that is handled by the node.


Outputs
=======

Output
   One of the inputs without any modifications.


## Menu Switch

.. index:: Geometry Nodes; Menu Switch
.. _bpy.types.GeometryNodeMenuSwitch:

****************
Menu Switch Node
****************

.. figure:: /images/node-types_GeometryNodeMenuSwitch.webp
   :align: right
   :alt: Menu Switch Node.

The *Menu Switch* node outputs one of its inputs depending on a menu
selection. Only the input that is passed through the node is computed.

The available menu entries are defined by the user. Menu items can be
added and removed, as well as renamed and reordered in the editor side
bar. Renaming a menu entry keeps existing links of the matching input
socket.

The menu can be used in node groups and the nodes modifier UI.
Connecting the menu input with a *Group Input* node will expose the menu
as a group input. A menu socket in a node group, reroute node, or other
pass-through nodes needs to be connected to a *Menu Switch* node in
order to work. An unconnected menu socket will show an empty menu by
default.

Connecting multiple *Menu Switch* nodes to the same output
socket creates a conflict (even when the menu entries are the same).
To avoid this a menu switch can be wrapped in a node group. Multiple
node groups of the same type can be connected to the same menu, since
they contain the same menu switch node.

.. list-table::

   * - .. figure:: /images/node-types_GeometryNodeMenuSwitch_conflict.webp

          Conflict caused by connecting different menus.

     - .. figure:: /images/node-types_GeometryNodeMenuSwitch_group_wrapper.webp

          Same node group can be connected without conflict.


.. seealso::

   The :doc:`/modeling/geometry_nodes/utilities/index_switch`
   is similar but it exposes the choices as an integer index.


Inputs
======

Menu
   Determines which of the input options below will be passed through.

Item Inputs
   One input is created for every menu entry. The input is used when the
   matching option is selected.


Properties
==========

Type
   Determines the type of the data that is handled by the node.


Outputs
=======

Output
   One of the inputs without any modifications.


## Random Value

.. index:: Geometry Nodes; Random Value
.. _bpy.types.FunctionNodeRandomValue:

*****************
Random Value Node
*****************

.. figure:: /images/node-types_FunctionNodeRandomValue.webp
   :align: right
   :alt: Random Value node.

The *Random Value* node outputs a white noise like value as a *Float*, *Integer*, *Vector*, or *Boolean* field.


Inputs
======

Min
   The minimum value of the range where random values are sampled from.
   This input is only available for *Float*, *Integer*, and *Vector* types.

Max
   The maximum value of the range where random values are sampled from.
   This input is only available for *Float*, *Integer*, and *Vector* types.

Probability
   The probability ratio for the random *Boolean* output to be *True*.
   This input is only available for *Boolean* types.

ID
   An ID to drive the random number generator seed. By default, this input uses the same value
   as of the :doc:`/modeling/geometry_nodes/geometry/read/id`, which is the ``id`` attribute of the context
   geometry if it exists, and otherwise the :doc:`index </modeling/geometry_nodes/geometry/read/input_index>`.

   .. tip:: Single Random Value

      By default, the random value node generates a value for each unique index.
      If a single random value is desired, connect a single value
      (such as an :doc:`/modeling/geometry_nodes/input/constant/integer` ) to the ID input.

Seed
   A field to :term:`Seed` the random number generator. This can be used to generate
   a different set of random values, even for two nodes with the same *ID* input.


Properties
==========

Data Type
   :Float: The output will be a *Float* field.
   :Integer: The output will be an *Integer* field.
   :Vector: The output will be a *Vector* field.
   :Boolean: The output will be a *Boolean* field.


Outputs
=======

Value
   Random values as a field.


## Repeat Zone

.. index:: Geometry Nodes; Repeat Zone
.. _bpy.types.GeometryNodeRepeatInput:
.. _bpy.types.GeometryNodeRepeatOutput:

***********
Repeat Zone
***********

Repeat zones allow running nodes many times in a loop. Compared with simply duplicating
a node, they support executing a node an arbitrary number of times, possibly determined
when the node group is evaluated. For example, the nodes could be repeated based on the
number of stories in a building generator.

.. figure:: /images/modeling_geometry-nodes_repeat_zone.png
   :align: center

   Repeat zone used to repeat a node group a few times

When adding a repeat zone, two nodes are added, with the "zone" defined between them.
The inputs connected to the *Repeat Input* node are read at the beginning, before starting
the repetitions. Then they are passed to the inside of the zone where they can be changed,
and passed to the next iteration. This process is repeated the specified number of times.

Other nodes can be connected as inputs to the inside of the repeat zone from the outside.
Those are constant throughout every iteration based on their value at the current frame.
However, outputs of the zone must be connected through the *Repeat Output* node.


Inputs
======

Iterations
   Number of repetitions.


Properties
==========

Inspection Index
   Iteration number that is used by inspection features like the :doc:`/modeling/geometry_nodes/output/viewer`
   or :doc:`socket inspection </modeling/geometry_nodes/inspection>`.


## Switch

.. index:: Geometry Nodes; Switch
.. _bpy.types.GeometryNodeSwitch:

***********
Switch Node
***********

.. figure:: /images/node-types_GeometryNodeSwitch.webp
   :align: right
   :alt: Switch Node.

The *Switch* node outputs one of two inputs depending on a condition.
Only the input that is passed through the node is computed.

.. seealso::

   The :doc:`/modeling/geometry_nodes/utilities/menu_switch`
   and :doc:`/modeling/geometry_nodes/utilities/index_switch`
   can be used to switch between an arbitrary amount of inputs.


Inputs
======

Switch
   Determines which of the two inputs below will be passed through.

False
   Is passed through when the switch is set to false.

True
   Is passed through when the switch is set to true.


Properties
==========

Type
   Determines the type of the data that is handled by the node.


Outputs
=======

Output
   One of the two inputs without any modifications.


## Blackbody

.. index:: Geometry Nodes; Blackbody
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /render/shader_nodes/converter/blackbody.rst
   :start-after: .. --- copy below this line ---


## Color Ramp

.. index:: Geometry Nodes; Color Ramp
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below (for Cycles).
.. include:: /compositing/types/color/color_ramp.rst
   :start-after: .. --- copy below this line ---


## Combine Color

.. _bpy.types.FunctionNodeCombineColor:
.. index:: Geometry Nodes; Combine Color
.. --- copy below this line ---

******************
Combine Color Node
******************

.. figure:: /images/node-types_FunctionNodeCombineColor.webp
   :align: right
   :alt: Combine Color Node.

Combines four grayscale channels into one color image,
based on a particular :term:`Color Model`.


Inputs
======

The inputs of this node depend on the Mode property (see below).

Alpha
   The opacity of the output color.


Properties
==========

Mode
   The color model to use.

   :RGB: Red, Green, Blue.
   :HSV: Hue, Saturation, Value.
   :HSL: Hue, Saturation, Lightness.


Output
======

Color
   Standard color output.


## Index


#######################
  Color Utility Nodes
#######################

Nodes for modifying color data passed through color sockets.

.. toctree::
   :maxdepth: 1

   blackbody.rst
   color_ramp.rst
   combine_color.rst
   mix_rgb.rst
   rgb_curves.rst
   separate_color.rst


## Mix Rgb

.. index:: Geometry Nodes; Mix RGB
.. _bpy.types.ShaderNodeMixRGB:
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /compositing/types/color/mix/mix_color.rst
   :start-after: .. --- copy below this line ---


## Rgb Curves

.. index:: Geometry Nodes; RGB Curves
.. _bpy.types.ShaderNodeRGBCurve:
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /compositing/types/color/adjust/rgb_curves.rst
   :start-after: .. --- copy below this line ---


## Separate Color

.. _bpy.types.FunctionNodeSeparateColor:
.. index:: Geometry Nodes; Separate Color
.. --- copy below this line ---

*******************
Separate Color Node
*******************

.. figure:: /images/node-types_FunctionNodeSeparateColor.webp
   :align: right
   :alt: Separate Color Node.

Splits an image into its channels,
based on a particular :term:`Color Model`.


Inputs
======

Color
   Standard color input.


Properties
==========

Mode
   The color model to output.

   :RGB: Red, Green, Blue.
   :HSV: Hue, Saturation, Value.
   :HSL: Hue, Saturation, Lightness.


Outputs
=======

The outputs of this node depend on the Mode property (see above).

Alpha
   The opacity value.


## Accumulate Field

.. index:: Geometry Nodes; Accumulate Field
.. _bpy.types.GeometryNodeAccumulateField:

*********************
Accumulate Field Node
*********************

.. figure:: /images/node-types_GeometryNodeAccumulateField.webp
   :align: right
   :alt: Accumulate Field Node.

The *Accumulate Field* node counts a running total of its input values, in the order defined
by the geometry's :doc:`indices </modeling/geometry_nodes/geometry/read/input_index>`. The node's essential
operation is just addition, but instead of only outputting the final total, it outputs the current
value at every element.


Inputs
======

Value
   The values to be accumulated.

   .. warning::

      When accumulating integer values, be careful to make sure that there are not
      too many large values. The maximum integer that Blender stores internally is
      around 2 billion. After that, values may wrap around and become negative.
      See `wikipedia <https://en.wikipedia.org/wiki/Integer_%28computer_science%29>`__
      for more information.

Group Index
   An index used to group values together for multiple separate accumulations.
   This can be thought of as a choice of the "bin" in which to place each value.
   This input has no effect when it is only a single value.


Properties
==========

Data Type
   :Float: The node will accumulate a *Float* field.
   :Integer: The node will accumulate an *Integer* field.
   :Vector: The node will accumulate a *Vector* field.

Domain
   The :ref:`attribute domain <attribute-domains>` used for accumulation
   and for evaluation of the *Value* input.


Output
======

Leading
   The running total of values in the corresponding group, starting at the first value.

Trailing
   The running total of values in the corresponding group, starting at zero.

Total
   The total of all of the values in the corresponding group


Examples
========

Table
-----

+-------+-------------+---------+----------+-------+
| Value | Group Index | Leading | Trailing | Total |
+=======+=============+=========+==========+=======+
|   1   |      7      |    1    |     0    |   6   |
+-------+-------------+---------+----------+-------+
|   3   |      7      |    4    |     1    |   6   |
+-------+-------------+---------+----------+-------+
|   2   |      7      |    6    |     4    |   6   |
+-------+-------------+---------+----------+-------+
|   1   |      3      |    1    |     0    |   3   |
+-------+-------------+---------+----------+-------+
|   0   |      3      |    1    |     1    |   3   |
+-------+-------------+---------+----------+-------+
|   2   |      3      |    3    |     1    |   3   |
+-------+-------------+---------+----------+-------+

A few examples of input values and the node's results. One important take-away from this table
is that the specific values for the *Group Input* does not matter; it only matters that the
values are shared between elements.

Stacking Boxes
--------------

.. figure:: /images/modeling_geometry-nodes_utilities_accumulate-field_box-stack.png
   :align: center

Here, the node is used in combination with the :doc:`/modeling/geometry_nodes/utilities/random_value`
to create a stack of randomly scaled boxes. The *Group Index* input is not used, because all boxes
are meant to be in the same stack.

.. figure:: /images/modeling_geometry-nodes_utilities_accumulate-field_box-stack-2.png
   :align: center

A slightly more complicated version of the previous example,
using the *Group Index* input to create three separate stacks.


## Evaluate At Index

.. index:: Geometry Nodes; Evaluate at Index
.. _bpy.types.GeometryNodeFieldAtIndex:

**********************
Evaluate at Index Node
**********************

.. figure:: /images/node-types_GeometryNodeFieldAtIndex.webp
   :align: right
   :alt: Evaluate at Index Node.

The *Evaluate at Index* node allows accessing data of other elements in the context geometry.
It is similar to the :doc:`/modeling/geometry_nodes/geometry/sample/sample_index`.
The main difference is that this node does not require a geometry input, because the geometry
from the :ref:`field context <field-context>` is used.

This node is also similar to the :doc:`/modeling/geometry_nodes/utilities/field/evaluate_on_domain` node,
except that the value to retrieve from the specified domain is specified by an index rather than
an automatic domain interpolation.


Inputs
======

Index
   The :doc:`index </modeling/geometry_nodes/geometry/read/input_index>` of the element in the selected domain
   to retrieve data from, i.e. "the fourth face", or "the first control point".

Value
   The field to retrieve data from.


Properties
==========

Domain
   The :ref:`attribute domain <attribute-domains>` used for evaluation of the *Value* input.
   This is useful because it can be a different domain than the domain from the
   :ref:`field context <field-context>`, i.e. to choose a vertex for each face.


Output
======

Value
   The value of the input field at the given index.


## Evaluate On Domain

.. index:: Geometry Nodes; Evaluate on Domain
.. _bpy.types.GeometryNodeFieldOnDomain:

***********************
Evaluate on Domain Node
***********************

.. figure:: /images/node-types_GeometryNodeFieldOnDomain.webp
   :align: right
   :alt: Evaluate on Domain Node.

The *Evaluate on Domain* allows evaluating a field for a different :ref:`attribute domain <attribute-domains>`
than the domain from the :ref:`field context <field-context>`. For example, the face index could be used instead
of the face corner index, when setting the values of a :term:`UV Map`

.. note::

   This node is not necessary to retrieve data from other attribute domains; that is done automatically.
   Its utility comes from the fact that it's possible to control *when* the domain interpolation happens.
   Normally, input nodes interpolate their data to the current context's domain as soon as they create
   their output.

.. tip::

   It may be preferable to use this node over the :doc:`/modeling/geometry_nodes/attribute/capture_attribute`,
   since it allows using a specific attribute domain without requiring a geometry socket input,
   which allows creating more reusable node groups.

.. seealso::

   The method of retrieving data from another domain is somewhat similar to the
   :doc:`/modeling/geometry_nodes/utilities/field/evaluate_at_index`.


Inputs
======

Value
   The field to evaluate on the chosen attribute domain.


Properties
==========

Domain
   The :ref:`attribute domain <attribute-domains>` used for evaluation of the *Value* input.


Output
======

Value
   The values from the input, evaluated on the chosen domain, then interpolated to the domain from
   the :ref:`field context <field-context>`.


## Index


#######################
  Field Utility Nodes
#######################

.. toctree::
   :maxdepth: 1

   accumulate_field.rst
   evaluate_at_index.rst
   evaluate_on_domain.rst


## Boolean Math

.. index:: Geometry Nodes; Boolean Math
.. _bpy.types.FunctionNodeBooleanMath:

*****************
Boolean Math Node
*****************

.. figure:: /images/node-types_FunctionNodeBooleanMath.webp
   :align: right
   :alt: Boolean Math Node.

The *Boolean Math* node performs a basic logical operation on its inputs.


Inputs
======

Boolean
   Two standard Boolean inputs.


Properties
==========

Mode
   :And:
      True when both inputs are true.
      (`AND <https://en.wikipedia.org/wiki/AND_gate>`__)
   :Or:
      True when at least one input is true.
      (`OR <https://en.wikipedia.org/wiki/OR_gate>`__)
   :Not:
      Opposite of the input.
      (`NOT <https://en.wikipedia.org/wiki/NOT_gate>`__)
   :Not And:
      (True when at least one input is false.
      `NAND <https://en.wikipedia.org/wiki/NAND_gate>`__)
   :Nor:
      True when both inputs are false.
      (`NOR <https://en.wikipedia.org/wiki/NOR_gate>`__)
   :Equal:
      True when both inputs are equal. Also known as "exclusive nor".
      (`XNOR <https://en.wikipedia.org/wiki/XNOR_gate>`__)
   :Not Equal:
      (`XOR <https://en.wikipedia.org/wiki/XOR_gate>`__)
      True when both inputs are different. Also known as "exclusive or".
   :Imply:
      True unless the first input is true and the second is false.
      (`IMPLY <https://en.wikipedia.org/wiki/IMPLY_gate>`__)
   :Subtract:
      True when the first input is true and the second is false. Also known as ""not imply".
      (`NIMPLY <https://en.wikipedia.org/wiki/NIMPLY_gate>`__)


Output
======

Boolean
   Standard Boolean output.


## Clamp

.. index:: Geometry Nodes; Clamp
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /render/shader_nodes/converter/clamp.rst
   :start-after: .. --- copy below this line ---


## Compare

.. index:: Geometry Nodes; Compare
.. _bpy.types.FunctionNodeCompare:

************
Compare Node
************

.. figure:: /images/node-types_FunctionNodeCompare.webp
   :align: center
   :alt: Compare Node.

The *Compare* node takes two inputs and does an operation to determine whether they are similar.
The node can work on all generic data types, and has modes for vectors that contain more complex
comparisons, which can help to reduce the number of necessary nodes, and make a node tree more readable.


Inputs
======

A, B
   Standard value inputs of the selected type.
C
   Compared against the dot product of two input vectors in when the *Mode* property is set to *Dot Product*.
Epsilon
   This value is used as a threshold for still considering the two inputs as equal
   for the Equal and Not Equal operations.


Properties
==========

Mode
   :Element-Wise:
      Compare each axis of the input vectors separately, and output true only when the result is true
      for each axis.
   :Length:
      Compare the length of the two input vectors.
   :Average:
      Compare the average of the elements of the input vectors. This is the same as the implicit
      conversion used when setting the node's data type to *Float*.
   :Dot Product:
      Compare the dot product of the two vectors with the separate *C* input, using the selected operation.
      The dot product outputs a single value that says how much the two vectors "agree".
   :Direction:
      Compare the angle between the two vectors with the separate *Angle* input, using the selected operation.
      The vectors are normalized, so their length does not matter.

Operation
   :Less Than:
      True when the first input is smaller than second input.
   :Less Than or Equal:
      True when the first input is smaller than the second input or equal.
   :Greater Than:
      True when the first input is greater than the second input.
   :Greater Than or Equal:
      True when the first input is greater than the second input or equal.
   :Equal:
      True when both the difference between the two inputs is smaller than the *Epsilon* input.
   :Not Equal:
      True when both the difference between the two inputs is larger than the *Epsilon* input.
   :Brighter:
      True when the first color input is brighter than the second.
   :Darker:
      True when the first color input is darker than the second.


Output
======

Result
   Standard Boolean output.


Examples
========

.. figure:: /images/modeling_geometry-nodes_utilities_compare_direction.png
   :align: center

Here, the compare node is used with the *Direction* mode to compare the direction of the
sphere's :doc:`face normals </modeling/geometry_nodes/geometry/read/normal>` to the "direction"
of the cube object's location. Anywhere that the directions are less than 32.9 degrees apart,
the faces will be selected, and deleted.


## Float Curve

.. index:: Geometry Nodes; Float Curve

.. include:: /render/shader_nodes/converter/float_curve.rst
   :start-after: .. --- copy below this line ---


## Float To Integer

.. index:: Geometry Nodes; Float To Integer
.. _bpy.types.FunctionNodeFloatToInt:

*********************
Float To Integer Node
*********************

.. figure:: /images/node-types_FunctionNodeFloatToInt.webp
   :align: right
   :alt: Float To Integer Node.

The *Float To Integer* node takes a single floating point number input and converts it to
an integer with a choice of methods.


Inputs
======

Float
   Standard float value input.


Properties
==========

Rounding Mode
   :Round: Outputs the closest integer to Float, rounding either up or down based on the value.
   :Floor: Outputs the closest integer less than Float, always rounding down.
   :Ceiling: Outputs the closest integer greater than Float, always rounding up.
   :Truncate: Outputs the closest integer between Float and zero. For positive numbers, acts like Floor.
              For negative numbers, acts as Ceiling.


Output
======

Result
   Standard integer output.


Examples
========

+--------------+---------+---------+-----------+------------+
| Input Value  |  Round  |  Floor  |  Ceiling  |  Truncate  |
+==============+=========+=========+===========+============+
|  -69.6574    |   -70   |   -70   |    -69    |    -69     |
+--------------+---------+---------+-----------+------------+
|   -3.14159   |   -3    |   -4    |    -3     |    -3      |
+--------------+---------+---------+-----------+------------+
|   -1.5       |   -2    |   -2    |    -1     |    -1      |
+--------------+---------+---------+-----------+------------+
+--------------+---------+---------+-----------+------------+
|    1.5       |    2    |    1    |     2     |     1      |
+--------------+---------+---------+-----------+------------+
|    3.14159   |    3    |    3    |     4     |     3      |
+--------------+---------+---------+-----------+------------+
|   69.6574    |    70   |    69   |     70    |     69     |
+--------------+---------+---------+-----------+------------+


## Index


######################
  Math Utility Nodes
######################

.. toctree::
   :maxdepth: 1

   boolean_math.rst
   clamp.rst
   compare.rst
   float_curve.rst
   float_to_integer.rst
   map_range.rst
   math.rst
   mix.rst


## Map Range

.. index:: Geometry Nodes; Map Range
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /render/shader_nodes/converter/map_range.rst
   :start-after: .. --- copy below this line ---


## Math

.. index:: Geometry Nodes; Math
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /compositing/types/utilities/math.rst
   :start-after: .. --- copy below this line ---


## Mix

.. index:: Geometry Nodes; Mix
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /render/shader_nodes/converter/mix.rst
   :start-after: .. --- copy below this line ---


## Align Euler To Vector

.. index:: Geometry Nodes; Align Euler to Vector
.. _bpy.types.FunctionNodeAlignEulerToVector:

**************************
Align Euler to Vector Node
**************************

.. figure:: /images/node-types_FunctionNodeAlignEulerToVector.webp
   :align: center
   :alt: Align Euler to Vector node.

The *Align Euler to Vector* node rotates an Euler rotation into the given direction.


Inputs
======

Rotation
   The :term:`Euler` rotation to align.

   .. important::

      This input has to be a rotation input. Be careful not to connect a direction vector
      like the :doc:`normal </modeling/geometry_nodes/geometry/read/normal>`.

Factor
   Determines how much the points are rotated towards the vector.
   Zero effectively disables the node and one means that the points are aligned with the vector perfectly.

Vector
   The direction vector that points should be rotated to.
   The vector is in the local space of the object that is being modified.
   When it is all zeros for a point, it is not rotated at all.


Properties
==========

Axis
   Local axis of the object that is to be rotated towards the vector input.

Pivot
   The local axis to rotate around.

   :Auto:
      The best rotation angle is computed automatically.
      This minimizes the angle of rotation.
   :X, Y, Z:
      Rotate around a specific local axis.


Outputs
=======

Rotation
   The rotated Euler rotation.


## Axis Angle To Rotation

.. index:: Geometry Nodes; Axis Angle to Rotation
.. _bpy.types.FunctionNodeAxisAngleToRotation:

***************************
Axis Angle to Rotation Node
***************************

.. figure:: /images/node-types_FunctionNodeAxisAngleToRotation.webp
    :align: right
    :alt: Axis Angle to Rotation node.

The *Axis Angle to Rotation* node converts a :ref:`axis angle <axis angle mode>` rotation to a standard rotation
value.

Inputs
======

Axis
    Unit vector representing the axis to rotate around.

Angle
    The rotation angle around the axis.


Outputs
=======

Rotation
    Standard rotation value.


## Euler To Rotation

.. index:: Geometry Nodes; Euler to Rotation
.. _bpy.types.FunctionNodeEulerToRotation:

**********************
Euler to Rotation Node
**********************

.. figure:: /images/node-types_FunctionNodeEulerToRotation.webp
   :align: right
   :alt: Euler to Rotation node.

The *Euler to Rotation* node creates a rotation value from an Euler rotation.

Inputs
======

Euler
    The :term:`Euler` rotation.


Outputs
=======

Rotation
    Standard rotation value.


## Index


##########################
  Rotation Utility Nodes
##########################

.. toctree::
   :maxdepth: 1

   align_euler_to_vector.rst
   rotate_rotation.rst
   rotate_vector.rst
   axis_angle_to_rotation.rst
   euler_to_rotation.rst
   rotation_to_euler.rst
   rotation_to_quaternion.rst
   quaternion_to_rotation.rst
   invert_rotation.rst


## Invert Rotation

.. index:: Geometry Nodes; Invert Rotation
.. _bpy.types.FunctionNodeInvertRotation:

********************
Invert Rotation Node
********************

.. figure:: /images/node-types_FunctionNodeInvertRotation.webp
   :align: right
   :alt: Invert Rotation node.

The *Invert Rotation* node inverts a rotation.

Inputs
======

Rotation
    Standard rotation value.

Outputs
=======

Rotation
    The inverted rotation.


## Quaternion To Rotation

.. index:: Geometry Nodes; Quaternion to Rotation
.. _bpy.types.FunctionNodeQuaternionToRotation:

***************************
Quaternion to Rotation Node
***************************

.. figure:: /images/node-types_FunctionNodeQuaternionToRotation.webp
   :align: right
   :alt: Quaternion to Rotation node.

The *Quaternion to Rotation* node converts a :ref:`quaternion rotation <quaternion mode>` to  a standard rotation.

Inputs
======

W
    The W value of the quaternion.
X
    The X value of the quaternion.
Y
    The Y value of the quaternion.
Z
    The Z value of the quaternion.


Outputs
=======

Rotation
    Standard rotation value.


## Rotate Rotation

.. index:: Geometry Nodes; Rotate Rotation
.. _bpy.types.FunctionNodeRotateRotation:

********************
Rotate Rotation Node
********************

.. figure:: /images/node-types_FunctionNodeRotateRotation.webp
   :align: right
   :alt: Rotate Euler node.

The *Rotate Rotate Rotation* node applies an additional rotation amount to a rotation value.

To rotate a :term:`Euler Rotation`, first use the :doc:`/modeling/geometry_nodes/utilities/rotation/euler_to_rotation`


Inputs
======

Rotation
   The rotation to rotate.

Rotate By
   Specifies how much a rotation is rotated.


Properties
==========

Space
   Base orientation for the rotation.

   :Global: Rotate a rotation in :term:`Global Space`.
   :Local: Rotate a rotation in :term:`Local Space`.


Outputs
=======

Rotation
   The rotated rotation.


## Rotate Vector

.. index:: Geometry Nodes; Rotate Vector
.. _bpy.types.FunctionNodeRotateVector:

******************
Rotate Vector Node
******************

.. figure:: /images/node-types_FunctionNodeRotateVector.webp
   :align: right
   :alt: Rotate Vector node.

The *Rotate Vector* node rotates a vector by a given rotation value.

Inputs
======

Vector
    The vector to rotate.

Rotation
    Standard rotation value.

Outputs
=======

Vector
    The rotated vector.


## Rotation To Euler

.. index:: Geometry Nodes; Roation to Euler
.. _bpy.types.FunctionNodeRotationToEuler:

**********************
Rotation to Euler Node
**********************

.. figure:: /images/node-types_FunctionNodeRotationToEuler.webp
   :align: right
   :alt: Rotation to Euler node.

The *Rotation to Euler* node converts a standard rotation socket value to an Euler rotation.

Inputs
======

Rotation
    Standard rotation socket value.


Outputs
=======

Euler
    The :term:`Euler` rotation.


## Rotation To Quaternion

.. index:: Geometry Nodes; Rotation to Quaternion
.. _bpy.types.FunctionNodeRotationToQuaternion:

***************************
Rotation to Quaternion Node
***************************

.. figure:: /images/node-types_FunctionNodeRotationToQuaternion.webp
   :align: right
   :alt: Rotation to Quaternion node.

The *Rotation to Quaternion* node converts a standard rotation socket value to a
:ref:`quaternion rotation <quaternion mode>` rotation.

Inputs
======

Rotation
    Standard rotation socket value.


Outputs
=======

W
    The W value of the quaternion.
X
    The X value of the quaternion.
Y
    The Y value of the quaternion.
Z
    The Z value of the quaternion.


## Index


######################
  Text Utility Nodes
######################

Nodes to manipulate strings.

.. toctree::
   :maxdepth: 1

   join_strings.rst
   replace_string.rst
   slice_string.rst
   special_characters.rst
   string_length.rst
   string_to_curves.rst
   value_to_string.rst


## Join Strings

.. index:: Geometry Nodes; Join Strings
.. _bpy.types.GeometryNodeStringJoin:

*****************
Join Strings Node
*****************

.. figure:: /images/node-types_GeometryNodeStringJoin.webp
   :align: center
   :alt: Join Strings node.

The *Join Strings* node combines any number of input strings into the output string.
The order of the result depends on the vertical ordering of the inputs in the multi-input socket.

.. tip::

   This node can be used to create a multi-line string for
   the :doc:`/modeling/geometry_nodes/utilities/text/string_to_curves`,
   when combined with the line break output from
   the :doc:`/modeling/geometry_nodes/utilities/text/special_characters`.


Inputs
======

Delimiter
   String value to place between each concatenated string.

Strings
   Multiple string values to be combined in connection order.


Properties
==========

This node has no properties.


Outputs
=======

String
   String result of the concatenation.


## Replace String

.. index:: Geometry Nodes; Replace String
.. _bpy.types.FunctionNodeReplaceString:

*******************
Replace String Node
*******************

.. figure:: /images/node-types_FunctionNodeReplaceString.webp
   :align: right
   :alt: Replace String node.

The *Replace String* node replaces a string segment with another.


Inputs
======

String
   Standard string input.

Find
   The substring to find in *String* to be replaced.

Replace
   A string segment which replaces occurrences of the *Find* substring.


Properties
==========

This node has no properties.


Outputs
=======

String
   Standard string output.


Examples
========

.. figure:: /images/modeling_geometry-nodes_text_replace-string_example.png
   :align: center

   Using the node to add the newline character to a string.


## Slice String

.. index:: Geometry Nodes; Slice String
.. _bpy.types.FunctionNodeSliceString:

*****************
Slice String Node
*****************

.. figure:: /images/node-types_FunctionNodeSliceString.webp
   :align: center
   :alt: Slice String node.

The *Slice String* node extracts a string segment from a larger string.


Inputs
======

String
   String value to be sliced.

Position
   Integer value used to determine the starting point of the new string within the input string.
   The first letter of the string is at index 0.

Length
   Integer value used to determine how many characters are extracted from the input string.


Properties
==========

This node has no properties.


Outputs
=======

String
   String value of the extracted substring.


## Special Characters

.. index:: Geometry Nodes; Special Characters
.. _bpy.types.FunctionNodeInputSpecialCharacters:

***********************
Special Characters Node
***********************


.. figure:: /images/node-types_FunctionNodeInputSpecialCharacters.webp
   :align: center
   :alt: Special Characters node.

The *Special Characters* node is used to output string characters that can't be typed directly with the keyboard.

.. tip::

   This node can be used to create a multi-line string for
   the :doc:`/modeling/geometry_nodes/utilities/text/string_to_curves`,
   when combined with the :doc:`/modeling/geometry_nodes/utilities/text/join_strings`
   or the :doc:`/modeling/geometry_nodes/utilities/text/replace_string`.


Inputs
======

This node has no inputs.


Properties
==========

This node has no properties.


Outputs
=======

Line Break
   A new line character (escape character ``\n``).

Tab
   A tab character used to add an indentation in the output.


## String Length

.. index:: Geometry Nodes; String Length
.. _bpy.types.FunctionNodeStringLength:

******************
String Length Node
******************

.. figure:: /images/node-types_FunctionNodeStringLength.webp
   :align: center
   :alt: String Length node.

The *String Length* node outputs the number of characters in the input string.


Inputs
======

String
   String value to be evaluated.


Properties
==========

This node has no properties.


Outputs
=======

Length
   Integer value representing the length of the input string.


## String To Curves

.. index:: Geometry Nodes; String to Curves
.. _bpy.types.GeometryNodeStringToCurves:

*********************
String to Curves Node
*********************

.. figure:: /images/node-types_GeometryNodeStringToCurves.webp
   :align: right
   :alt: String to Curves node.

The *String to Curves* converts a string to curve instances. Each unique character used in the string
is converted to a curve once, and further uses of that character are more instances of the same geometry.

This makes processing the output geometry very efficient, because each unique character
only has to be processed once. However, it means that the result will be the same
for every instance of the same character. To process each character individually,
the :doc:`/modeling/geometry_nodes/instances/realize_instances` can be used.

.. tip::

   :doc:`Socket inspection </modeling/geometry_nodes/inspection>` can be used to see the value
   of the string input used when the node was evaluated, by holding the mouse over the socket.


Inputs
======

String
   Standard string input.

Size
   The size of each character. The values of the other inputs are scaled by this value.

Character Spacing
   A factor by which the space between each character (kerning) is scaled on the X axis.

Word Spacing
   A factor by which whitespace between words is scaled on the X axis.

Line Spacing
   The distance between separate lines in the output. Scaled by the *Size* input.

Text Box Width
   The maximum width of each line, though individual words will not be wrapped.

Text Box Height
   The maximum height for all the lines of the text.


Properties
==========

Font
   Font glyph used to generate the curve.

Overflow
   :Overflow:
      Wraps the text at the *Text Box Width*.
   :Scale To Fit:
      Scales the text size to fit the *Text Box Width* and *Text Box Height*.
   :Truncate:
      Only outputs text characters that fit within the width and height, based on the *Size* input.
      Any part of the string that did not fit is moved to the *Remainder* output.

Alignment
   :Left: Aligns the text to the left.
   :Center: Aligns the text to the center.
   :Right: Aligns the text to the right.
   :Justify: Aligns the text to the left and right.
   :Flush: Aligns the text to the left and right with equal character spacing.

Align Y
   :Top: Aligns the text to the top.
   :Top Baseline: Aligns the text to the top baseline.
   :Middle: Aligns the text to the middle.
   :Bottom Baseline: Aligns the text to the bottom baseline.
   :Bottom: Aligns the text to the bottom.

Pivot Point
   Controls where on each character the output *Pivot Point* is placed.

   :Midpoint: Place the pivot points at the center of each character's bounds.
   :Top Left: Place the pivot points at the top left of each character's bounds.
   :Top Center: Place the pivot points at the middle of the top of each character's bounds.
   :Top Right: Place the pivot points at the top right of each character's bounds.
   :Bottom Left: Place the pivot points at the bottom left of each character's bounds.
   :Bottom Center: Place the pivot points at the middle of bottom of each character's bounds.
   :Bottom Right: Place the pivot points at the bottom right of each character's bounds.


Outputs
=======

Curve Instances
   Curve instances geometry.

Remainder
   The part of the text that did not fit in the box described by the *Text Box Height* and
   *Text Box Width* inputs. Only used in the *Truncate* overflow mode.

Line
   An attribute field containing the line index of each character
   (on the :ref:`instance domain <attribute-domains>`).

Pivot Point
   Outputs the position described by the *Pivot Point* drop-down in the local space of each instance.


Examples
========

.. figure:: /images/modeling_geometry-nodes_text_string-to-curves_example.png
   :align: center

The node can be used to make overflowing text boxes. Here, the text that does not fit into
the first node's fix-sized text box is passed to a separate *String to Curves* node.
And finally added with a *Scale to Fit* node.


## Value To String

.. index:: Geometry Nodes; Value to String
.. _bpy.types.FunctionNodeValueToString:

********************
Value to String Node
********************

.. figure:: /images/node-types_FunctionNodeValueToString.webp
   :align: center
   :alt: Value to String node.

The *Value to String* node generates string representation of the input value.


Inputs
======

Value
   Floating-point value to be converted.

Decimals
   Integer value used to determine the precision of the output value.


Properties
==========

This node has no properties.


Outputs
=======

String
   String value representation of the input.


## Combine Xyz

.. index:: Geometry Nodes; Combine XYZ

****************
Combine XYZ Node
****************

.. figure:: /images/compositing_node-types_CompositorNodeCombineXYZ.webp
   :align: right
   :alt: Combine XYZ Node.

The *Combine XYZ Node* combines a vector from its individual components.


Inputs
======

- X
- Y
- Z


Properties
==========

This node has no properties.


Output
======

Vector
   Standard vector output.

.. note::

   The vector is not normalized.


## Index


########################
  Vector Utility Nodes
########################

Nodes for modifying vector quantities.

.. toctree::
   :maxdepth: 1

   combine_xyz.rst
   separate_xyz.rst
   vector_curves.rst
   vector_math.rst
   vector_rotate.rst


## Separate Xyz

.. index:: Geometry Nodes; Separate XYZ

*****************
Separate XYZ Node
*****************

.. figure:: /images/compositing_node-types_CompositorNodeSeparateXYZ.webp
   :align: right
   :alt: Separate XYZ Node.

The *Separate XYZ Node* splits a vector into its individual components.


Input
=====

Vector
   Standard vector input.


Properties
==========

This node has no properties.


Outputs
=======

- X
- Y
- Z


## Vector Curves

.. index:: Geometry Nodes; Vector Curves
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /compositing/types/vector/vector_curves.rst
   :start-after: .. --- copy below this line ---


## Vector Math

.. index:: Geometry Nodes; Vector Math
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /render/shader_nodes/converter/vector_math.rst
   :start-after: .. --- copy below this line ---


## Vector Rotate

.. index:: Geometry Nodes; Vector Rotate
.. DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
.. include:: /render/shader_nodes/vector/vector_rotate.rst
   :start-after: .. --- copy below this line ---


## Index


################
  Volume Nodes
################

Nodes for creating or working with volumes.

.. toctree::
   :maxdepth: 1

   Operations <operations/index.rst>
   Primitives <primitives/index.rst>


## Index


##########################
  Volume Operation Nodes
##########################

.. toctree::
   :maxdepth: 1

   volume_to_mesh.rst


## Volume To Mesh

.. index:: Geometry Nodes: Volume to Mesh
.. _bpy.types.GeometryNodeVolumeToMesh:

*******************
Volume to Mesh Node
*******************

.. figure:: /images/node-types_GeometryNodeVolumeToMesh.webp
   :align: center
   :alt: The Volume to Mesh node.

The *Volume to Mesh* node generates a mesh on the "surface" of a volume.
The surface is defined by a threshold value.
All voxels with a larger value than the threshold are considered to be inside.


Inputs
======

Volume
   Standard geometry input.

Voxel Amount
   Specifies the approximate resolution of the final mesh.
   The voxel size is adapted to the size of the entire volume.

Voxel Size
   Use a fixed resolution that does not change when the volume changes.

Threshold
   Voxels with a larger value are considered to be inside the mesh.
   The mesh will be generated on the boundary of inside and outside voxels.
   This is also called "iso value".

Adaptivity
   Reduces the final face count by simplifying geometry where detail is not needed.
   This is similar to decimating the final to reduce resolution where it is not needed.


Properties
==========

Resolution Mode
   Mode for how the resolution of the final mesh is controlled.

   :Grid:
      This makes the resolution dependent on the resolution of the grid that is converted.
      Higher resolution grids result in a higher resolution mesh.
      In many cases, that is the most efficient mode.
   :Voxel Amount:
      Specifies the approximate resolution of the final mesh.
      The voxel size is adapted to the size of the entire volume.
   :Voxel Size:
      Use a fixed resolution that does not change when the volume changes.

   .. note::

      This option applies individually for every grid in the input geometry.

Outputs
=======

Mesh
   Standard geometry output.


## Index


##########################
  Volume Primitive Nodes
##########################

.. toctree::
   :maxdepth: 1

   volume_cube.rst


## Volume Cube

.. index:: Geometry Nodes: Volume Cube
.. _bpy.types.GeometryNodeVolumeCube:

****************
Volume Cube Node
****************

.. figure:: /images/node-types_GeometryNodeVolumeCube.webp
   :align: right
   :alt: The Volume Cube node.

The *Volume Cube* generates a volume from scratch by evaluating an input field on every single
voxel in a rectangular prism. The *Density* field defines the output volume grid's value at every
voxel. The field can only depend on the :doc:`/modeling/geometry_nodes/geometry/read/position`.


Inputs
======

Density
   The value for the new grid at each voxel.

Background
   The value of the grid outside the rectangular prism controlled by the *Min* and *Max* inputs.
   The node can generate a more memory-efficient volume when the values of the *Density* input are
   the same as the background value.

Min
   One corner of the rectangular prism in which to fill evaluate the field.

Max
   The other corner of the rectangular prism in which to fill evaluate the field.

Resolution X,Y,Z
   The number of voxels to evaluate the field in on each axis.

   .. note::

      Changing these values can have a significant impact on performance. For example, the default values
      of 32 mean the input field will be evaluated about 33 thousand times. Increasing the values to 100
      will give 1 million evaluations, and 1000 would give 1 billion.


Properties
==========

This node has no properties.


Outputs
=======

Volume
   Geometry containing the generated volume.


## Import Images As Planes

.. _bpy.ops.image.import_as_mesh_planes:

***********************
Import Images as Planes
***********************

.. reference::

   :Menu:      :menuselection:`3D Viewport --> Add --> Image --> Images as Planes`

Imports images and creates planes with them as textures.
It automates the process of creating a plane, resizing it to fit the dimensions of the image,
and creating a material with the image texture to it.
The name of the plane, material, and texture will be derived from the name of the image file.

You can import a single image, multiple images, or an image sequence/movie clip.
If you choose a single image, it creates one plane; if you choose multiple images,
it creates as many planes as the number of images you selected, either stacked on top of each other or spaced apart.
Selecting a movie clip or an image sequence will create a single plane with an animation.


Properties
==========

You can save the current import settings as an :ref:`Operator Preset <ui-presets>`.


Options
-------

Relative Path
   Set link to the image file using a :ref:`relative file path <files-blend-relative_paths>`.

Force Reload
   Reload the image file if it already exists as an image data-block.

Animate Image Sequences
   Import sequentially numbered images as
   an animated :doc:`image sequence </video_editing/edit/montage/strips/image>` instead of separate planes.
   They will be imported as a *Clip* texture on a single plane.
   The frame range will be automatically set but can be changed later.


Material
--------

Images as Planes sets up a material to display the image. You can set the type of material and related settings
before the import.

Shader
   :Principled:
      The material will have a :doc:`Principled BSDF </render/shader_nodes/shader/principled>` shader node
      with default settings as its main component.
      An Image Texture node linked to the imported image will be connected to the Base Color of the Principled
      BSDF node.
   :Shadeless:
      A shadeless material is a material that does not respond to light from other objects and always has the same
      color in any lighting environment.
      This option creates a material with a node group of a mix between a Diffuse and an Emission shader controlled
      by a Light Path node.
   :Emit:
      The material will have a Principled BSDF shader node as its main component, but the Color output from
      the Image Texture node will be linked to the Emission input instead of the Base Color.

      Strength
         Set the strength of the emission.

.. note::

   *Blend Mode* and *Shadow Mode* options are specific to the EEVEE renderer.
   For a detailed explanation of each option, see :doc:`Material Settings </render/eevee/material_settings>`.

Blend Mode
   Set the alpha blend mode of the material.

Shadow Mode
   Set the shadow mode of the material.

Show Backface
   Show backside of the transparent part.

Backface Culling
   Hide backside of the plane.

Overwrite Material
   By default, the name of the new material from the name of the imported image. However, if there is already
   a material with the same name, Blender will append a number to the name of the material to avoid conflict.
   This *Override Material* option makes it overwrite the existing material of the same name in that case.


Texture
-------

.. note::

   For a detailed explanation of each option, see :doc:`Image Texture Node </render/shader_nodes/textures/image>`.

Interpolation
   Set the method to scale the image.

Extension
   Set how the image is extrapolated past the original bounds.

Alpha
   Use the alpha channel of the image for transparency.

Auto Refresh
   Automatically refresh the images in the viewport on frame changes.


Transform
---------

Images as Planes creates the plane at the 3D Cursor's location. With *Offset Planes*, multiple planes will be
placed with distance intervals set in *Offset*, along the axis set in *Local Axis*, beginning at the 3D Cursor's
location.

Size Mode
   Set how the plane's size will be determined.

   :Absolute:
      The size of the plane will be set based on the height value set in *Height*. The width will be set in direct
      ratio to the height value. For example, with the default height value of 1 m, an image of 800 × 600 pixels
      will have a width of 1 / 600 × 800 or 1.33 m.

      Height
         Set the height of the plane.

   :Camera Relative:
      The size of the plane will be set to fit or fill the camera frame. This will automatically set the *Align*
      option to *Face Camera*. Make sure to have an active camera in the scene before the import.

      :Fit:
         Scale the plane to fit inside the camera frame while preserving the aspect ratio.
      :Fill:
         Scale the plane so that it fills the entire camera view while preserving the aspect ratio, but some part of
         the image can spill outside the camera frame.

   ::abbr:`DPI (Dots per inch)`:
      The size of the plane will be set based on the pixels per inch value set in *Definition*. With the *Unit System*
      set to *Metric* and the default definition of 600 DPI, an image of 800 × 600 pixels will have a size of
      0.0339 × 0.0254 units since 600 pixels are defined as 1 inch (0.0254 m).

      Definition
         Set the number of pixels to fit in 1 inch.

   :Dots/BU:
      The size of the plane will be set based on the pixels per Blender Unit set in *Definition*. With the default
      definition value of 600, an image of 800 × 600 pixels will have a size of 1.33 × 1 units.

      Definition
         Set the number of pixels to fit in 1 Blender Unit.

Align
   Set the rotation of the plane.

   :Main Axis:
      The plane will be aligned to a major axis that is best to face the camera's view direction.
      If there is no camera in the scene, the plane will face toward Z+ (Up) axis.
   :Face Camera:
      Similar to the *Main Axis* but the plane will be rotated to directly face the camera's view direction.
   :Z- (Down), Y-, X-, Z+ (Up), Y+, X+:
      The plane will be rotated to face toward the selected axis.

Track Camera
   Add a :doc:`Locked Track </animation/constraints/tracking/locked_track>` constraint to make the plane always
   face the camera, even if the camera moves. This option is only available when *Main Axis* or *Face Camera*
   option is selected in the *Align* menu.

Offset Planes
   Place multiple planes with an offset. If disabled, all planes will be created at the same location.

Offset Direction
   Choose a local axis (not the global axis) to offset the planes. For example, if you choose *X+*, the planes
   will be placed along the positive direction of the plane's local X axis.

Distance
   Set a distance between each plane.


## Index

.. _bpy.types.Mesh:
.. _bpy.ops.mesh:

##########
  Meshes
##########

.. toctree::
   :maxdepth: 2

   introduction.rst
   structure.rst
   primitives.rst
   tools/index.rst
   selecting/index.rst
   editing/index.rst
   properties/index.rst
   uv/index.rst
   mesh_analysis.rst
   retopology.rst


## Introduction


************
Introduction
************

Mesh Modeling typically begins with
a :doc:`Mesh Primitive </modeling/meshes/primitives>` shape (e.g. circle, cube, cylinder...).
From there you might begin editing to create a larger, more complex shape.


Modeling Modes
==============

The 3D Viewport has three principal modes that allow for the creation,
editing and manipulation of the mesh models.
Each of the three modes has a variety of tools. Some tools may be found in one or more of the modes.

Modes that used for modeling:

Object Mode
   Supports basic operations such as object creation,
   joining objects, managing shape keys, UV/color layers.
Edit Mode
   Used for the majority of mesh editing operations.
Sculpt Mode
   Instead of dealing with individual mesh elements,
   supports sculpting with brushes *(not covered in this chapter)*.


## Mesh Analysis

.. _bpy.types.MeshStatVis:
.. _modeling-mesh-analysis:

*************
Mesh Analysis
*************

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Header --> Overlays --> Mesh Analysis`

Mesh analysis is useful for displaying attributes of the mesh,
that may impact certain use cases.

The mesh analysis works in *Edit Mode* and *Solid* Viewport shading.
It shows areas with a high value in red, and areas with a low value in blue.
Geometry outside the range is displayed gray.

Currently the different modes target 3D printing as their primary use.


Overhang
========

Extrusion 3D printers have a physical limit to the overhang that can be printed,
this display mode shows the overhang with angle range and axis selection.

Minimum/Maximum
   Minimum/Maximum angle to display.
Axis
   Axis and direction to use as the bases to calculate the angle to visualize.

.. figure:: /images/modeling_meshes_mesh-analysis_overhang.png
   :width: 350px
   :align: center

   Overhang.


Thickness
=========

Printers have a limited *wall-thickness* where very thin areas cannot be printed,
this test uses ray casting and a distance range to the thickness of the geometry.

Minimum/Maximum
   Minimum/Maximum thickness to display.
Samples
   Number of samples to use to calculate the thickness.

.. figure:: /images/modeling_meshes_mesh-analysis_thickness.png
   :width: 400px
   :align: center

   Thickness.


Intersections
=============

Another common cause of problems for printing are intersections between surfaces,
where the inside/outside of a model cannot be reliably detected.

Unlike other display modes, intersections have no variance and are either on or off.

.. figure:: /images/modeling_meshes_mesh-analysis_intersections.png
   :width: 400px
   :align: center

   Intersecting faces.


Distortion
==========

Distorted geometry can cause problems since the triangulation of a distorted n-gon is undefined.

Distortion is measured by faces which are not flat,
with parts of the face pointing in different directions.

Minimum/Maximum
   Minimum/Maximum distortion to display.

.. figure:: /images/modeling_meshes_mesh-analysis_distortion.png
   :width: 300px
   :align: center

   Distorted Faces.


Sharp Edges
===========

Similar to wall-thickness, sharp edges can form shapes that are too thin to be able to print.

Minimum/Maximum
   Minimum/Maximum angle to display.

.. figure:: /images/modeling_meshes_mesh-analysis_sharp-edges.png
   :width: 350px
   :align: center

   Sharp edges.


Known Limitations
=================

There are some known limitations with mesh analysis:

- Currently only displayed with Deform Modifiers.
- For high-poly meshes the performance is low while editing.


## Primitives


**********
Primitives
**********

.. reference::

   :Mode:      Object Mode and Edit Mode
   :Menu:      :menuselection:`Add --> Mesh`
   :Shortcut:  :kbd:`Shift-A`

A common object type used in a 3D scene is a mesh.
Blender comes with a number of "primitive" mesh shapes that you can start modeling from.
You can also add primitives in Edit Mode at the 3D cursor.

.. figure:: /images/modeling_meshes_primitives_all.png

   Blender's standard primitives.

.. note:: Planar Primitives

   You can make a planar mesh three-dimensional by moving one or more of the vertices out of its plane
   (applies to *Plane*, *Circle* and *Grid*).
   A simple circle is often used as a starting point to create even the most complex of meshes.


Common Options
==============

These options can be specified in the :ref:`bpy.ops.screen.redo_last` panel,
which appears when the object is created.
Options included in more than one primitive are:

Generate UVs
   Generates a default UV unwrapping of new geometry.
   This will be defined in the first UV layer (which will get added if needed).
Radius/Size, Align to View, Location, Rotation
   See :ref:`Common Object Options <object-common-options>`.


.. _bpy.ops.mesh.primitive_plane_add:

Plane
=====

The standard plane is a single quad face, which is composed of four vertices, four edges, and one face.
It is like a piece of paper lying on a table;
it is not a three-dimensional object because it is flat and has no thickness.
Objects that can be created with planes include floors, tabletops, or mirrors.

.. seealso::

   :ref:`Import Images as Planes <bpy.ops.image.import_as_mesh_planes>`
   adds a mesh plane with materials and texture from an image file.
   The dimensions of the plane are calculated to match the aspect of the image file.

.. toctree::
   :hidden:

   import_images_as_planes.rst


.. _bpy.ops.mesh.primitive_cube_add:

Cube
====

A standard cube contains eight vertices, twelve edges, and six faces,
and is a three-dimensional object. Objects that can be created out of cubes include dice,
boxes, or crates.


.. _bpy.ops.mesh.primitive_circle_add:

Circle
======

Vertices
   The number of vertices that define the circle or polygon.
Fill Type
   Set how the circle will be filled.

   :Triangle Fan: Fill with triangular faces which share a vertex in the middle.
   :N-gon: Fill with a single :term:`N-gon`.
   :Nothing: Do not fill. Creates only the outer ring of vertices.


.. _bpy.ops.mesh.primitive_uv_sphere_add:

UV Sphere
=========

A standard UV sphere is made out of quad faces and a triangle fan at the top and bottom.
It can be used for texturing.

Segments
   Number of vertical segments. Like the Earth's meridians, going pole to pole.
Rings
   Number of horizontal segments. These are like the Earth's parallels.

   .. note::

      Rings are face loops and not edge loops, which would be one less.


.. _bpy.ops.mesh.primitive_ico_sphere_add:

Icosphere
=========

An icosphere is a polyhedral sphere made up of triangles.
Icospheres are normally used to achieve a more isotropical layout of
vertices than a UV sphere, in other words, they are uniform in every direction.

Subdivisions
   How many recursions are used to define the sphere.
   At level 1 the icosphere is an icosahedron, a solid with 20 equilateral triangular faces.
   Each increase in the number of subdivisions splits each triangular face into four triangles.

.. note::

   Subdividing an icosphere raises the vertex count very quickly even with few iterations
   (10 times creates 5,242,880 triangles),
   Adding such a dense mesh is a sure way to cause the program to crash.


.. _bpy.ops.mesh.primitive_cylinder_add:

Cylinder
========

Objects that can be created out of cylinders include handles or rods.

Vertices
   The number of vertical edges between the circles used to define the cylinder or prism.
Depth
   Sets the starting height of the cylinder.

Cap Fill Type
   Similar to circle (see above). When set to none, the created object will be a tube.
   Objects that can be created out of tubes include pipes or drinking glasses
   (the basic difference between a cylinder and a tube is that the former has closed ends).


.. _bpy.ops.mesh.primitive_cone_add:

Cone
====

Objects that can be created out of cones include spikes or pointed hats.

Vertices
   The number of vertical edges between the circles or tip, used to define the cone or pyramid.
Radius 1
   Sets the radius of the circular base of the cone.
Radius 2
   Sets the radius of the tip of the cone. Which will create a frustum (a pyramid or cone with the top cut off).
   A value of 0 will produce a standard cone shape.
Depth
   Sets the starting height of the cone.

Base Fill Type
   Similar to circle (see above).


.. _bpy.ops.mesh.primitive_torus_add:

Torus
=====

A doughnut-shaped primitive created by rotating a circle around an axis.
The overall dimensions can be defined by two methods.

Operator Presets
   Torus preset settings for reuse. These presets are stored as scripts in the proper presets directory.

Major Segments
   Number of segments for the main ring of the torus.
   If you think of a torus as a "spin" operation around an axis, this is how many steps are in the spin.

Minor Segments
   Number of segments for the minor ring of the torus.
   This is the number of vertices of each circular segment.

Dimensions Mode
   Change the way the torus is defined.

   Major/Minor, Exterior/Interior

   Major Radius
      Radius from the origin to the center of the cross sections.
   Minor Radius
      Radius of the torus' cross section.

   Exterior Radius
      If viewed along the major axis,
      this is the radius from the center to the outer edge.
   Interior Radius
      If viewed along the major axis,
      this is the radius of the hole in the center.


.. _bpy.ops.mesh.primitive_grid_add:

Grid
====

A regular quadratic grid which is a subdivided plane.
Example objects that can be created out of grids include landscapes
and organic surfaces.

X Subdivisions
   The number of spans in the X axis.
Y Subdivisions
   The number of spans in the Y axis.


.. _bpy.ops.mesh.primitive_monkey_add:

Monkey
======

This adds a stylized monkey head to use as a test mesh,
use :term:`Subdivision Surface` for a refined shape.

This is intended as a test mesh, similar to:

- `Utah Teapot <https://en.wikipedia.org/wiki/Utah_teapot>`__
- `Stanford Bunny <https://en.wikipedia.org/wiki/Stanford_Bunny>`__.

.. admonition:: History
   :class: tip

   This is a gift from old NaN to the community and is seen as a programmer's joke or
   "Easter Egg". It creates a monkey's head once you press the *Monkey* button.
   The Monkey's name is "Suzanne" and is Blender's mascot.

.. note::

   In addition to the basic geometric primitives can be added via extensions
   These are available from the :doc:`Preferences </editors/preferences/extensions>`.


## Retopology

.. the title should be remeshing since retopology (feature based) is a subtype of remeshing.
   remeshing vs. retopology by dev Pablo Dobarro bcon19: https://www.youtube.com/watch?v=lxkyA4Xslzs&t=9m34s

**********
Retopology
**********

Retopology is the process of simplifying the topology of a mesh to make it cleaner and easier to work with.
Retopology is need for mangled topology resulting from sculpting or generated topology, for example from a 3D scan.
Meshes often need to be retopologized if the mesh is going to be deformed in some way.
Deformations can include rigging or physics simulations such as cloth or soft body.
Retopology can be done by hand by manipulating geometry in Edit Mode or through automated methods.


Using the Poly Build Tool
=========================

Todo 2.81.


.. _bpy.types.Mesh.remesh:
.. _bpy.ops.object.voxel_remesh:

Remeshing
=========

.. reference::

   :Mode:      Object Mode, Sculpt Mode
   :Panel:     :menuselection:`Properties --> Object Data --> Remesh`

Remeshing is a technique that automatically rebuilds the geometry with a more uniform topology.
Remeshing can either add or remove the amount of topology depending on a defined resolution.
This technique is especially useful for :doc:`sculpting </sculpt_paint/sculpting/index>`,
to generate better topology after blocking out the initial shape.

.. note:: Limitations:

   - Remeshing only works on the original mesh data and
     ignores generated geometry from modifiers, shape keys, rigging, etc.
   - Remeshing will not work with the :doc:`/modeling/modifiers/generate/multiresolution`.

.. seealso::

   :doc:`Remesh modifier </modeling/modifiers/generate/remesh>`


Voxel
-----

The Voxel Remesher uses OpenVDB to generate a new manifold mesh from the current geometry.
It produces a mesh with perfectly even distributed topology and
it does not have any performance penalty once the new mesh is calculated.
This makes the voxel remesher great for sculpting as it is possible to
sculpt at a much higher level of detail than using other features
like dyntopo which often adds more performance overhead.

Voxel Size
   The resolution or the amount of detail the remeshed mesh will have.
   The value is used to define the size, in object space, of the :term:`Voxel`.
   These voxels are assembled around the mesh and are used to determine the new geometry.
   For example a value of 0.5 m will create topological patches that are about 0.5 m
   (assuming *Preserve Volume* is enabled).
   Lower values preserve finer details but will result in a mesh with a much more dense topology.

Adaptivity
   Reduces the final face count by simplifying geometry where detail is not needed.
   This introduce triangulation to faces that do not need as much detail.
   Note, an *Adaptivity* value greater than zero disables *Fix Poles*.

Fix Poles
   Tries to produce less :term:`Poles <Pole>` at the cost of some performance to produce a better topological flow.

Preserve
   Volume
      Tells the algorithm to try to preserve the original volume of the mesh.
      Enabling this could make the operator slower depending on the complexity of the mesh.
   Paint Mask
      Reprojects the :ref:`paint mask <sculpt-mask-menu>` onto the new mesh.
   Face Sets
      Reprojects :ref:`Face Sets <sculpting-editing-facesets>` onto the new mesh.
   Color Attributes
      Reprojects the :ref:`Color Attributes <modeling-meshes-properties-object_data-color-attributes>` onto
      the new mesh.

Voxel Remesh
   Performs the remeshing operation to create a new manifold mesh based on the volume of the current mesh.
   Performing this will lose all mesh object data layers associated with the original mesh.


.. _bpy.ops.object.quadriflow_remesh:

Quad
----

The Quad remesh uses the Quadriflow algorithm to create a :term:`Quad`
based mesh with few poles and edge loops following the curvature of the surface.
This method is relatively slow but generates a higher quality output for final topology.

.. warning::

   Performing *Quadriflow Remesh* will lose all mesh object data layers associated with the original mesh.

Quadriflow Remesh
   Opens a pop-up used to set parameters for the remesh operation.

Use Paint Symmetry
   Generates a symmetrical mesh using the :ref:`Mesh Symmetry <modeling_meshes_tools-settings_mirror>` options.

Preserve Sharp
   Tells the algorithm to try to preserve sharp features of the mesh.
   Enabling this could make the operator slower depending on the complexity of the mesh.

Preserve Mesh Boundary
   Tells the algorithm to try to preserve the original volume of the mesh.
   Enabling this could make the operator slower depending on the complexity of the mesh.

.. Use Mesh Curvature
..    Take the mesh curvature into account when remeshing.

Preserve Paint Mask
   Reprojects the :ref:`Paint Mask <sculpt-mask-menu>` onto the new mesh.

Smooth Normals
   Applies the :ref:`Smooth Normals <bpy.ops.object.shade_smooth>` operator to the resulting mesh.

Mode
   How to specify the amount of detail for the new mesh.

   :Ratio: Specify target number of faces relative to the current mesh.
   :Edge Length: Input target edge length in the new mesh.
   :Faces: Input target number of faces in the new mesh.

Seed
   Random :term:`Seed` to use with the solver;
   different seeds will cause the remesher to generate different quad layouts on the mesh.


## Structure


*********
Structure
*********

With meshes, everything is built from three basic structures:
*vertices*, *edges* and *faces*.

.. figure:: /images/modeling_meshes_structure_example.svg
   :width: 600px

   Example of mesh structure.

.. The geometry of the faces performing the model is called topology.


Vertices
========

The most elementary part of a mesh is the vertex (vertices plural) which is a single point or position in 3D space.
Vertices are represented in the 3D Viewport in Edit Mode as small dots.
The vertices of an object are stored as an array of coordinates.

.. tip::

   Do not mistake the :doc:`object origin </scene_layout/object/origin>` for a vertex.
   It may look similar, but it is bigger and cannot be selected.

   .. figure:: /images/modeling_meshes_structure_cube-example.png

      The vertex is labeled as "A"; the object's origin dot is labeled as "B".


Edges
=====

An edge always connects two vertices by a straight line.
The edges are the "wires" you see when you look at a mesh in wireframe view.
They are usually invisible on the rendered image. They are used to construct faces.


Faces
=====

Faces are used to build the actual surface of the object.
They are what you see when you render the mesh.
If this area does not contain a face,
it will simply be transparent or nonexistent in the rendered image.

A face is defined as the area between either three (triangles), four (quadrangles) or more (n-gons) vertices,
with an edge on every side. The faces are often abbreviated to *tris, quads & n-gons*.

Triangles are always flat and therefore easy to calculate. On the other hand,
quadrangles "deform well" and are therefore preferred for animation and subdivision modeling.

.. seealso::

   - `Why should triangles be avoided for character animation? <https://blender.stackexchange.com/questions/2931>`__
   - `When should N-gons be used, and when shouldn't they? <https://blender.stackexchange.com/questions/89>`__


.. _modeling-meshes-structure-normals:

Normals
=======

In geometry, a normal is a direction or line that is perpendicular to something,
typically a triangle or surface but can also be relative to a line,
a tangent line for a point on a curve, or a tangent plane for a point on a surface.

Normals help to determine the shading of the mesh among other things.

.. figure:: /images/modeling_meshes_structure_viewport.png
   :width: 350px

   A visualization of the face normals of a torus.

In the figure above, each blue line represents the normal for a face on the torus.
The lines are each perpendicular to the face on which they lie.
The visualization can be activated, in Edit Mode,
in the :ref:`Mesh Display Viewport Overlays panel <mesh-display-normals>`.


.. _modeling-meshes-structure-normals-shading:

Shading
-------

Surface normals play a fundamental role in determining how light interacts with 3D objects
and thus greatly influence the shading of those objects. Normals can be shaded smooth or flat.

When a mesh uses flat shading, the faces are rendered and displayed faces uniformly.
This is usually desirable for objects with flat surfaces such as a cube or pyramid.

When a mesh uses smooth shading, the normals are interpolated cross the vertices of a polygonal mesh,
smooth transitions between adjacent polygons can be achieved, resulting in a more realistic appearance.

By default face normals have flat shading however, this can be adjusted either for the whole object or per face.

To adjust the the shading of the whole object, use:

- :ref:`bpy.ops.object.shade_smooth` -- To mark the whole object as smooth
- :ref:`bpy.ops.object.shade_smooth_by_angle` -- To mark portions of the object as smooth

To revert to flat shading, use :ref:`bpy.ops.object.shade_flat`

The shading of objects can also be adjusted per face, edge, or vertex.


.. _modeling_meshes_normals_custom:

Custom Split Normals
--------------------

*Custom Split Normals* is a way to tweak/fake shading by pointing normals towards
other directions than the default, auto-computed ones. It is mostly used in game development,
where it helps counterbalance some issues generated by low-poly objects
(the most common examples are low-poly trees, bushes, grass, etc. and the 'rounded' corners).

Blender supports custom normals on a 'smooth fan' base, defined as a set of neighbor face corners
sharing the same vertex and 'linked' by smooth edges. This means you can have normals per face corners,
per a set of neighbor face corners, or per vertex.

.. tip::

   The computation of *Custom Split Normals* can be disabled to improve performance.
   This option can be found in the :ref:`Simplify Rendering Settings <bpy.types.RenderSettings.use_simplify_normals>`.


Editing Custom Split Normals
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals`
   :Shortcut:  :kbd:`Alt-N`

There are a number of tools for editing custom split normals.
The custom normal mesh edit tools can affect all normals (the default), or only selected ones.
To select a custom normal associated with a particular vertex and face:

- Make the element selection mode both Vertex and Face (use :kbd:`Shift-LMB` to enable the second one).
- Select one or more vertices, then select a face.
  This can be repeated to select more vertices and a different face and so on.
  It is easiest to see the effect of these tools if you turn on
  the Edit Mode Overlays option *Display vertex-per-face normals as lines*.

.. seealso::

   :doc:`Editing Normals </modeling/meshes/editing/mesh/normals>`.


Importing Custom Split Normals
------------------------------

Some tools, particularly those used in :abbr:`CAD (Computer-Aided Design)`, tend to generate irregular geometry
when tessellating their objects into meshes (very thin and long triangles, etc.).
Auto-computed normals on such geometry often gives bad artifacts,
so it is important to be able to import and use the normals as generated by the CAD tool itself.

.. note::

   Currently, only the :doc:`FBX Importer </addons/import_export/scene_fbx>` and
   :doc:`Alembic Importer </files/import_export/alembic>` are capable of importing custom normals.


Topology
========

.. Note: this could be it's own page, for now keep this a fairly brief section.

Loops
-----

.. _fig-mesh-topo-loop:

.. figure:: /images/modeling_meshes_structure_edge-face-loops.png

   Edge and face loops.

*Edge* and *face* loops are sets of faces or edges that form continuous "loops" as shown in
Fig. :ref:`fig-mesh-topo-loop`.

In the image above, loops that do not end in poles are cyclic (1 and 3).
They start and end at the same vertex and divide the model into two partitions.
Loops can be a quick and powerful tool to work with specific,
continuous regions of a mesh and are a prerequisite for organic character animation.
For a detailed description of how to work with loops in Blender, see:
:ref:`bpy.ops.mesh.loop_multi_select`.

.. note::

   Note that loops (2 and 4) do not go around the whole model.
   Loops stop at so-called poles because there is no unique way to continue a loop from a pole.
   Poles are vertices that are connected to either three, five, or more edges. Accordingly,
   vertices connected to exactly one, two or four edges are not poles.


.. _modeling-mesh-structure-edge-loops:

.. rubric:: Edge Loops

Loops (1 and 2) in Fig. :ref:`fig-mesh-topo-loop` are edge loops.
They connect vertices so that each one on the loop has exactly two neighbors that are not on
the loop and placed on both sides of the loop (except the start and end vertex in case of poles).

Edge loops are an important concept especially in organic (subsurface)
modeling and character animation. When used correctly, they allow you to build models with
relatively few vertices that look very natural when used as subdivision surfaces and
deform very well in animation.

Take Fig. :ref:`fig-mesh-topo-loop` in organic modeling as an example: the edge loops follow
the natural contours and deformation lines of the skin and the underlying muscles.
The loops are denser in areas that deform more when the character moves, for example at the shoulders or knees.

Further details on working with edge loops can be found in :ref:`bpy.ops.mesh.loop_multi_select`.


.. rubric:: Face Loops

These are a logical extension of edge loops in that they consist of the faces between
two edge loops, as shown in loops (3 and 4) in Fig. :ref:`fig-mesh-topo-loop`.
Note that for non-circular loops (4)
the faces containing the poles are not included in a face loop.

Further details on working with face loops can be found in
:ref:`Face Loop Selection <modeling-meshes-selecting-face-loops>`.


Poles
-----

See `N-poles & E-poles <https://blender.stackexchange.com/a/133676/55>`__.


Non-Manifold
------------

See :term:`Non-manifold`.


## Index


###########
  Editing
###########

.. toctree::
   :maxdepth: 2

   introduction.rst
   mesh/index.rst
   vertex/index.rst
   edge/index.rst
   face/index.rst
   uv.rst


## Introduction


************
Introduction
************

Blender provides a variety of operators for editing meshes.
These operators are used to add, duplicate, move and delete elements.

These are available through the Menus in the 3D Viewport header, and context menus in the 3D Viewport,
as well as individual shortcut keys.

.. note::

   All the "transform precision/snap" keys :kbd:`Ctrl` and/or :kbd:`Shift`
   also work for all these advanced operations, but most of them do not have
   :doc:`axis locking </scene_layout/object/editing/transform/control/axis_locking>`
   possibilities, and some of them do not take into account
   the :doc:`pivot point </editors/3dview/controls/pivot_point/index>`
   and/or :doc:`transform orientation </editors/3dview/controls/orientation>` either.

These transform operators are available in the *Transform* section of the *Mesh* menu in the header.
Note that, some of these can also be used on other editable objects, like curves, surfaces, and lattices.


Accessing Mesh Operators
========================

The mesh editing operations are found in various places, and available through shortcuts as well.


Menus
-----

These menus are located in the header.
Some of the menus can be accessed with shortcuts:

- :kbd:`Ctrl-F` brings up the Face operators menu
- :kbd:`Ctrl-E` brings up the Edge operators menu
- :kbd:`Ctrl-V` brings up the Vertex operators menu


## Uv


************
UV Operators
************

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> UV`
   :Shortcut:  :kbd:`U`

Blender offers several ways of mapping UVs.
The simpler projection methods use formulas that map 3D space onto 2D space,
by interpolating the position of points toward a point/axis/plane through a surface.
The more advanced methods can be used with more complex models, and have more specific uses.


.. _bpy.ops.uv.unwrap:

Unwrap
======

.. reference::

   :Editor:    3D Viewport and UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Unwrap`
   :Shortcut:  :kbd:`U`

Flattens the mesh surface by cutting along :doc:`seams </modeling/meshes/uv/unwrapping/seams>`.
Useful for organic shapes.


Begin by selecting all the faces you want to unwrap.
In the 3D Viewport, select :menuselection:`UV --> Unwrap` or :kbd:`U` and select :menuselection:`Unwrap`.
You can also do this from the UV Editor with :menuselection:`UV --> Unwrap` or :kbd:`U`.
This method will unwrap all faces and reset previous work.
The UVs menu will appear in the UV Editor after unwrapping has been performed once.

.. figure:: /images/modeling_meshes_editing_uv_unwrap-example.png
   :width: 420px

   Result of unwrapping Suzanne.

This operation unwraps the faces of the object to provide
the "best fit" scenario based on how the faces are connected and will fit within the image,
and takes into account any seams within the selected faces.
If possible, each selected face gets its own different area of the image and is not overlapping any other faces UVs.
If all faces of an object are selected, then each face is mapped to a part of the image.

.. tip::

   A face's UV image texture only has to use *part* of the image, not the *whole* image.
   Also, portions of the same image can be shared by multiple faces.
   A face can be mapped to less and less of the total image.


Options
-------

The :ref:`bpy.ops.screen.redo_last` panel allows fine control over how a mesh is unwrapped:

Method
 :Angle Based:
   Uses Angle Based Flattening (ABF). This method gives a good 2D representation of a mesh.
 :Conformal:
   Uses Least Squares Conformal Mapping (LSCM).
   This usually results in a less accurate UV mapping than Angle Based, but performs better on simpler objects.
Fill Holes
   Activating Fill Holes will prevent overlapping from occurring and better represent any holes in the UV regions.
Correct Aspect
   Map UVs will take the image's aspect ratio into consideration.
   If an image has already been mapped to the :term:`Texture Space` that is non-square,
   the projection will take this into account and distort the mapping to appear correctly.
Use Subdivision Surface
   Map UVs taking vertex position after Subdivision Surface Modifier into account.
Margin Method
   The method to use when calculating the empty space between islands.

   :Scaled: Use scale of existing UVs to multiply margin.
   :Add: Simple method, just add the margin.
   :Fraction: Precisely specify the fraction of the UV unit square for margin. (Slower than other two methods.)
Margin
   The scale for the empty space between islands.


.. _bpy.ops.uv.smart_project:

Smart UV Project
================

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Smart UV Project`
   :Shortcut:  :kbd:`U`

Smart UV Project, cuts a mesh based on an angle threshold (angular changes in your mesh).
This gives you fine control over how automatic seams are created.
It is a good method for simple and complex geometric forms,
such as mechanical objects or architecture.

This algorithm examines the shape of your object,
the selected faces and their relation to one another,
and creates a UV map based on this information and settings that you supply.

In the example below, the Smart Mapper mapped all of the faces of a cube to a neat arrangement of three sides on top,
three sides on the bottom, for all six sides of the cube to fit squarely, just like the faces of the cube.

.. figure:: /images/modeling_meshes_editing_uv_smart-project.png
   :width: 670px

   Smart UV project on a cube.

For more complex mechanical objects,
this operator can quickly and easily create a regular and straightforward UV layout.


Options
-------

The :ref:`bpy.ops.screen.redo_last` panel allows fine control over how a mesh is unwrapped:

Angle Limit
   This controls how faces are grouped: a higher limit will lead to many small groups but less distortion,
   while a lower limit will create fewer groups at the expense of more distortion.
Margin Method
   The method to use when calculating the empty space between islands.

   :Scaled: Use scale of existing UVs to multiply margin.
   :Add: Simple method, just add the margin.
   :Fraction: Precisely specify the fraction of the UV unit square for margin. (Slower than other two methods.)
Rotation Method
   :Axis-aligned: Rotated to a minimal rectangle, either vertical or horizontal.
   :Axis-aligned (Horizontal): Rotate islands to be aligned horizontally.
   :Axis-aligned (Vertical): Rotate islands to be aligned vertically.
Island Margin
   This controls how tightly the UV islands are packed together.
   A higher number will add more space between islands.
Area Weight
   Weight projection's vector by faces with larger areas.
Correct Aspect
   Map UVs will take the image's aspect ratio into consideration.
   If an image has already been mapped to the :term:`Texture Space` that is non-square,
   the projection will take this into account and distort the mapping to appear correctly.
Scale to Bounds
   If the UV map is larger than the (0 to 1) range, the entire map will be scaled to fit inside.


.. _bpy.ops.uv.lightmap_pack:

Lightmap Pack
=============

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Lightmap Pack`
   :Shortcut:  :kbd:`U`

Lightmap Pack takes each of a mesh's faces, or selected faces,
and packs them into the UV bounds. Lightmaps are used primarily in realtime rendering,
where lighting information is baked onto texture maps,
when it is needed to use as much UV space as possible.
It has several options that appear in the :ref:`bpy.ops.screen.redo_last` panel:


Options
-------

Selection
   :Selected Faces: Only unwraps the selected faces.
   :All Faces: Unwraps the whole mesh.
Share Texture Space
   This is useful if mapping more than one mesh.
   It attempts to fit all of the objects' faces in the UV bounds without overlapping.
New UV Map
   If mapping multiple meshes, this option creates a new UV map for each mesh.
   See :ref:`uv-maps-panel`.
Pack Quality
   Pre-packing before the more complex Box packing.
Margin
   This controls how tightly the UV islands are packed together.
   A higher number will add more space between islands.


.. _bpy.ops.uv.follow_active_quads:

Follow Active Quads
===================

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Follow Active Quads`
   :Shortcut:  :kbd:`U`

Extrapolate UV's based on the active quad by following continuous face loops,
even if the mesh face is irregularly-shaped.

.. note::

   For a clean 90-degree unwrap it's typically best to first make sure the quad a rectangle in UV space.

   Otherwise any distortion in the active UV is extended which doesn't result in a useful grid-layout.

.. note::

   The resulting unwrap is not clamped within the UV bounds,
   you may wish to scale down the active quad's UV's so the result is in a usable range.


Options
-------

Edge Length Mode
   Method to space UV edge loops.

   :Even:
      Space all UVs evenly, where the shape of the quad in the 3D viewport is ignored.
   :Length:
      Each face's UV's are calculated based on the edge length.

      While this minimizes distortion, adjacent loops may become disconnected.
   :Length Average:
      Average space UVs edge length of each loop.

      This has the benefit of minimizing distortion, while keeping UV's connected.


.. _bpy.ops.uv.cube_project:

Cube Projection
===============

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Cube Projection`
   :Shortcut:  :kbd:`U`

Cube Projection maps the mesh onto the faces of a cube, which is then unfolded.
It projects the mesh onto six separate planes, creating six UV islands.
In the UV editor, these will appear overlapped, but can be moved.
See :doc:`Editing UVs </modeling/meshes/uv/editing>`.


Options
-------

Cube Size
   Set the size of the cube to be projected onto.
Correct Aspect
   Map UVs will take the image's aspect ratio into consideration.
   If an image has already been mapped to the :term:`Texture Space` that is non-square,
   the projection will take this into account and distort the mapping to appear correctly.
Clip to Bounds
   Any UVs that lie outside the (0 to 1) range will be clipped to that range
   by being moved to the UV space border it is closest to.
Scale to Bounds
   If the UV map is larger than the (0 to 1) range, the entire map will be scaled to fit inside.


.. _bpy.ops.uv.cylinder_project:

Cylinder Projection
===================

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Cylinder Projection`
   :Shortcut:  :kbd:`U`

Normally, to unwrap a cylinder (tube) as if you slit it lengthwise and folded it flat,
Blender wants the view to be vertical, with the tube standing "up".
Different views will project the tube onto the UV map differently, skewing the image if used.
However, you can set the axis on which the calculation is done manually.


Options
-------

Direction
   :View on Poles:
      Use when viewing from the top (at a pole) by using an axis that is straight down from the view.
   :View on Equator:
      Use if view is looking at the equator, by using a vertical axis.
   :Align to Object:
      Uses the object's transform to calculate the axis.
Align
   How to determine rotation around the pole.

   :Polar ZX: Polar 0 is on the X axis.
   :Polar ZY: Polar 0 is on the Y axis.
Pole
   How to handle faces at the poles.

   :Pinch: UVs are pinched at the poles.
   :Fan: UVs are fanned at the poles.
Preserve Seams
   Separate projections by islands isolated by seams.
Radius
   The radius of the cylinder to use.
Correct Aspect
   Map UVs will take the image's aspect ratio into consideration.
   If an image has already been mapped to a :term:`Texture Space` that is non-square,
   the projection will take this into account and distort the mapping to appear correctly.
Clip to Bounds
   Any UVs that lie outside the (0 to 1) range will be clipped to that range
   by being moved to the UV space border it is closest to.
Scale to Bounds
   If the UV map is larger than the (0 to 1) range, the entire map will be scaled to fit inside.


.. _bpy.ops.uv.sphere_project:

Sphere Projection
=================

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Sphere Projection`
   :Shortcut:  :kbd:`U`

Spherical mapping is similar to cylinder but the difference is that
a cylindrical mapping projects the UVs on a plane toward the cylinder shape,
while a spherical map takes into account the sphere's curvature,
and each latitude line becomes evenly spaced.
*Sphere Projection* is useful for spherical shapes, like eyes, planets, etc.

Recall the opening cartographer's approaching to mapping the world? Well,
you can achieve the same here when unwrapping a sphere from different points of view.
Normally, to unwrap a sphere, view the sphere with the poles at the top and bottom.
After unwrapping, Blender will give you an equirectangular projection;
the point at the equator facing you will be in the middle of the image.
A polar view will give a very different but common projection map.
Using an equirectangular projection map of the earth as the UV image
will give a good planet mapping onto the sphere.

.. figure:: /images/modeling_meshes_editing_uv_sphere-projection.png

   Using an equirectangular image with a Sphere Projection.


Options
-------

Direction
   Direction of the sphere.

   :View on Poles:
      Use when viewing from the top (at a pole) by using an axis that is straight down from the view.
   :View on Equator:
      Use if view is looking at the equator, by using a vertical axis.
   :Align to Object:
      Uses the object's transform to calculate the axis.
Align
   Select which axis is up.

   :Polar ZX: Polar 0 is on the X axis.
   :Polar ZY: Polar 0 is on the Y axis.
Pole
   How to handle faces at the poles.

   :Pinch: UVs are pinched at the poles.
   :Fan: UVs are fanned at the poles.
Preserve Seams
   Separate projections by islands isolated by seams.
Correct Aspect
   Map UVs will take the image's aspect ratio into consideration.
   If an image has already been mapped to a :term:`Texture Space` that is non-square,
   the projection will take this into account and distort the mapping to appear correctly.
Clip to Bounds
   Any UVs that lie outside the (0 to 1) range will be clipped to that range
   by being moved to the UV space border it is closest to.
Scale to Bounds
   If the UV map is larger than the (0 to 1) range, the entire map will be scaled to fit inside.


.. _bpy.ops.uv.project_from_view:

Project from View
=================

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Project from View`
   :Shortcut:  :kbd:`U`

Project from View takes the current view in the 3D Viewport and flattens the mesh as it appears.
Use this option if you are using a picture of a real object as a UV Texture for an object that
you have modeled. You will get stretching in areas where the model recedes away from you.


Options
-------

Orthographic
   Apply an orthographic projection.
Camera Bounds
   Map UVs to the camera region taking resolution and aspect into account
Correct Aspect
   Map UVs will take the image's aspect ratio into consideration.
   If an image has already been mapped to a :term:`Texture Space` that is non-square,
   the projection will take this into account and distort the mapping to appear correctly.
Clip to Bounds
   Any UVs that lie outside the (0 to 1) range will be clipped to that range
   by being moved to the UV space border it is closest to.
Scale to Bounds
   If the UV map is larger than the (0 to 1) range, the entire map will be scaled to fit inside.


Project from View (Bounds)
==========================

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Project from View (Bounds)`
   :Shortcut:  :kbd:`U`

The same as :ref:`bpy.ops.uv.project_from_view`, but with *Scale to Bounds* activated by default.


.. _bpy.ops.uv.reset:

Reset
=====

.. reference::

   :Editor:    3D Viewport and UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Reset`
   :Shortcut:  :kbd:`U`

Reset UVs maps each face to fill the UV grid, giving each face the same mapping.

If you want to use an image that is tileable,
the surface will be covered in a smooth repetition of that image,
with the image skewed to fit the shape of each individual face.
Use this unwrapping option to reset the map and undo any unwrapping (go back to the start).


## Bevel

.. _bpy.ops.mesh.bevel:
.. _tool-mesh-bevel:

***********
Bevel Edges
***********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Bevel Edges`
   :Shortcut:  :kbd:`Ctrl-B` (Bevel Edges)
   :Menu:      :menuselection:`Vertex --> Bevel Vertices`
   :Shortcut:  :kbd:`Shift-Ctrl-B` (Bevel Vertices)

The *Bevel* tool allows you to create chamfered or rounded corners on geometry.
A bevel is an effect that smooths out edges and corners.

Real world edges are very seldom exactly sharp.
Not even a knife blade edge can be considered perfectly sharp.
Most edges are intentionally beveled for mechanical and practical reasons.

Bevels are also useful for giving realism to non-organic models. In the real world,
the blunt edges on objects catch the light and change the shading around the edges.
This gives a solid, realistic look,
as opposed to un-beveled objects which can look too perfect.

.. figure:: /images/modeling_meshes_editing_edge_bevel_cubes.jpg

   Cubes with and without bevel.


Usage
=====

The *Bevel Edges* tool works only on selected edges with exactly two adjacent faces.
It will recognize any edges included in a vertex or face selection as well,
and perform the bevel the same as if those edges were explicitly selected.
In "vertex only" mode, the *Bevel Vertices* tool works on selected vertices instead of edges,
and there is no requirement about having any adjacent faces.
The *Bevel* tool smooths the edges and/or "corners" (vertices)
by replacing them with faces making smooth profiles with a specified number of *segments*
(see the options below for details about the bevel algorithm).

Use :kbd:`Ctrl-B` or a method listed above to run the tool.
Move the mouse to interactively or type a number to specify the bevel offset,
and scroll the :kbd:`Wheel` to increase or decrease the number of segments (see below).

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_bevel_example-1.png
          :width: 320px

          Selected edge before beveling.

     - .. figure:: /images/modeling_meshes_editing_edge_bevel_example-2.png
          :width: 320px

          Result of bevel (one segment).

     - .. figure:: /images/modeling_meshes_editing_edge_bevel_example-3.png
          :width: 320px

          Result of bevel (vertex only).

.. note::

   Normal (edge) beveling only works on edges that have exactly two faces
   attached to them. Vertex beveling has no such restriction.


Options
=======

Affect :kbd:`V`
   Vertices
      Only the areas near vertices are beveled, the edges remain unchanged.
   Edges
      Bevel the edges, creating intersections at vertices.

Width Type :kbd:`M`
   Selects how the *Width* value controls the size of the bevel. According to the selection, the width is:

   :Offset:
      The distance from the new edge to the original.
   :Width:
      The distance between the two new edges formed by the bevel
      (or the edges on either side of the bevel if there is more than one segment).
   :Percent:
      The percentage of the length of adjacent edges that the new edges slide.
   :Absolute:
      The exact distance along edges adjacent to the beveled edge. A difference from **Offset** is visible
      when the unbeveled edges attached to beveled edges meet at an angle besides a right angle.

   For vertex-only bevels, the Offset and Depth types measure from the original vertex.
   The Width type is measured from a new vertex to the center of the new face (as half the *Width*).

Width :kbd:`A`
   You can change the bevel width by moving the mouse towards and away from the object,
   a bit like with transform tools.
   The exact meaning of the value depends on the *Width Type* option (see above).
   As usual, the scaling can be controlled to a finer degree by holding :kbd:`Shift` to scale in 0.001 steps.
   :kbd:`LMB` finalizes the operation, :kbd:`RMB` or :kbd:`Esc` aborts the action.

   .. note::

      When multiple edges are beveled at the same time,
      it is sometimes impossible to make the width match the above definition on all edges simultaneously.
      Bevel tries to compromise in such cases.
      Sometimes turning off Loop Slide (see below) can make it easier for Bevel to make the widths as specified.

Segments :kbd:`S`
   The number of segments in the bevel can be defined by
   scrolling the mouse :kbd:`Wheel` to increase or decrease this value.
   The greater the number of segments, the smoother the bevel.
   Or press :kbd:`S` to change the number with mouse movements, as well as numeric input.

   Alternatively, you can manually enter a segment number value while using the tool,
   or in the Mesh Tool options panel after using the tool.

   .. figure:: /images/modeling_meshes_editing_edge_bevel_example-4.png
      :width: 320px

      Bevel with four segments.

Shape :kbd:`P`
   This is a number between 0 and 1 that controls the shape of the profile (side view of a beveled edge).
   The default value, 0.5, gives a circular arc (if the faces meet at right angles).
   Values less than that give a flatter profile, with 0.25 being exactly flat,
   and values less than that giving a concave bevel. Values more than 0.5 give a more convex profile.
   Similarly as *Segments* it can be set with mouse movements and numeric input after toggling :kbd:`P`.

Material Index
   The *Material* number specifies which material is assigned to the new faces created by the *Bevel* tool.
   With the default, -1, the material is inherited from the closest existing face ("closest" can be a bit ambiguous).
   Otherwise, the number is the slot index of the material to use for all newly created faces.

Harden Normals :kbd:`H`
   When enabled, the per-vertex face normals of the bevel faces are adjusted to
   match the surrounding faces, and the normals of the surrounding faces are not affected.
   This will keep the surrounding faces flat (if they were before),
   with the bevel faces shading smoothly into them. For this effect to work,
   a mesh must have :ref:`custom split normals <modeling_meshes_normals_custom>`.
   As a convenience, that option will be enabled for you if it is not already when you enable Harden Normals here.

Clamp Overlap :kbd:`C`
   Limits the width of each beveled edge so that edges cannot cause
   overlapping intersections with other geometry.

Loop Slide
   If there are un-beveled edges along with beveled edges into a vertex,
   the bevel tries to slide along those edges when possible.
   Turning the option off can lead to more even bevel widths.

Mark
   Seams :kbd:`U`
      If a seam edge crosses a non-seam one and you bevel all of them,
      this option will maintain the expected propagation of seams.
   Sharp :kbd:`K`
      Similar to Mark Seams, but for sharp edges.

Miter Outer :kbd:`O`
   A *miter* is formed when two beveled edges meet at an angle.
   On the side where the angle is greater than 180 degrees, if any, it is called an *outer miter*.
   This option specifies the pattern that Blender uses at an outer miter.

   :Sharp:
      Edges meet at a sharp point, with no extra vertices introduced on the edges.
   :Patch:
      Edges meet at a sharp point but in addition, two extra vertices are introduced near the point
      so that the edges and faces at the vertex may be less pinched together than
      what occurs in the *Sharp* case.
   :Arc:
      Two vertices are introduced near the intersection, and a curved arc joins them together.
      The *Spread* slider controls how far the new vertices are from the intersection.
      The *Profile* curve widget controls the shape of the arc.

   The current choices are shown in this diagram, where the outer miter is along the horizontal surface.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-2.png
             :width: 320px

             Sharp outer miter.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-3.png
             :width: 320px

             Patch outer miter.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-4.png
             :width: 320px

             Arc outer miter.

Inner :kbd:`I`
   An *Inner Miter* is formed when the angle between two beveled edges is less than 180 degrees.
   This option specifies the pattern Blender uses at an inner miter.
   The options are the same as for Outer Miter, except that *Patch* makes no sense and is therefore omitted.
   Inner miters are shown in the following diagram, where two inner miters are on the vertical surfaces.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-5.png
             :width: 200px

             Sharp inner miter.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-6.png
             :width: 200px

             Arc inner miter.

Spread
   The value used to spread extra vertices apart for *Outer* and *Inner Miters*.
   This option is available when Miter Inner is set to Arc.

Intersection Type :kbd:`N`
   When more than two beveled edges meet at a vertex, a mesh is created as
   a way to complete the intersection between the generated geometry.
   This option controls the method used to create that mesh.

   :Grid Fill:
      The default method for building intersections, useful when a smooth continuation of
      the bevel profile is desired. Without *Custom Profile* enabled, the curve of the profile
      continues through the intersection, but with a custom profile it just creates a smooth grid within
      the intersection's boundary.
   :Cutoff:
      Creates a cutoff face at the end of each beveled edge coming into the vertex. This is most
      useful for custom profiles when the new intersection is too complex for a smooth grid fill.

      With a three way intersection, when the inner corners of the cutoff profiles faces meet at
      the same location, no center face is created.

      The direction of the cutoff faces depends on the original vertex's normal.

   .. list-table:: Intersection method options.

      * - .. figure:: /images/modeling_meshes_editing_edge_bevel_vmesh-1.png
             :width: 200px

             Grid fill intersection method.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_vmesh-2.png
             :width: 200px

             Three way cutoff intersection where the inner vertices are merged.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_vmesh-3.png
             :width: 200px

             Cutoff intersection method with a center face.

Face Strength
   Set *Face Strength* on the faces involved in the bevel, according to the specified mode.
   This can be used in conjunction with
   a :doc:`Weight Normals Modifier </modeling/modifiers/modify/weighted_normal>`
   (with the *Face Influence* option checked).

   :None:
      Do not set face strength.
   :New:
      Set the face strength of new faces along edges to *Medium*,
      and the face strength of new faces at vertices to *Weak*.
   :Affected:
      In addition to those set for the *New* case,
      also set the faces adjacent to new faces to have strength *Strong*.
   :All:
      In addition to those set for the *Affected* option,
      also set all the rest of the faces of the model to have strength *Strong*.

Profile Type :kbd:`Z`
   :Superellipse:
      Creates a bevel with a uniform concave or convex curve.

   :Custom:
      .. figure:: /images/modeling_modifiers_generate_bevel_profile-widget.png
         :align: right
         :width: 300px

         The custom profile widget.

      This :ref:`ui-curve-widget` allows the creation of a user-defined profile with more complexity than
      with the single profile parameter. The modal tool allows toggling the custom profile,
      but the shape of the profile is only editable in the options panel after the operation is confirmed.

      The profile starts at the bottom right of the widget and ends at the top left, as if it
      were between two edges intersecting at a right angle. Control points are created in the widget and
      then the path is sampled with the number of segments from the Bevel modifier.

      .. note::

         The *Profile* curve widget stays active when miters are enabled
         because it still controls the shape of the miter profiles.

      Presets
         The *Support Loops* and *Steps* presets are built dynamically depending on
         the number of segments in the bevel. If the number of segments is changed,
         the preset will have to be re-applied.

      Sampling
         Samples will first be added to each control point, then if there are enough samples,
         they will be divided evenly between the edges. The *Sample Straight Edges* option toggles whether
         the samples are added to edges with sharp control points on either side. If there aren't enough samples
         to give each edge the same number of samples, they will just be added to the most curved edges.
         So it is recommended to use at least as many segments as there are control points.


Examples
========

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_bevel_example-5.png
          :width: 320px

          Result of beveling multiple edges.

     - .. figure:: /images/modeling_meshes_editing_edge_bevel_example-6.png
          :width: 320px

          Another example of beveling multiple edges.

     - .. figure:: /images/modeling_meshes_editing_edge_bevel_example-7.png
          :width: 320px

          An example using Profile=0.150.

.. seealso::

   The :doc:`Bevel Modifier </modeling/modifiers/generate/bevel>`
   is a non-destructive alternative to the Bevel tool.


## Bridge Edge Loops

.. _bpy.ops.mesh.bridge_edge_loops:
.. _modeling-meshes-editing-bridge-edge-loops:

*****************
Bridge Edge Loops
*****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Bridge Edge Loops`

*Bridge Edge Loops* connects multiple edge loops with faces.

Connect Loops
   :Open Loop: Loops connected with open ends.
   :Closed Loop: Tries to connect to a circular loop (where the start and end are merged).
   :Loop Pairs: Connects each even count of loops individually.
Merge
   Merges edge loops rather than creating a new face.
Merge Factor
   Which edge loop the edges are merged to, a value of 0.5 will merge at a half-way point.
Twist
   Determines which vertices in both loops are connected to each other.
Number of Cuts
   The number of intermediate edge loops used to bridge the distance between two loops.
Interpolation
   Linear, Blend Path, Blend Surface
Smoothness
   Smoothness of the *Blend Path* and *Blend Surface*.
Profile Factor
   How much intermediary new edges are shrunk/expanded.
Profile Shape
   The shape of the new edges.
   See the :ref:`Proportional Editing <bpy.types.ToolSettings.proportional_edit_falloff>` page
   for a description of each option.


Examples
========

Simple example showing two closed edge loops.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_simple-before.png
          :width: 320px

          Input.

     - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_simple-after.png
          :width: 320px

          Bridge result.

Example of the Bridge tool between edge loops with different numbers of vertices.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_uneven-before.png
          :width: 320px

          Input.

     - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_uneven-after.png
          :width: 320px

          Bridge result.

Example using the Bridge tool to cut holes in face selections and connect them.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_faces-before.png
          :width: 320px

          Input.

     - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_faces-after.png
          :width: 320px

          Bridge result.

Example showing how Bridge tool can detect multiple loops and connect them in one step.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_multi-before.png
          :width: 320px

          Input.

     - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_multi-after.png
          :width: 320px

          Bridge result.

Example of the subdivision option and surface blending with UVs.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_advanced-before.png
          :width: 320px

          Input.

     - .. figure:: /images/modeling_meshes_editing_edge_bridge-edge-loops_advanced-after.png
          :width: 320px

          Bridge result.


## Edge Data


*********
Edge Data
*********

Edges can have several different properties that affect how certain other tools affect the mesh.

.. _bpy.ops.transform.edge_crease:

Edge Crease
===========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Edge Crease`
   :Shortcut:  :kbd:`Shift-E`

This operator interactively sets the :ref:`Edge Crease <modeling-edges-crease-subdivision>` amount
by moving the mouse (or typing a value with the keyboard).
Selecting more than one edge will adjust the mean (average) crease value.
A negative value will subtract from the actual crease value, if present.
To clear the crease edge property, enter a value of -1.


.. _bpy.ops.transform.edge_bevelweight:

Edge Bevel Weight
=================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Edge Bevel Weight`

Sets the value for the ``bevel_weight_edge`` attribute, a value between (0.0 to 1.0).

This attribute is used by the :doc:`Bevel Modifier </modeling/modifiers/generate/bevel>`
to control the bevel intensity of the edges.

This operator enters an interactive mode (a bit like transform tools),
where by moving the mouse (or typing a value with the keyboard)
you can set the bevel weight of selected edges. If more than one edge is selected,
this operator alters the average weight of the edges.

.. seealso::

   :ref:`Vertex Bevel Weight <modeling-vertex-bevel-weight>`


.. _bpy.ops.mesh.mark_seam:

Mark Seam & Clear Seam
======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Mark Seam/Clear Seam`

These operators set or unset this mark for selected edges.
Seams are a way to create separations, "islands", in UV maps.
See the :ref:`UV Mapping section <editors-uv-index>` for more details.


.. _bpy.ops.mesh.mark_sharp:

Mark Sharp & Clear Sharp
========================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Mark Sharp/Clear Sharp`

Signifies the selected edge(s) as being "sharp".
This edge attribute can either be set (mark) or unset (clear).

This influences the rendering of :ref:`modeling-meshes-structure-normals`
to appear flat if smooth shading is enabled for the connecting face or object.
This attribute can also be used by many modifiers or operators to mask their effect.

Internally, this uses the :ref:`sharp edge attribute <geometry-nodes_builtin-attributes>`.


.. _bpy.ops.mesh.set_sharpness_by_angle:

Set Sharpness by Angle
======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Set Sharpness by Angle`

Sets the :ref:`sharp edge attribute <geometry-nodes_builtin-attributes>`
based on the angle between neighboring faces.

Angle
   Maximum angle between face normals that will be considered as smooth.
Extend
   Add new sharp edges without clearing existing sharp edges.


## Edge Slide

.. _bpy.ops.transform.edge_slide:
.. _modeling-meshes-editing-edge-slide:
.. _tool-mesh-edge_slide:

**********
Edge Slide
**********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Edge Slide`
   :Shortcut:  :kbd:`G`, :kbd:`G`

Slides one or more edges across adjacent faces with a few restrictions involving the selection
of edges (i.e. the selection *must* define a valid loop, see below).

Even :kbd:`E`
   Forces the edge loop to match the shape of the adjacent edge loop.
   You can flip to the opposite vertex using :kbd:`F`.
Flipped :kbd:`F`
   When Even mode is active, this flips between the two adjacent edge loops the active edge loop will match.
Clamp :kbd:`Alt` or :kbd:`C`
   Toggle clamping the slide within the edge extents.
Factor
   Determines the amount of slide performed.
   Negative values correspond to slides toward one face, while positive ones, refer to the other one.
   It is also displayed in the 3D Viewport footer.
Mirror Editing
   Lets you propagate the operation to the symmetrical elements of the mesh (if present, in local X direction).
Correct UVs
   Corrects the corresponding UV coordinates, if these exist, to avoid image distortions.


Usage
=====

By default, the position of vertices on the edge loop move as a percentage of the distance
between their original position and the adjacent edge loop, regardless of the edges' lengths.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_edge-slide_before.png
          :width: 320px

          Selected edge loop.

     - .. figure:: /images/modeling_meshes_editing_edge_edge-slide_after.png
          :width: 320px

          Repositioned edge loop.


Even Mode
---------

*Even* mode keeps the shape of the selected edge loop the same as one of the edge loops adjacent to it,
rather than sliding a percentage along each perpendicular edge.

In *Even* mode, the tool shows the position along the length of the currently selected edge
which is marked in yellow, from the vertex that has an enlarged red marker.
Movement of the sliding edge loop is restricted to this length. As you move the mouse
the length indicator in the header changes showing where along the length of the edge you are.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_edge-slide_even.png
          :width: 320px

          Even Mode enabled.

     - .. figure:: /images/modeling_meshes_editing_edge_edge-slide_even-flip.png
          :width: 320px

          Even Mode with Flip enabled.

Moving the mouse moves the selected edge loop towards or away from the start vertex,
but the loop line will only move as far as the length of the currently selected edge,
conforming to the shape of one of the bounding edge loops.


Limitations & Workarounds
-------------------------

There are restrictions on the type of edge selections that can be operated upon.
Invalid selections are:

Loop Crosses Itself
   This means that the tool could not find any suitable faces that were adjacent to the selected edge(s).
   An example that shows this is selecting two edges that share the same face.
   A face cannot be adjacent to itself.
Multiple Edge Loops
   The selected edges are not in the same edge loop, which means they do not have a common edge.
   You can minimize this error by always selecting edges end-to-end or in a "chain".
   If you select multiple edges just make sure they are connected.
   This will decrease the possibility of getting looping errors.
Border Edges
   When a single edge was selected in a single-sided object.
   An edge loop cannot be found because there is only one face.
   Remember, edge loops are loops that span two or more faces.

A general rule of thumb is that if multiple edges are selected they should be connected end-to-end
such that they form a continuous chain. This is *literally* a general rule because you
can still select edges in a chain that are invalid because some of the edges in the chain are
in different edge loops.


## Extrude Edges

.. _bpy.ops.mesh.extrude_edges_move:

*************
Extrude Edges
*************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Extrude Edges`
               :menuselection:`Mesh --> Extrude --> Extrude Edges`
   :Shortcut:  :kbd:`E`

Extrude edges as individual edges.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_extrude-edges_before.png
          :width: 320px

          Edge selected.

     - .. figure:: /images/modeling_meshes_editing_edge_extrude-edges_after.png
          :width: 320px

          Edge extruded.


## Index


##################
  Edge Operators
##################

.. toctree::
   :maxdepth: 2

   extrude_edges.rst
   bevel.rst
   bridge_edge_loops.rst
   screw.rst
   subdivide.rst
   subdivide_edge_ring.rst
   unsubdivide.rst
   rotate_edge.rst
   edge_slide.rst
   offset_edge_slide.rst
   loopcut_slide.rst
   edge_data.rst


## Loopcut Slide

.. _bpy.ops.mesh.loopcut_slide:

******************
Loop Cut and Slide
******************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Loop Cut and Slide`
   :Shortcut:  :kbd:`Ctrl-R`

*Loop Cut and Slide* splits a loop of faces by inserting a new edge loop intersecting the chosen edge.


Usage
=====

The tool is interactive and has two steps:

#. Pre-Visualizing the Cut

   After the tool is activated, move the cursor over a desired edge.
   The cut to be made is marked with a magenta colored line as you move the mouse over the various edges.
   The to be created edge loop stops at the poles (tris and n-gons) where the existing face loop terminates.

#. Sliding the new Edge Loop

   Once an edge is chosen via :kbd:`LMB`,
   you can move the mouse along the edge to determine where the new edge loop will be placed.
   This is identical to the :ref:`Edge Slide tool <modeling-meshes-editing-edge-slide>`.
   Clicking :kbd:`LMB` again confirms and makes the cut at the pre-visualized location,
   or clicking :kbd:`RMB` forces the cut to exactly 50%.
   This step is skipped when using multiple edge loops (see below).

.. list-table::

   * - .. figure:: /images/modeling_meshes_tools_loop_before.png

          Mesh before inserting edge loop.

     - .. figure:: /images/modeling_meshes_tools_loop_preview.png

          Preview of edge loop location.

     - .. figure:: /images/modeling_meshes_tools_loop_placement.png

          Interactive placement of edge loop between adjacent loops.


.. _modeling-meshes-editing-edge-loopcut-slide-options:

Options
=======

These options are available while the tool is in use, and later in
the :ref:`bpy.ops.screen.redo_last` panel.

Number of Cuts :kbd:`Wheel` or :kbd:`PageUp` / :kbd:`PageDown`
   After activating the tool, but before confirming initial loop location,
   you can increase and decrease the number of cuts to create,
   by entering a number with the keyboard, scrolling :kbd:`Wheel` or using :kbd:`PageUp` and :kbd:`PageDown`.

   .. note::

      When creating multiple loops, these cuts are uniformly distributed in the original face loop,
      and you will *not* be able to control their positions.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_editing_edge_loopcut-slide_multicut.png

             Preview of multiple edge loops.

        - .. figure:: /images/modeling_meshes_editing_edge_loopcut-slide_multicut-after.png

             Result of using multiple cuts.

Smoothness :kbd:`Alt-Wheel`
   Smoothing causes edge loops to be placed in an interpolated position, relative to the face it is added to,
   causing them to be shifted outwards or inwards by a given percentage,
   similar to the *Subdivide Smooth* tool. When not using smoothing,
   new vertices for the new edge loop are placed exactly on the preexisting edges.
   This keeps subdivided faces flat, but can distort geometry,
   particularly when using :doc:`Subdivision Surfaces </modeling/modifiers/generate/subdivision_surface>`.
   Smoothing can help maintain the curvature of a surface once it is subdivided.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_editing_edge_loopcut-slide_unsmooth.png

             Added edge loops without smoothing.

        - .. figure:: /images/modeling_meshes_editing_edge_loopcut-slide_smooth.png

             Same edge loops, but with smoothing value.

Falloff
   Falloff type for *Smoothness*, changes the shape of the profile.

Factor
   Position of the edge loop relative to the surrounding edge loops.

Even :kbd:`E`
   Only available for single edge loops.
   This matches the shape of the edge loop to one of the adjacent edge loops.
   (See :ref:`Edge Slide tool <modeling-meshes-editing-edge-slide>` for details.)

Flip :kbd:`F`
   When Even is enabled, this flips the target edge loop to match.
   (See :ref:`Edge Slide tool <modeling-meshes-editing-edge-slide>` for details.)

Clamp
   Clamp within the edge extents.

Correct UVs
   Corrects the corresponding UV coordinates, if these exist, to avoid image distortions.


## Offset Edge Slide

.. _bpy.ops.mesh.offset_edge_loops_slide:

*****************
Offset Edge Slide
*****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Offset Edge Slide`
   :Shortcut:  :kbd:`Shift-Ctrl-R`

Add two edge loops on either side of selected loops.

Cap Endpoint
   Extends the loop by creating triangles at endpoints.
Factor
   Location of the loop relative to the center loop and the outside edge loops.
Even
   Only available for single edge loops.
   This matches the shape of the edge loop to one of the adjacent edge loops.
   (See :ref:`Edge Slide tool <modeling-meshes-editing-edge-slide>` for details.)
Flipped
   When Even is enabled, this flips the target edge loop to match.
   (See :ref:`Edge Slide tool <modeling-meshes-editing-edge-slide>` for details.)
Clamp
   Clamp within the edge extents.
Correct UVs
   Correct UV coordinates when transforming.


## Rotate Edge

.. _modeling-meshes-editing-edges-rotate:
.. _bpy.ops.mesh.edge_rotate:

***********
Rotate Edge
***********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Rotate Edge CW / Rotate Edge CCW`

Rotating an edge clockwise (CW) or counterclockwise (CCW) spins an edge between two faces around their vertices.
This is very useful for restructuring a mesh's topology.

The tool operates on selected edges or the shared edge between selected faces.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_rotate-edge_face-mode1.png
          :width: 320px

          Two adjacent faces selected.

     - .. figure:: /images/modeling_meshes_editing_edge_rotate-edge_face-mode2.png
          :width: 320px

          Selected edge rotated.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_rotate-edge_flip-before.png
          :width: 320px

          Selected edge.

     - .. figure:: /images/modeling_meshes_editing_edge_rotate-edge_flip-after.png
          :width: 320px

          Edge, rotated CW.

.. warning::

   To rotate an edge based on faces you must select adjacent face pairs,
   otherwise Blender notifies you with an error message,
   *"Could not find any select edges that can be rotated"*. Using either *Rotate Edge CW*
   or *Rotate Edge CCW* will produce exactly the same results as if you had
   selected the common edge.


## Screw

.. _bpy.ops.mesh.screw:

*****
Screw
*****

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Screw`

The *Screw* operator extrudes geometry along a helix. You can use it to create screws, springs,
sea shells and so on.

While it's similar to the :doc:`Screw Modifier </modeling/modifiers/generate/screw>`,
there are some important differences:

.. list-table::
   :header-rows: 1

   * - Screw operator
     - Screw modifier
   * - Works in world space.
     - Works in object space.
   * - Extrudes only the selected geometry.
     - Extrudes all geometry.
   * - The centerpoint can be specified manually.
     - The centerpoint is always the object's origin.
   * - One revolution is always 360°.
     - The angle can be chosen freely.
   * - The height offset of each revolution is calculated automatically based on the geometry.
     - The height offset must be specified manually.
   * - Each revolution can also have a radial offset away from/towards the central axis
       (again determined by the geometry).
     - The radius stays constant.

As described above, the Screw operator automatically determines the height offset and radial
offset to apply after each revolution. It does this by looking for the endpoints of an open profile --
a series of connected edges that don't form a closed loop. The geometry is extruded so that the
profile's top vertex in one revolution will coincide with the bottom vertex in the next.

The most common use case is extruding such an open profile. You're not limited to this, however.
As long as there is one open profile in the selection -- even just a single loose edge --
you can also extrude closed profiles and even geometry with faces.

You can see some examples below.

.. list-table::

   * - .. _fig-mesh-screw-wood:

       .. figure:: /images/modeling_meshes_editing_edge_screw_example-shell.png

          Wood Screw.

     - .. _fig-mesh-screw-spring:

       .. figure:: /images/modeling_meshes_editing_edge_screw_example-spring.png

          Spring.


Usage
=====

First, make sure you have an open profile in your mesh. If you want to extrude anything else
(such as one or more circles), you should create an open profile next to it.

Once that's done, enter *Edit Mode* and select the geometry you want to extrude,
making sure to include exactly one open profile. If you have fewer or more, the operator will
fail with the error "You have to select a string of connected vertices too."

Make sure the :doc:`/editors/3dview/3d_cursor` is at the centerpoint around which you want
the geometry to turn. Also make sure that the vertical axis on your screen matches the direction
of the axis around which it should turn. The most common example is turning around the global Z
axis: for that, you'd place the 3D Cursor at the world origin and switch to an orthographic side view.

Now you're ready to run the operator: open the *Edge* menu (by clicking it in the 3D Viewport's
header or pressing :kbd:`Ctrl-E`) and click *Screw*.

You can change the number of steps and turns in the
:ref:`Adjust Last Operation <bpy.ops.screen.redo_last>` panel.

If you only created an open profile to guide the extrusion (not because you wanted its geometry),
you can select its extruded faces by hovering over one and pressing :kbd:`L`,
then delete them by pressing :kbd:`X` or :kbd:`Delete`.


Options
=======

.. figure:: /images/modeling_meshes_editing_edge_screw_interactive-panel.png

   Screw panel (in Edit Mode).

Steps
   The number of extrusions to be done for each 360° turn.
Turns
   The number of turns to create.
Center X, Y, Z
   The worldspace coordinates of the centerpoint around which to spin the geometry.
   Initially this is the location of the 3D Cursor.
Axis X, Y, Z
   The direction vector around which to spin the geometry.
   Initially this is the screen-space vertical axis (so the global Z axis when in a
   side view or the global Y axis when in top view). By inverting the *Axis*,
   you can flip between going clockwise and counterclockwise.

.. tip::
   You can use the :doc:`Align View to Active </editors/3dview/navigate/align>`
   menu item to align the viewport, and thereby the *Axis*, to a certain item
   in the scene.

Notice that the *Axis* only determines how the geometry spins "horizontally" around
the centerpoint. It doesn't determine how the geometry moves "vertically."
Instead, the geometry always moves by a distance and direction given by the endpoints
of the open profile, and goes downward in the object's local space.


Examples
========

Creating a Spring
-----------------

First, let's create a circle to serve as the spring's cross section:

#. Open Blender and delete the default Cube.
#. Add a circle by pressing :kbd:`Shift-A` and selecting :menuselection:`Mesh --> Circle`.
#. Set the *Location X* property of this new object to -3 and its *Rotation X* property to 90°.
#. Enter *Edit Mode* by pressing :kbd:`Tab`.
#. Switch to the *Front Orthographic* view by pressing :kbd:`Numpad1`.

.. figure:: /images/modeling_meshes_editing_edge_screw_circle-moved-x-3units.png

   Extrusion profile created.

Next, let's create a vertical line to specify the distance between spring loops:

#. Deselect all vertices by clicking on an empty space or pressing :kbd:`Alt-A`.
#. Click :kbd:`Ctrl-RMB` twice to create two vertices connected by an edge.
#. Select both vertices and press :kbd:`S X 0 Return` to ensure they have the same X coordinate.
   (This is necessary to keep the spring's radius constant.)

.. figure:: /images/modeling_meshes_editing_edge_screw_spring-profile-ready.png

   Guide profile created.

Now, we're ready to create the spring:

#. Select both the circle and the line by pressing :kbd:`A`.
#. Click :menuselection:`Edge --> Screw`.
#. Adjust the *Steps* and *Turns* to your liking.
#. Try changing *Axis Z* to -1 and see that this makes the spring turn the other way.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_screw_spring-counterclockwise.png

          Counterclockwise direction.

     - .. figure:: /images/modeling_meshes_editing_edge_screw_spring-clockwise.png

          Flipped to Clockwise direction.

You can get some interesting results by making the *Axis* diagonal (e.g. keeping *Axis Z*
at -1 and setting *Axis X* to 1). Notice that each individual spring loop is inclined by 45°,
but that after each loop, we still go down vertically (in the direction of the guide line).

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_screw_angular-vector-example1.png

     - .. figure:: /images/modeling_meshes_editing_edge_screw_angular-vector-example2.png


Creating a Screw Spindle
------------------------

The Screw operator is perfectly suited for creating helixes without any gaps between the turns.

#. Open Blender and enter *Edit Mode* for the default cube.
#. Delete all vertices by pressing :kbd:`X` or :kbd:`Delete`.
#. Switch to the *Front Orthographic* view by pressing :kbd:`Numpad1`.
#. Click :kbd:`Ctrl-RMB` three times to create a profile like the one below.
#. Select the two vertices closest to the global Z axis and press :kbd:`S X 0 Return`
   to ensure they have the same X coordinate.
#. Select all three vertices and click :menuselection:`Edge --> Screw`.
#. Adjust the *Steps* and *Turns* to your liking.

.. list-table::

   * - .. _fig-mesh-screw-spindle:

       .. figure:: /images/modeling_meshes_editing_edge_screw_perfect-spindle-profile.png

          Profile for a screw spindle.

     - .. _fig-mesh-screw-generated-mesh:

       .. figure:: /images/modeling_meshes_editing_edge_screw_generated-perfect-spindle.png

          Result after running the Screw operator.

You can also create more interesting shapes, like this spiral "staircase":

.. list-table:: Ramp.

   * - .. figure:: /images/modeling_meshes_editing_edge_screw_ramp-like-profile.png

          Profile.

     - .. figure:: /images/modeling_meshes_editing_edge_screw_ramp-like-generated.png

          Generated mesh.


Creating a Screw Tip
--------------------

Until now, we've always made sure that the first and last vertex of the profile
have the same X coordinate, thereby keeping the radius of the helix constant.
However, nothing stops you from using different X coordinates and having the helix
shrink/expand along its height.

.. list-table::

   * - .. _fig-mesh-screw-start:

       .. figure:: /images/modeling_meshes_editing_edge_screw_profile-with-vector-angle.png

          Profile.

     - .. _fig-mesh-screw-start-mesh:

       .. figure:: /images/modeling_meshes_editing_edge_screw_generated-with-base-vector-angle.png

          Generated.


## Subdivide

.. _bpy.ops.mesh.subdivide:

*********
Subdivide
*********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Subdivide`

Subdividing splits selected edges and faces by cutting them in half or more,
adding new vertices, and subdividing accordingly the faces involved.
It adds resolution to the mesh by divide faces or edges into smaller units.

This process follows a few rules, depending on the settings:

- When only one edge of a face is selected (Triangle mode),
  triangles are subdivided into two triangles, and quads, into three triangles.
- When two edges of a face are selected:

  - If the face is a triangle, a new edge is created between the two new vertices,
    subdividing the triangle in a triangle and a quad.
  - If the face is a quad, and the edges are neighbors,
    there have *three* possible behaviors to divide the quad,
    depending on the setting of *Quad Corner Type* (see below for details).
  - If the face is a quad, and the edges are opposite,
    the quad is just subdivided in two quads by the edge linking the two new vertices.

- When three edges of a face are selected:

  - If the face is a triangle, this means the whole face is selected and
    it is then subdivided in four smaller triangles.
  - If the face is a quad, first the two opposite edges are subdivided as described above.
    Then, the "middle" edge is subdivided, affecting its new "sub-quad" as described above for only one edge.
- When a face of a :term:`Quad` is selected, the face is subdivided into four smaller quads.
- When a face of an :term:`N-gon` is selected,
  the individual edges will be subdivided but the face will stay unsubdivided.


Options
=======

These options are available in the *Tool* panel after running the tool:

Number of Cuts
   Specifies the number of cuts per edge to make.
   By default this is 1, cutting edges in half. A value of 2 will cut it into thirds, and so on.
Smoothness
   Displaces subdivisions to maintain approximate curvature.
   The effect is similar to the way the :doc:`/modeling/modifiers/generate/subdivision_surface`
   might deform the mesh.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_smooth-before.png
             :width: 200px

             Mesh before subdividing.

        - .. figure:: /images/modeling_meshes_editing_edge_subdivide_smooth-none.png
             :width: 200px

             Subdivided with no smoothing.

        - .. figure:: /images/modeling_meshes_editing_edge_subdivide_smooth-after.png
             :width: 200px

             Subdivided with smoothing of 1.

Quad/Tri Mode
   Forces subdivide to create triangles or quads instead of n-gons (see examples below).
   This mode doesn't allow the use of *Straight Cut* on quad corners.
Quad Corner Type
   Controls the way quads with only two adjacent selected edges are subdivided.

   :Fan:
      The quad is subdivided in a fan of four triangles,
      the common vertex being the one opposite to the selected edges.
   :Inner Vertices:
      The selected edges are subdivided, then an edge is created between
      the two new vertices, creating a small triangle.
      This edge is also subdivided,
      and the "inner vertex" thus created is linked by another edge to the one opposite
      to the original selected edges. All this results in a quad subdivided in a triangle and two quads.
   :Path:
      First an edge is created between the two opposite ends of the selected edges,
      dividing the quad in two triangles. Then, the same goes for the involved triangle as described above.
   :Straight Cut:
      The selected edges are subdivided, then an edge is created between
      the two new vertices, creating a small triangle and n-gon.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-fan2.png
             :width: 200px

             Fan cut type.

        - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-innervert.png
             :width: 200px

             Inner Vertices cut type.

        - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-path.png
             :width: 200px

             Path cut type.

Fractal
   Displaces the vertices in random directions after the mesh is subdivided.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_fractal-before.png
             :width: 200px

             Plane before subdivision.

        - .. figure:: /images/modeling_meshes_editing_edge_subdivide_fractal-none.png
             :width: 200px

             Regular subdivision.

        - .. figure:: /images/modeling_meshes_editing_edge_subdivide_fractal-after1.png
             :width: 200px

             Same mesh with fractal added.

Along Normal
   Causes the vertices to move along their normals, instead of random directions.

   .. figure:: /images/modeling_meshes_editing_edge_subdivide_fractal-along-normal.png
      :width: 200px

      Along normal set to 1.

Random Seed
   Changes the random seed of the *Fractal* noise function, producing a different result for each seed value.

   .. figure:: /images/modeling_meshes_editing_edge_subdivide_fractal-after2.png
      :width: 200px

      Same mesh with a different seed value.


Examples
========

Below are several examples illustrating the various possibilities of the *Subdivide*
and *Subdivide Multi* tools. Note the selection after subdivision.

.. figure:: /images/modeling_meshes_editing_edge_subdivide_before.png
   :width: 300px

   The sample mesh.


One Edge
--------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_one-edge.png
          :width: 250px

          One Edge.

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_one-edge-tri.png
          :width: 250px

          Quad/Tri Mode.


Two Tri Edges
-------------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-tri.png
          :width: 250px

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-tri-tri.png
          :width: 250px

          Quad/Tri Mode.


Two Opposite Quad Edges
-----------------------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-opposite.png
          :width: 250px

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-opposite-tri.png
          :width: 250px

          Quad/Tri Mode.


Two Adjacent Quad Edges
-----------------------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-fan2.png
          :width: 250px

          Fan cut type.

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-fan.png
          :width: 250px

          Quad/Tri Mode.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-innervert.png
          :width: 250px

          Inner vertices cut type.

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-innervert-tri.png
          :width: 250px

          Quad/Tri Mode.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-path.png
          :width: 250px

          Path cut type.

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_two-edges-quad-path-tri.png
          :width: 250px

          Quad/Tri Mode.


Three Edges
-----------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_three-edges.png
          :width: 250px

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_three-edges-tri.png
          :width: 250px

          Quad/Tri Mode.


Tri
---

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_three-edges-tri2.png
          :width: 250px

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_three-edges-tri-tri.png
          :width: 250px

          Quad/Tri Mode.


Quad/Four Edges
---------------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_four-edges.png
          :width: 250px

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_four-edges-tri.png
          :width: 250px

          Quad/Tri Mode.


Multiple Cuts
-------------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_edge_subdivide_tri-multi.png
          :width: 250px

          Triangle with two cuts.

     - .. figure:: /images/modeling_meshes_editing_edge_subdivide_quad-multi.png
          :width: 250px

          Quad with two cuts.


## Subdivide Edge Ring

.. _bpy.ops.mesh.subdivide_edgering:

*******************
Subdivide Edge-Ring
*******************

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Edge --> Subdivide Edge-Ring`

Take an edge ring, and subdivide with interpolation options.

Options
   See :ref:`Bridge Edge Loops <modeling-meshes-editing-bridge-edge-loops>`.


## Unsubdivide

.. _bpy.ops.mesh.unsubdivide:
.. _mesh-unsubdivide:

************
Un-Subdivide
************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Un-Subdivide`

Un-subdivide functions as the reverse of subdivide by attempting to remove edges
that were the result of a subdivide operation.
If additional editing has been done after the subdivide operation,
unexpected results may occur.

Iterations
   How many subdivisions to remove.


## Beautify Faces

.. _bpy.ops.mesh.beautify_fill:

**************
Beautify Faces
**************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Beautify Faces`

*Beautify Faces* works only on selected existing faces.
It rearrange selected triangles to obtain more "balanced" ones (i.e. less long thin triangles).

Max Angle
   An angle delimiter option to limit edge rotation to flat surfaces.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_face_beautify-faces_before.png
          :width: 320px

          Text converted to a mesh.

     - .. figure:: /images/modeling_meshes_editing_face_beautify-faces_after.png
          :width: 320px

          Result of Beautify Faces.


## Extrude Faces

.. _bpy.ops.mesh.extrude_indiv:
.. _bpy.ops.view3d.edit_mesh_extrude_individual_move:
.. _bpy.ops.view3d.edit_mesh_extrude_move_normal:

*************
Extrude Faces
*************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Extrude Faces`,
               :menuselection:`Mesh --> Extrude --> Extrude Faces`
   :Shortcut:  :kbd:`E`

*Extrude Faces* duplicate faces, while keeping the new geometry connected with the original vertices.

.. list-table::

   * - .. figure:: /images/modeling_meshes_tools_extrude-region_vert.png
          :width: 320px

          Single vertex extruded.

     - .. figure:: /images/modeling_meshes_tools_extrude-region_edge.png
          :width: 320px

          Single edge extruded.

This tool is of paramount importance for creating new geometry.
It allows you to create parallelepipeds from rectangles and cylinders from circles,
as well as easily creating such things as tree limbs.

The axis on which faces are extruded along can be set interactively.
Faces are extruded by default along their averaged normal.
The extrusion can be limited to a single axis by specifying an axis;
see :doc:`/scene_layout/object/editing/transform/control/axis_locking`.

The extrude tools differentiate in how the new geometry is connected in itself.
Only the border loop gets extruded.
The inner region of the selection gets moved unchanged with the extrusion.

.. list-table::

   * - .. figure:: /images/modeling_meshes_tools_extrude-region_face-before.png
          :width: 200px

          Selected face.

     - .. figure:: /images/modeling_meshes_tools_extrude-region_face-after.png
          :width: 200px

          During extrude.

     - .. figure:: /images/modeling_meshes_tools_extrude-region_face-after-zaxis.png
          :width: 200px

          Set to Z axis.

Flip Normals
   Only the *normals* of the new faces created from the extrusion will be flipped.

Dissolve Orthogonal Edges
   Removes and connects edges whose faces form a flat surface and intersect new edges.

Orientation
   Aligns the transformation axes to a specified orientation constraint.
   See :doc:`Transform Orientations </editors/3dview/controls/orientation>` for more information.

Proportional Editing
   The extruded face will affect nearby geometry.
   See :doc:`Proportional Editing </editors/3dview/controls/proportional_editing>` for a full reference.

   .. note::

      Even with the *Proportional Size* set to it's minimum,
      it will extrude the selected face as well as the new geometry and they will be layered on top of each other.


## Extrude Faces Normal

.. _bpy.ops.view3d.edit_mesh_extrude_move_shrink_fatten:

***************************
Extrude Faces Along Normals
***************************

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Extrude Along Normals`
   :Menu:      :menuselection:`Face --> Extrude Faces Along Normals`,
               :menuselection:`Mesh --> Extrude --> Extrude Faces Along Normals`
   :Shortcut:  :kbd:`E`

Extrusion and offset will be locked in to only move along the local normals of the selected mesh.

Flip Normals
   Only the *normals* of the new faces created from the extrusion will be flipped.

Dissolve Orthogonal Edges
   Removes and connects edges whose faces form a flat surface and intersect new edges.

Offset
   Amount to move geometry along the normals.

Offset Even
   The length of the new edges will be uniform.

Proportional Editing
   The extruded face will affect nearby geometry.
   See :doc:`Proportional Editing </editors/3dview/controls/proportional_editing>` for a full reference.


## Extrude Individual Faces

.. _bpy.ops.mesh.extrude_faces_move:
.. _tool-mesh-extrude_individual:

************************
Extrude Individual Faces
************************

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Extrude Individual`
   :Menu:      :menuselection:`Face --> Individual Faces`,
               :menuselection:`Mesh --> Extrude --> Individual Faces`

This tool allows you to extrude a selection of multiple faces as individuals, instead of as a region.
The faces are extruded along their own normals, rather than their average.
This has several consequences: first, "internal" edges
(i.e. edges between two selected faces) are no longer deleted (the original faces are).

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_face_extrude-individual-faces_multi.png
          :width: 200px

          Selection of multiple faces.

     - .. figure:: /images/modeling_meshes_editing_face_extrude-individual-faces_multi-region.png
          :width: 200px

          Extruded using extrude region.

     - .. figure:: /images/modeling_meshes_editing_face_extrude-individual-faces_multi-individual.png
          :width: 200px

          Extruded using Extrude Individual.


## Face Data


*********
Face Data
*********

.. _bpy.ops.mesh.colors_rotate:

Rotate Colors
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Rotate Colors`

Rotates the Color Attribute's colors inside faces either clockwise or counterclockwise.


.. _bpy.ops.mesh.colors_reverse:

Reverse Colors
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Reverse Colors`

Flips the direction of Color Attribute's colors inside the selected faces.


Rotate UVs
==========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Rotate UVs`

See :ref:`bpy.ops.mesh.uvs_rotate`.


Reverse UVs
===========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Reverse UVs`

See :ref:`bpy.ops.mesh.uvs_reverse`.


.. _bpy.ops.mesh.flip_quad_tessellation:

Flip Quad Tessellation
======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Flip Quad Tessellation`

Internally, all :term:`quads <Quad>` are :term:`Tessellated <Tessellation>` into 2 triangles,
this operator swaps which way the quad is split into triangles.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_face_flip-tesselation_before.png
     - .. figure:: /images/modeling_meshes_editing_face_flip-tesselation_after.png


.. _bpy.ops.mesh.mark_freestyle_face:

Mark Freestyle Face
===================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Mark Freestyle Face`

Todo.


Clear Freestyle Face
====================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Clear Freestyle Face`

Todo.


## Fill

.. _bpy.ops.mesh.fill:
.. _modeling-meshes-editing-fill:

****
Fill
****

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Fill`
   :Shortcut:  :kbd:`Alt-F`

The *Fill* option will create *triangular* faces from any group of selected edges
or vertices, as long as they form one or more complete perimeters.

Beauty
   Arrange the new triangles nicely.

.. figure:: /images/modeling_meshes_editing_face_fill_example.png
   :width: 300px

   Filled using fill.

Note, unlike creating n-gons, *Fill* supports holes.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_face_fill_holes.png
          :width: 320px

          A closed perimeter of edges with holes.

     - .. figure:: /images/modeling_meshes_editing_face_fill_holes-filled.png
          :width: 320px

          Filled using fill.


## Grid Fill

.. _bpy.ops.mesh.fill_grid:
.. _modeling-meshes-editing-grid-fill:

*********
Grid Fill
*********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Grid Fill`

*Grid Fill* uses a pair of connected edge loops or a single, closed edge loop to fill in a grid
that follows the surrounding geometry.

The best predictable result can be achieved if you select two opposite edge loops
with an equal number of vertices. When a single, closed edge loop is selected,
the Span/Offset options allows you to adjust the way two opposite edge loops
are detected from one closed edge loop.

Span
   Specifies the number of columns in the grid.
Offset
   Defines the vertex that is considered to be the corner of the grid,
   by default, it's the active vertex. The Offset allows you to rotate the grid lines.
Simple Blending
   Use a simple interpolation algorithm to generate grid vertices from boundary loops,
   which does not tries to maintain the shape,
   useful for flat surfaces or times when keeping the shape gives odd results.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_face_grid-fill_before.png
          :width: 320px

          Input.

     - .. figure:: /images/modeling_meshes_editing_face_grid-fill_after.png
          :width: 320px

          Grid Fill result.


## Index


##################
  Face Operators
##################

.. toctree::
   :maxdepth: 2

   extrude_faces.rst
   extrude_faces_normal.rst
   extrude_individual_faces.rst
   inset_faces.rst
   poke_faces.rst
   triangulate_faces.rst
   triangles_quads.rst
   solidify_faces.rst
   wireframe.rst
   fill.rst
   grid_fill.rst
   beautify_faces.rst
   intersect_knife.rst
   intersect_boolean.rst
   weld_edges_faces.rst
   shading.rst
   face_data.rst


## Inset Faces

.. _bpy.ops.mesh.inset:
.. _tool-mesh-inset_faces:

***********
Inset Faces
***********

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Inset Faces`
   :Menu:      :menuselection:`Face --> Inset Faces`
   :Shortcut:  :kbd:`I`

This tool takes the currently selected faces and creates an inset of them,
with adjustable thickness and depth. Think of it as like creating an edge loop,
but relative to the selected edges, even in complex meshes.

The tool is modal, such that when you activate it,
you may adjust the thickness with your mouse position.
You may also adjust the depth of the inset during the modal operation by holding :kbd:`Ctrl`.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_face_inset-faces_before.png
          :width: 320px

          Selection to inset.

     - .. figure:: /images/modeling_meshes_editing_face_inset-faces_after.png
          :width: 320px

          Result of inset with *Select Outer* enabled.


Options
=======

.. figure:: /images/modeling_meshes_editing_face_inset-faces_options.png
   :align: right

   Inset operator options.

Boundary :kbd:`B`
   Determines whether open edges will be inset or not.
Offset Even
   Scale the offset to give a more even thickness.
Offset Relative
   Scale the offset by lengths of surrounding geometry.
Edge Rail
   Created vertices slide along the original edges of the inner geometry, instead of the normals.
Thickness
   Set the size of the offset.
Depth :kbd:`Ctrl`
   Raise or lower the newly inset faces to add depth.
Outset :kbd:`O`
   Create an outset rather than an inset.
   Causes the geometry to be created surrounding selection (instead of within).
Select Outer
   Toggle which side of the inset is selected after the operation.
Individual :kbd:`I`
   By default the Inset tool operates on the region around selected faces,
   but with this option each selected face can be inset on its own.
Interpolate
   Interpolate mesh data: e.g. UVs, Color Attribute's colors, weights, etc.


## Intersect Boolean

.. _bpy.ops.mesh.intersect_boolean:

*******************
Intersect (Boolean)
*******************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Intersect (Boolean)`

Performs Boolean operations with the selection on the unselected geometry.
While the :doc:`/modeling/modifiers/generate/booleans` is useful for non-destructive edits,
access to these operations with a tool in Edit Mode can be useful to quickly perform edits.

Boolean Operation
   :Intersect:
      Opposite of *Difference* (everything *inside* of the target mesh is kept).
   :Union:
      The target mesh is added to the modified mesh.
   :Difference:
      The target mesh is subtracted from the modified mesh (everything *outside* of the target mesh is kept).

Solver
   Algorithm used to calculate the Boolean intersections.

   :Fast:
      Uses a mathematically simple solver which offers the best performance;
      however, this solver lacks support for overlapping geometry.

      Merge Threshold
         Tolerance for close faces to be considered touching.
         It may be useful to increase this when some intersections aren't detected that should be and
         when extra geometry is being created because edges aren't detected as overlapping.

         .. warning::

            A threshold approaching the size of faces may cause very slow calculation,
            in general keep this value small.

   :Exact:
      Uses a mathematically complex solver which offers the best results
      and has full support for overlapping geometry;
      however, this solver is much slower than the *Fast Solver*.

Swap
   Changes the order of the operations when using *Difference* to determine which side is kept.

Self Intersection
   Correctly calculates cases when one or both operands have self-intersections,
   this involves more calculations making it slower.


## Intersect Knife

.. _bpy.ops.mesh.intersect:

*****************
Intersect (Knife)
*****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Intersect (Knife)`

The Intersect tool lets you cut intersections into geometry.
It is a bit like the Boolean tool, but, does not calculate interior/exterior geometry.
Faces are split along the intersections, leaving new edges selected.

Source
   :Self Intersect: Operate on the overlapping geometry of the mesh.
   :Selected/Unselected: Operate between the selected and unselected geometry.

Separate Mode
   :All: Splits the geometry at the new edge.
   :Cut: Keep each side of the intersection separate without splitting the faces in half.
   :Merge: Merge all the geometry from the intersection.

Solver
   Algorithm used to calculate the intersections.

   :Fast:
      Uses a mathematically simple solver which offers the best performance;
      however, this solver lacks support for overlapping geometry.

      Merge Threshold
         Tolerance for close faces to be considered touching.
         It may be useful to increase this when some intersections aren't detected that should be and
         when extra geometry is being created because edges aren't detected as overlapping.

         .. warning::

            A threshold approaching the size of faces may cause very slow calculation,
            in general keep this value small.

   :Exact:
      Uses a mathematically complex solver which offers the best results
      and has full support for overlapping geometry;
      however, this solver is much slower than the *Fast Solver*.


## Poke Faces

.. _bpy.ops.mesh.poke:

**********
Poke Faces
**********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Faces --> Poke Faces`

Splits each selected faces into a triangle fan,
creating a new center vertex and triangles between the original face edges
and new center vertex. The *Offset* can be used to make spikes or depressions.

Poke Offset
   Offset the new center vertex along the face normal.
Offset Relative
   Multiply the Offset by the average length from the center to the face vertices.
Poke Center
   Computes the center of a face.

   :Weighted Mean: Using the mean average weighted by edge length.
   :Mean: Using the mean average.
   :Bounds: Uses center of bounding box.


## Shading

.. _bpy.ops.mesh.face_shading:

*******************
Shade Smooth & Flat
*******************

The appearance of the mesh edges are determined to be evened out or well defined within the 3D Viewport and render.
In Edit Mode, individual faces can be selected to determine which faces are smoothed or flattened.

.. note::

   Both :doc:`Shade Smooth and Flat </scene_layout/object/editing/shading>`
   are also available in Object Mode and function the same way.


.. _bpy.ops.mesh.faces_shade_smooth:

Shade Smooth
============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Shade Smooth`

Using interpolated vertex normals, the mesh faces will blur at the edges and appear smooth.


.. _bpy.ops.mesh.faces_shade_flat:

Shade Flat
==========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Shade Flat`

Face normals are displayed evenly, because of this all the edges of the selected mesh will be easily visible.

.. tip::

   Use the :doc:`Edge Split </modeling/modifiers/generate/edge_split>`
   modifier and :ref:`Smooth by Angle Smooth <bpy.ops.object.shade_smooth_by_angle>`
   to balance between smooth surfaces and sharp edges.


## Solidify Faces

.. _bpy.ops.mesh.solidify:

**************
Solidify Faces
**************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Solidify Faces`

This takes a selection of faces and solidifies them by extruding them
uniformly to give volume to a :term:`Non-manifold` surface.
This is also available as a :doc:`Modifier </modeling/modifiers/generate/solidify>`.
After using the tool, you can set the offset distance in the :ref:`bpy.ops.screen.redo_last` panel.

Thickness
   Amount to offset the newly created surface.
   Positive values offset the surface inward relative to the normals direction.
   Negative values offset outward.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_face_solidify-faces_before.png
          :width: 200px

          Mesh before solidify operation.

     - .. figure:: /images/modeling_meshes_editing_face_solidify-faces_after.png
          :width: 200px

          Solidify with a positive thickness.

     - .. figure:: /images/modeling_meshes_editing_face_solidify-faces_after2.png
          :width: 200px

          Solidify with a negative thickness.


## Triangles Quads

.. _bpy.ops.mesh.tris_convert_to_quads:
.. _mesh-faces-tristoquads:

******************
Triangles to Quads
******************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Triangles to Quads`
   :Shortcut:  :kbd:`Alt-J`

This tool converts the selected triangles into quads by taking adjacent triangles and
removing the shared edge to create a quad, based on a threshold.
This tool can be applied on a selection of multiple triangles.

This means you can select the entire mesh and convert triangles that already form square shapes --
to be converted into quads, without having to concern yourself with individual faces.

Alternatively you can force this operation selecting a pairs of faces (see hint below for other ways of joining).

To create a quad, this tool needs at least two adjacent triangles.
If you have an even number of selected triangles,
it is also possible not to obtain only quads. In fact,
this tool tries to create most even rectangular quads from the given triangles,
which means some triangles could remain.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_face_triangles-quads_before.png
          :width: 320px

          Before converting tris to quads.

     - .. figure:: /images/modeling_meshes_editing_face_triangles-quads_after.png
          :width: 320px

          After converting tris to quads.

Max Angle
   This value, between (0 to 180), controls the threshold for this tool to work on adjacent triangles.
   With a threshold of 0.0,
   it will only join adjacent triangles that form a perfect rectangle
   (i.e. right-angled triangles sharing their hypotenuses).
   Larger values are required for triangles with a shared edge that is small,
   relative to the size of the other edges of the triangles.
Compare UVs
   Prevents the union of triangles that are not also adjacent in the active UV map.
Compare Color Attributes
   Prevents the union of triangles that do not have matching
   :ref:`Color Attributes <modeling-meshes-properties-object_data-color-attributes>`.
Compare Sharp
   Prevents the union of triangles that share an edge marked as sharp.
Compare Materials
   Prevents the union of triangles that do not have the same material assigned.

.. hint::

   When isolated groups of faces are selected, they can be combined
   with :ref:`Create Face <modeling-mesh-make-face-edge-dissolve>` or :ref:`bpy.ops.mesh.dissolve_faces`;
   this is not limited to quads.


## Triangulate Faces

.. _bpy.ops.mesh.quads_convert_to_tris:

*****************
Triangulate Faces
*****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Triangulate Faces`
   :Shortcut:  :kbd:`Ctrl-T`

This tool converts each of the selected faces (whether it be quads or n-gons) to triangular faces.
See the :doc:`/modeling/modifiers/generate/triangulate`.


## Weld Edges Faces

.. _bpy.ops.mesh.face_split_by_edges:

*********************
Weld Edges into Faces
*********************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Weld Edges into Faces`

A tool to split selected faces by loose wire edges.
This can be used in a similar way to the Knife tool, but the edges are manually setup first.


## Wireframe

.. _bpy.ops.mesh.wireframe:

*********
Wireframe
*********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Wireframe`

The Wireframe tool makes a wireframe from faces by turning edges into wireframe tubes,
similar to the :doc:`/modeling/modifiers/generate/wireframe`.


## Bisect

.. _bpy.ops.mesh.bisect:
.. _tool-mesh-bisect:

******
Bisect
******

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Knife --> Bisect`
   :Menu:      :menuselection:`Mesh --> Bisect`

The Bisect tool is a quick way to cut a mesh in two along a custom plane.

Use :kbd:`LMB` click and drag to draw cut line.
Once the cut is done the :ref:`bpy.ops.screen.redo_last` panel gives a few options:

Plane Point, Plane Normal
   The plane can be numerically adjusted for precise values.
Fill
   Cuts can optionally fill in the holes created,
   with materials, UV maps, and Color Attributes based on the surrounding geometry.
Clear Inner, Clear Outer
   Cuts may remove geometry on one side.
Axis Threshold
   Cut along the straight plane or along the existing geometry below the distance from the plane.


Controls
========

Move :kbd:`Spacebar`
   Changes the location of the line.
Snap :kbd:`Ctrl`
   Constrains the rotation of the line to 15 degree intervals.
Flip :kbd:`F`
   Changes the side of the line that is the inner/outer side;
   this option is useful when using *Clear Inner*, *Clear Outer* and/or *Fill*.


Examples
========

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_bisect_example.png
          :width: 300px

          Example of a common use of bisect.

     - .. figure:: /images/modeling_meshes_editing_mesh_bisect_uv.jpg
          :width: 320px

          Example of bisect with the fill option enabled.


## Cleanup


********
Clean Up
********

These tools are to help cleanup degenerate geometry and fill in missing areas of a mesh.


.. _bpy.ops.mesh.decimate:

Decimate Geometry
=================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Clean up --> Decimate Geometry`

The Decimate Geometry tool allows you to reduce
the vertex/face count of a mesh with minimal shape changes.

Ratio
   Ratio of triangles to reduce to.
Vertex Group
   Use the active vertex group as an influence.

   Weight
      Strength of the vertex group.
   Invert
      Inverts the vertex group.
Symmetry
   Maintain symmetry on either the *X*, *Y*, or *Z* axis.

.. seealso::

   This tool works similar to the :doc:`Decimate Modifier </modeling/modifiers/generate/decimate>`.


.. _bpy.ops.mesh.fill_holes:

Fill Holes
==========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Clean up --> Fill Holes`

This tool can take a large selection and detect the holes in the mesh, filling them in.

This is different from the face creation operator in three important respects:

#. Holes are detected, so there is no need to manually find and select the edges around the holes.
#. Holes can have a limit for the number of sides (so only quads or tris are filled in for example).
#. Mesh data is copied from surrounding geometry (UVs, Color Attributes, multi-res, all layers),
   since manually creating this data is very time-consuming.


.. _bpy.ops.mesh.face_make_planar:

Make Planar Faces
=================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Clean up --> Make Planar Faces`

The *Make Planar Faces* iteratively flattens faces.
This can happen with faces over three vertices and
it is a common convention that faces should be kept planar.

Factor
   Distance to move the vertices each iteration.
Iterations
   Number of times to repeat the operation.


.. _bpy.ops.mesh.vert_connect_nonplanar:

Split Non-Planar Faces
======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Clean up --> Split Non-Planar Faces`

This tool avoids ambiguous areas of geometry by splitting non-flat faces when they are bent beyond
a given limit.


.. _bpy.ops.mesh.vert_connect_concave:

Split Concave Faces
===================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Clean up --> Split Concave Faces`

This tool can be used to convert any :term:`Concave Face` to convex
by splitting the concave into two or more convex faces.


.. _bpy.ops.mesh.delete_loose:

Delete Loose
============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Clean up --> Delete Loose`

This tool removes disconnected vertices and edges (optionally faces).


.. _bpy.ops.mesh.dissolve_degenerate:

Degenerate Dissolve
===================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Clean up --> Degenerate Dissolve`

This tool collapses / removes geometry which you typically will not want.

- Edges with no length.
- Faces with no areas (faces on a point or thin faces).
- Face corners with no area.


.. _bpy.ops.mesh.remove_doubles:

Merge by Distance
=================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Merge by Distance`,
               :menuselection:`Context Menu --> Merge by Distance`

Merge by Distance is a useful tool to simplify a mesh by merging the selected vertices that
are closer than a specified distance to each other.
An alternative way to simplify a mesh is to use the :doc:`Decimate Modifier </modeling/modifiers/generate/decimate>`.

Merge Distance
   Sets the distance threshold for merging vertices.
Unselected
   Allows vertices in the selection to be merged with unselected vertices.
   When disabled, selected vertices will only be merged with other selected ones.


## Convex Hull

.. _bpy.ops.mesh.convex_hull:

***********
Convex Hull
***********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Convex Hull`

The Convex Hull operator takes a point cloud as input and outputs a convex hull surrounding those vertices.
If the input contains edges or faces that lie on the convex hull, they can be used in the output as well.
This operator can be used as a bridge tool as well.

.. figure:: /images/modeling_meshes_editing_mesh_convex-hull_example.png

   Input mesh, point cloud, and Convex Hull result.

Delete Unused
   Removes vertices, edges, and faces that were selected, but not used as part of the hull.
   Note that vertices and edges that are used
   by other edges and faces not part of the selection will not be deleted.

Use Existing Faces
   Where possible, use existing input faces that lie on the hull.
   This allows the convex hull output to contain n-gons rather than triangles
   (or quads if the *Join Triangles* option is enabled).

Make Holes
   Delete edges and faces in the hull that were part of the input too.
   Useful in cases like bridging to delete faces between the existing mesh and the convex hull.

Join Triangles
   Joins adjacent triangles into quads.
   Has all the same properties as the *Tris to Quads* operator (angle limit, compare UVs, etc.).
Max Face Angle, Max Shape Angle, Compare
   See :ref:`mesh-faces-tristoquads`.


## Delete


*********************
Deleting & Dissolving
*********************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Delete`

These tools can be used to remove components.


.. _bpy.ops.mesh.delete:

Delete
======

.. reference::

   :Shortcut:  :kbd:`X`, :kbd:`Delete`

Deletes selected vertices, edges, or faces. This operation can also be limited to:

Vertices
   Delete all vertices in current selection, removing any faces or edges they are connected to.
Edges
   Deletes any edges in the current selection. Removes any faces that the edge shares with it.
Faces
   Removes any faces in current selection.
Only Edges & Faces
   Limits the operation to only selected edges and adjacent faces.
Only Faces
   Removes faces, but edges within the face selection are retained.


.. _bpy.ops.mesh.dissolve:

Dissolve
========

Dissolve operations are also accessed from the delete menu.
Dissolve will remove the geometry and fill in the surrounding geometry.
Instead of removing the geometry, which may leave holes that you have to fill in again.

Removes selected geometry, but without creating holes, effectively turning the selection into a single n-gon.
Dissolve works slightly different based on if you have edges, faces or vertices selected.
You can add detail where you need it, or quickly remove it where you do not.


.. _bpy.ops.mesh.dissolve_verts:

Dissolve Vertices
-----------------

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Delete --> Dissolve Vertices`

Remove the vertex, merging all surrounding faces.
In the case of two edges, merging them into a single edge.

Face Split
   When dissolving vertices into surrounding faces, you can often end up with very large, uneven n-gons.
   The face split option limits dissolve to only use the corners of the faces connected to the vertex.
Tear Boundaries
   Split off face corners instead of merging faces.


Examples
^^^^^^^^

.. figure:: /images/modeling_meshes_editing_mesh_delete_dissolve-examples.png

   \1) Original mesh.
   \2) Face Split: Off, Tear Boundaries: Off.
   \3) Face Split: On, Tear Boundaries: Off.
   \4) Face Split: On/Off, Tear Boundaries: On.


.. _bpy.ops.mesh.dissolve_edges:

Dissolve Edges
--------------

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Delete --> Dissolve Edges`

Removes edges sharing two faces (joining those faces).

The options are the same as for the `Dissolve Vertices`_ tool.


.. _bpy.ops.mesh.dissolve_faces:

Dissolve Faces
--------------

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Delete --> Dissolve Faces`

Merges regions of faces that share edges into a single face.

.. note::

   This can be accessed quickly using the :kbd:`F` key,
   see: :ref:`modeling-mesh-make-face-edge-dissolve`.


Dissolve (Context-Sensitive)
----------------------------

.. reference::

   :Shortcut:  :kbd:`Ctrl-X`

This is a convenient shortcut that dissolves
based on the current selection mode (vertex, edge, face).


.. _bpy.ops.mesh.dissolve_limited:

Limited Dissolve
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Delete --> Limited Dissolve`

This tool can simplify your mesh by dissolving vertices and edges separating flat regions.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_delete_limited-dissolve-before.png
          :width: 320px

          Original mesh.

     - .. figure:: /images/modeling_meshes_editing_mesh_delete_limited-dissolve-after.png
          :width: 320px

          Result of Limited Dissolve.

Max Angle
   Reduces detail on planar faces and linear edges with an adjustable angle threshold.
All Boundaries
   Always dissolve vertices that have two edge users at boundaries.
Delimit
   Prevent faces from joining when they don't share certain properties (material for e.g.).


.. _bpy.ops.mesh.edge_collapse:

Collapse Edges & Faces
======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Delete --> Collapse Edges & Faces`
   :Shortcut:  :kbd:`X`, :menuselection:`Collapse Edges & Faces`

Collapse each isolated edge and face region into single vertices,
with support for face data such as UVs and vertex colors.

This is useful for taking a ring of edges and collapsing it,
removing the face loop it ran through.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_delete_collapse-before.png
          :width: 320px

          Selected edge ring.

     - .. figure:: /images/modeling_meshes_editing_mesh_delete_collapse-after.png
          :width: 320px

          Edge ring collapsed.

.. tip::

   This can be useful as a general way to remove detail, it has some advantages over:

   :Delete Vertices: Leaves holes.
   :Collapse Vertices: Doesn't correct UVs, vertex colors, etc.
   :Dissolve Vertices: Often creates n-gons.


.. _bpy.ops.mesh.delete_edgeloop:

Edge Loops
==========

.. reference::

   :Mode:      Edit Mode (Vertex or Edge select modes)
   :Menu:      :menuselection:`Mesh --> Delete --> Edge Loops`
   :Shortcut:  :kbd:`X` or :kbd:`Delete`, :menuselection:`Edge Loops`

*Edge Loop* allows you to delete a selected edge loop if it is between two other edge loops.
This will create one face loop where two previously existed.

.. note::

   The *Edge Loop* option is very different to the *Edges* option,
   even if you use it on edges that look like an edge loop.
   Deleting an edge loop merges the surrounding faces together to preserve the surface of the mesh.
   By deleting a chain of edges, the edges are removed, deleting the surrounding faces as well.
   This will leave holes in the mesh where the faces once were.


Example
-------

The selected edge loop on the UV Sphere has been deleted and
the faces have been merged with the surrounding edges.
If the edges had been deleted by choosing *Edges* from the *Delete* menu
there would be an empty band of deleted faces all the way around the sphere instead.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_delete_edge-loop-before.png
          :width: 320px

          Selected edge loop.

     - .. figure:: /images/modeling_meshes_editing_mesh_delete_edge-loop-after.png
          :width: 320px

          Edge loop deleted.

.. seealso::

   - :ref:`Vertex merging <vertex-merging>`.
   - :ref:`mesh-faces-tristoquads`.
   - :ref:`mesh-unsubdivide`.


## Duplicate

.. _bpy.ops.mesh.duplicate_move:

*********
Duplicate
*********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Duplicate`
   :Shortcut:  :kbd:`Shift-D`

This tool simply duplicates the selected elements,
without creating any connections with the rest of the mesh (unlike extrude, for example),
and places the duplicate at the location of the original. Once the duplication is done,
only the *new* duplicated elements are selected,
and you are automatically placed in move mode, so you can move your copy elsewhere...

In the *Toolbar* are settings for *Vector* offset, *Proportional Editing*,
*Duplication Mode*, and *Axis Constraints*.

.. TODO: Duplication Mode non-functional?

Note that duplicated elements belong to the same
:doc:`vertex groups </modeling/meshes/properties/vertex_groups/index>` as the "original" ones.
The same goes for the :ref:`material indices <bi-multiple-materials>`,
the edge's *Sharp* and *Seam* marks, and probably for the other vertex/edge/face properties...


## Extrude


*******
Extrude
*******

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Extrude`
   :Shortcut:  :kbd:`Alt-E`

This operators shown in this menu are dependent of what part of a mesh is currently selected.
Many of the operators are also available in the :doc:`Vertex </modeling/meshes/editing/vertex/index>`,
:doc:`Edge </modeling/meshes/editing/edge/index>`, abd :doc:`Face </modeling/meshes/editing/face/index>` menus.


Extrude Faces
=============

Available when a :term:`Face` is selected.

See :ref:`bpy.ops.view3d.edit_mesh_extrude_move_normal`.


Extrude Faces Along Normals
===========================

Available when a :term:`Face` is selected.

See :ref:`bpy.ops.view3d.edit_mesh_extrude_move_shrink_fatten`.


Extrude Individual Faces
========================

Available when a :term:`Face` is selected.

See :ref:`tool-mesh-extrude_individual`.


Extrude Manifold
================

Available when a :term:`Face` is selected.

See :doc:`/modeling/meshes/tools/extrude_manifold`.


Extrude Edges
=============

Available when a :term:`Edge` is selected.

See :ref:`bpy.ops.mesh.extrude_edges_move`.


Extrude Vertices
================

Available when a :term:`Vertex` is selected.

See :ref:`bpy.ops.mesh.extrude_vertices_move`.


.. _bpy.ops.mesh.extrude_repeat:

Extrude Repeat
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Extrude --> Extrude Repeat`

This tool behaves similar to the :doc:`/modeling/modifiers/generate/array`,
by extruding the selection along the Z axis of the view.
If the selection is not :term:`Manifold` it's extruded the specified number of times.

Offset X, Y, Z
   Distance between the instances.
Steps
   Number of instances.
Scale Offset
   Multiplication factor to increase or decrease the offset.


Spin
====

See :doc:`/modeling/meshes/tools/spin`.


## Index


##################
  Mesh Operators
##################

.. toctree::
   :maxdepth: 2

   transform/index.rst
   mirror.rst
   duplicate.rst
   extrude.rst
   merge.rst
   split.rst
   separate.rst
   bisect.rst
   knife_project.rst
   knife_topology_tool.rst
   convex_hull.rst
   symmetrize.rst
   snap_symmetry.rst
   normals.rst
   shading.rst
   set_attribute.rst
   sort_elements.rst
   cleanup.rst
   delete.rst


## Knife Project

.. _bpy.ops.mesh.knife_project:

*************
Knife Project
*************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Knife Project`

Knife Project is a non-interactive tool where you can use objects to cookie-cut into
one or more meshes rather than hand drawing the line. The outline of the selected objects
that *are not* in Edit Mode is projected along the view axis onto the meshes that *are*
in Edit Mode, and then cuts into the faces there. Afterwards, the resulting geometry
inside the cut gets selected.

.. note::

   The cutting objects must be curves or non-manifold meshes (e.g. flat shapes, loose edges).
   :ref:`Select Non-Manifold <bpy.ops.mesh.select_non_manifold>`
   will highlight the cutting edges of mesh objects.

Keep in mind that Knife Project works from the current view's perspective. For best results, make sure
to rotate your view to exactly the position you require before using this tool. Orthographic views such
as Right, Front, and Top are commonly used for this.

.. hint::
   :doc:`3D Viewport Alignment </editors/3dview/navigate/align>` to adjust the projection axis.

To use Knife Project, select the objects to be cut, switch to *Edit Mode*,
select the cutting objects in the Outliner (:kbd:`Ctrl-LMB`),
and choose :menuselection:`Mesh --> Knife Project`.

If Blender switches back to *Object Mode* when selecting the cutting objects,
make sure that :menuselection:`Edit --> Lock Object Modes` is checked in the topbar.
Alternatively, if you have only one cutting object, you can select it in the
viewport with :kbd:`Ctrl-LMB`.

Options
=======

Cut Through
   Projects the cut through the entire mesh, including back faces not currently visible.


Examples
========

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_knife-project_text-before.jpg
          :width: 320px

          Before projecting from a text object.

     - .. figure:: /images/modeling_meshes_editing_mesh_knife-project_text-after.jpg
          :width: 320px

          Resulting knife projection.

   * - .. figure:: /images/modeling_meshes_editing_mesh_knife-project_mesh-before.jpg
          :width: 320px

          Before projecting from a mesh object.

     - .. figure:: /images/modeling_meshes_editing_mesh_knife-project_mesh-after.jpg
          :width: 320px

          Resulting knife projection (extruded after).

   * - .. figure:: /images/modeling_meshes_editing_mesh_knife-project_curve-before.png
          :width: 320px

          Before projecting from a 3D curve object.

     - .. figure:: /images/modeling_meshes_editing_mesh_knife-project_curve-after.jpg
          :width: 320px

          Resulting knife projection (extruded after).


Known Limitations
=================

When cutting multiple meshes in Edit Mode at once,
geometry from these meshes does not occlude separate mesh objects behind them.


## Knife Topology Tool

.. _bpy.ops.mesh.knife:
.. _tool-mesh-knife:

*******************
Knife Topology Tool
*******************

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Knife`
   :Menu:      :menuselection:`Mesh --> Knife Topology Tool`
   :Shortcut:  :kbd:`K`

The Knife tool can be used to interactively subdivide (cut up)
geometry by drawing lines or closed loops to create holes.


Usage
=====

When using *Knife*, the cursor changes to an icon of a scalpel
and the header changes to display options for the tool.
You can draw connected straight lines by clicking :kbd:`LMB`,
marked with small green squares. Red squares are already defined cuts.
Surrounding red squares mean that there is a cut already in that position,
so no additional vertex will be created (besides the first one).

If multiple objects are selected before entering Edit Mode,
then knife cuts will affect all of those objects.

.. list-table::

   * - .. figure:: /images/modeling_meshes_tools_knife_line-before.png

          Mesh before knife cut.

     - .. figure:: /images/modeling_meshes_tools_knife_line-active.png

          Knife cut active.

     - .. figure:: /images/modeling_meshes_tools_knife_line-after.png

          After confirming knife cut.


Tool Settings
=============

Occlude Geometry
   Only cut geometry visible on screen.

Only Selected :kbd:`Shift-K`
   Only cuts through selected geometry.

X-Ray
   Show cut points on non-visible geometry too, when *Occlude Geometry* is deactivated.

Measurement
   Which visible measurements to show.

   Distance, Angle, None, Both

Angle Snapping
   Whether or not dragged lines should be constrained to particular angles, and if so,
   which coordinate system the angle is relative to.

   None, Screen, Relative

Angle Snapping Increment
   When angle snapping is on, the angle will be constrained to a multiple of this angle.


Controls
========

Confirm :kbd:`Spacebar` or :kbd:`Return`
   Confirms the cut.
   :kbd:`Return` will leave selected every edge except the new edges created from the cut.

Cancel :kbd:`Esc`
   Cancels the cut.

Draw a Continuous Line :kbd:`LMB` drag.
   So you can draw a free-hand line over a surface,
   points will be created at edge intersections.

Close Loop double-click :kbd:`LMB`
   This is a quick way to close the loop you are currently cutting.

New Cut :kbd:`RMB`
   Begins a new cut. This allows you to define multiple distinct cut lines.
   If multiple cuts have been defined, they are recognized as new snapping points.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_tools_knife_multiple-before.png

             Creating multiple cuts.

        - .. figure:: /images/modeling_meshes_tools_knife_multiple-after.png

             Result of starting new cuts while in the tool.

Midpoint Snap :kbd:`Shift`
   Hold to snap the cursor to the midpoint of edges,
   meaning that all cuts will be performed at the exact center of each cut edge.

Ignore Snap :kbd:`Ctrl`
   Hold to make the tool ignore snapping,
   unlike the default where mouse cursor snaps to near edges.

Cut Through: :kbd:`C`
   Allow the Cut tool to cut through to occluded faces, instead of only the visible ones.

Angle Constrain :kbd:`A`
   Constrains the cut line to certain degree increments.
   The increment can be specified in the Tool Settings (see above), or can be typed
   when angle constraining is active.
   The default angles are in the plane of the screen, but typing :kbd:`A` again
   makes it relative to the last cut edge.
   If the last cut edge is ambiguous (because the cut was on a vertex),
   typing :kbd:`R` cycles through the possible reference edges.

   .. list-table::

      * - .. figure:: /images/modeling_meshes_tools_knife_angle-before.png
             :width: 320px

             Constraining cut angle.

        - .. figure:: /images/modeling_meshes_tools_knife_angle-after.png
             :width: 320px

             Result of constraining cut angle.

Axis Constrain :kbd:`X`, :kbd:`Y`, or :kbd:`Z`
   Constrains the cut line to one of the coordinate system axes.
   Initially it will be the global axis with the given name,
   but pressing the same key again switches to the object's local axis system.
   Additionally, if the scene transformation orientation is set to
   a custom orientation (e.g. from a face), the constraints will be in that coordinate system.

Visible Measurements :kbd:`S`
   Shows measurements of the cuts being made: angles with respect to a mesh edge, lengths, or both.
   Pressing :kbd:`S` repeatedly cycles between what can be shown.

   Only Distance, Only Angles, Both, None

   .. list-table::

      * - .. figure:: /images/modeling_meshes_tools_knife-measurement-distance.png
             :width: 640px

             Only Distance.

        - .. figure:: /images/modeling_meshes_tools_knife-measurement-angles.png
             :width: 640px

             Only Angles.

        - .. figure:: /images/modeling_meshes_tools_knife-measurement-both.png
             :width: 640px

             Both Angles and Distance.

Undo :kbd:`Ctrl-Z`
   Undoes the previous cut segment. The starting point for the next cut is adjusted accordingly.
   If a cut is a drag cut, the entire drag cut is undone.

X-Ray Mode :kbd:`V`
   Toggles whether or not cuts to segments behind the visible geometry are shown.


Known Limitations
=================

Duplicate Vertices
------------------

If you experience problems where duplicate vertices are being created by cuts,
this is often caused by too large a near/far clipping range.

Try increasing the *Clip Start* to avoid this problem,
see :ref:`Depth Troubleshooting <troubleshooting-depth>` for details.


Unconnected Cuts
----------------

Cuts that begin or end in the middle of a face, will be ignored.

*This is constrained by the kinds of geometry Blender can represent.*


## Merge

.. _bpy.ops.mesh.merge:
.. _vertex-merging:

*****
Merge
*****

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Merge`,
               :menuselection:`Context Menu --> Merge`
   :Shortcut:  :kbd:`M`

This tool allows you to merge all selected vertices to a unique one, dissolving all others.
You can choose the location of the remaining vertex in the menu this tool pops up before executing:

At Center
   It will place the remaining vertex at the center of the selection.
   Available in all select modes.
At Cursor
   It will place the remaining vertex at the 3D Cursor.
   Available in all select modes.
Collapse
   Every island of selected vertices (connected by selected edges) will merge on its own median center,
   leaving one vertex per island.
At First
   It will place the remaining vertex at the location of the first one selected.
   Only available in *Vertex* select mode.
At Last
   It will place the remaining vertex at the location of the last one selected (the active one).
   Only available in *Vertex* select mode.

Merging vertices of course also deletes some edges and faces. But Blender will do everything
it can to preserve edges and faces only partly involved in the reunion.

.. note::

   *At First* and *At Last* depend on that the selection order is saved:
   the order is lost, for instance, after changing selection mode.

UVs
   If *UVs* is ticked in the :ref:`bpy.ops.screen.redo_last` panel,
   the UV mapping coordinates, if existing, will be corrected to avoid image distortion.


By Distance
===========

Todo.


## Mirror


******
Mirror
******

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Mirror`
   :Shortcut:  :kbd:`Ctrl-M`

The Mirror tool mirrors a selection across a selected axis.

The Mirror tool in *Edit Mode* is similar to
:doc:`Mirroring in Object Mode </scene_layout/object/editing/mirror>`.
It is exactly equivalent to scaling vertices by -1 around one chosen pivot point
and in the direction of one chosen axis, only it is faster/handier.

After this tool becomes active, select an axis to mirror the selection
by pressing :kbd:`X`, :kbd:`Y`, or :kbd:`Z`.

You can also interactively mirror the geometry by holding the :kbd:`MMB` and dragging in
the desired mirror direction.


Axis of Symmetry
================

For each transformation orientation,
you can choose one of its axes along which the mirroring will occur.

As you can see, the possibilities are infinite and the freedom complete:
You can position the pivot point at any location around which we want the mirroring to occur,
choose one transformation orientation and then one axis on it.


Pivot Point
===========

:doc:`Pivot points </editors/3dview/controls/pivot_point/index>` must be set first.
Pivot points will become the center of symmetry.
If the widget is turned on it will always show where the pivot point is.

In Fig. :ref:`fig-mesh-deform-mirror-origins` the pivot point default to
median point of the selection of vertices in *Edit Mode*.
This is a special case of the *Edit Mode* as explained on
the :doc:`pivot point page </editors/3dview/controls/pivot_point/index>`.

.. _fig-mesh-deform-mirror-origins:

.. list-table:: Mirror around the individual origins.

   * - .. figure:: /images/modeling_meshes_editing_mesh_mirror_cursor-before.png
          :width: 320px

          Mesh before mirror.

     - .. figure:: /images/modeling_meshes_editing_mesh_mirror_individual-after.png
          :width: 320px

          Mesh after mirrored along X axis.

In Fig. :ref:`fig-mesh-deform-mirror-cursor` the pivot point is the *3D Cursor*,
the transformation orientation is *Local*, a.k.a. the object space,
and the axis of transformation is X.

.. _fig-mesh-deform-mirror-cursor:

.. list-table:: Mirror around the 3D Cursor.

   * - .. figure:: /images/modeling_meshes_editing_mesh_mirror_cursor-before.png
          :width: 320px

          Mesh before mirror.

     - .. figure:: /images/modeling_meshes_editing_mesh_mirror_cursor-after.png
          :width: 320px

          Mesh after mirrored along X axis using the 3D cursor as a pivot point.


Transformation Orientations
===========================

:doc:`Transformation Orientations </editors/3dview/controls/orientation>`
are found on the 3D Viewport header, next to the *Widget* buttons.
They decide which coordinate system will rule the mirroring.


## Normals

.. _bpy.ops.mesh.normals_tools:
.. _modeling-meshes-editing-normals-editing:

*******
Normals
*******

.. TODO put in ref to weighted normals modifier and bevel tool and modifier.

.. seealso::

   The :doc:`/modeling/modifiers/modify/normal_edit` can be used to edit normals.

   The :doc:`/modeling/modifiers/modify/weighted_normal` can be used to affect normals by various methods,
   including *Face Strength* (see below).

   You can also copy normals from another mesh using Mesh Data Transfer
   (:doc:`operator </scene_layout/object/editing/link_transfer/transfer_mesh_data>`
   or :doc:`modifier </modeling/modifiers/modify/data_transfer>`).


.. _bpy.ops.mesh.flip_normals:

Flip
====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Flip`

This will reverse the normals direction of all selected faces.
Note that this allows you to precisely control the direction
(**not** the orientation, which is always perpendicular to the face) of your normals,
as only the selected faces are flipped.


.. _bpy.ops.mesh.normals_make_consistent:

Recalculate
===========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Recalculate Outside` and
               :menuselection:`Mesh --> Normals --> Recalculate Inside`
   :Shortcut:  :kbd:`Shift-N` and :kbd:`Shift-Ctrl-N`

These tools will recalculate the normals of selected faces so that they point outside
(respectively inside) the volume that the face belongs to.
The volume does not need to be closed; inside and outside are determined by the angles with adjacent faces.
This means that the face of interest must be adjacent to at least one non-coplanar other face.
For example, with a *Grid* primitive, recalculating normals does not have a meaningful result.


.. _bpy.ops.mesh.set_normals_from_faces:

Set from Faces
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Set from Faces`

Set the custom normals at corners to be the same as the face normal that the corner is part of.


.. _bpy.ops.transform.rotate_normal:

Rotate
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Rotate`
   :Shortcut:  :kbd:`R N`

This is an interactive tool. As you move the mouse around, the selected normals are rotated.
You can also invoke the Rotate Normals tool by pressing the Rotate transform key :kbd:`R`,
followed by :kbd:`N`.


.. _bpy.ops.mesh.point_normals:

Point to Target
===============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Point to Target`
   :Shortcut:  :kbd:`Alt-L`

All selected normals are set to point from their vertex to the target
after confirmed by :kbd:`Return` or :kbd:`LMB`.

A target is set by the keys:

- The mouse cursor :kbd:`M`
- The pivot :kbd:`L`
- The object origin :kbd:`O`
- The cursor (set at this click) :kbd:`Ctrl-LMB`
- A mesh item selection (set by this click) :kbd:`Ctrl-RMB`

Mode
   The tool operation can be modified; if one of the following keys has been previously pressed:

   Align :kbd:`A`
      All normals will point in the same direction: from the center of selected points to the target.
   Spherize :kbd:`S`
      Each normal will be an interpolation between its original value and the direction to the target.
   Invert :kbd:`I`
      The normal directions are reversed from what was specified above.

Reset :kbd:`R`
   Will reset the custom normals back to what they were when the operation started.


.. _bpy.ops.mesh.merge_normals:

Merge
=====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Merge`

Merge all of the normals at selected vertices, making one average normal for all of the faces.


.. _bpy.ops.mesh.split_normals:

Split
=====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Split`

Split the normals at all selected vertices so that there are separate normals for each face,
pointing in the same direction as those faces.


.. _bpy.ops.mesh.average_normals:

Average
=======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Average`

Average all of the normals in each fan of faces between sharp edges at a vertex.


Copy Vectors
============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Copy Vectors`

If a single normal is selected, copy it to an internal vector buffer.


Paste Vectors
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Paste Vectors`

Replace the selected normals with the one in the internal vector buffer.


.. _bpy.ops.mesh.smooth_normals:

Smooth Vectors
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Smooth Vectors`

Adjust the normals to bring them closer to their adjacent vertex normals.


Reset Vectors
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Reset Vectors`

Put normals back the to default calculation of the normals.


.. _bpy.ops.mesh.mod_weighted_strength:

Select by Face Strength
=======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Select by Face Strength`

Another way to affect normals is to set a *Face Strength* on the faces of the model.
The Face Strength can be either *Weak*, *Medium*, or *Strong*.
The idea is that the :doc:`/modeling/modifiers/modify/weighted_normal` can
be set to pay attention to the Face Strength as follows:
When combining the normals that meet at a vertex, only the faces
with the strongest Face Strength will contribute to the final value.

For example, if three faces meet at a vertex and have the face weights weak, medium, and strong,
then only the normal associated with the strong face will be used to set the final result.

Use the submenu to pick one of *Weak*, *Medium*, or *Strong*.
Then this tool selects those faces that have the chosen face strength.


Set Face Strength
=================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Normals --> Set Face Strength`

Use the submenu to pick one of *Weak*, *Medium*, or *Strong*.
Then this tool changes the Face Strength of currently selected faces to the chosen face strength.


## Separate

.. _bpy.ops.mesh.separate:
.. _object-separate:

********
Separate
********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Separate`
   :Shortcut:  :kbd:`P`

At some point, you will come to a time when you need to cut parts away from a mesh to be separate.

To separate an object, the vertices (or faces) must be selected and then separated,
though there are several different ways to do this.

.. figure:: /images/modeling_meshes_editing_mesh_separate_example.png

   Suzanne dissected neatly.

Selection
   Separates the selected elements.
By Material
   Separates fragments based on the materials assigned to the different faces.
By Loose Parts
   Creates one object for every independent (disconnected) fragment of the original mesh.

.. seealso::

   :ref:`Joining objects <object-join>`.


## Set Attribute

.. _bpy.ops.mesh.attribute_set:

*************
Set Attribute
*************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Set Attribute`

Sets the value of the :term:`Active` :term:`Attribute` for the selected element.
"Active attribute" here means the attribute that is currently selected in the
:ref:`Attributes list <bpy.types.AttributeGroup>`.

When the operator is executed a pop-up window will display the attribute's name and current value.
From here, the value field came be adjusted to change the attribute's value.

.. seealso::

   Attribute values can be viewed in the :doc:`/editors/spreadsheet` editor.


## Shading

.. _modeling-meshes-editing-normals-shading:

*******
Shading
*******

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Shading`

Alternatively, you can choose which faces to smooth by entering *Edit Mode*,
then selecting some faces and picking *Shade Smooth* from the *Face Menu*.

When the mesh is in *Edit Mode*,
only the selected faces will receive the "smoothing" attribute.
You can set faces as flat (removing the "smoothing" attribute)
in the same way by selecting edges and picking the *Shade Flat* from the *Face Menu*.


## Snap Symmetry

.. _bpy.ops.mesh.symmetry_snap:

****************
Snap to Symmetry
****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Snap to Symmetry`

The Snap to Symmetry tool lets you snap a mesh vertices to their mirrored neighbors.

Useful when dealing with meshes which are mostly symmetrical,
but have vertices which have been moved enough that Blender
does not detect them as mirrored (when X Mirror option is enabled for example).

This can be caused by accident when editing without X Mirror enabled. Sometimes models
imported from other applications are asymmetrical enough that mirror fails too.

Direction
   Specify the axis and direction to snap. Can be any of the three axes,
   and either positive to negative, or negative to positive.
Threshold
   Specify the search radius to use when finding matching vertices.
Factor
   Support for blending mirrored locations from one side to the other (0.5 is an equal mix of both).
Center
   Snap vertices along the center axis to zero.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_snap-symmetry_before.png
          :width: 320px

          Before Snap to Symmetry.

     - .. figure:: /images/modeling_meshes_editing_mesh_snap-symmetry_after.png
          :width: 320px

          After Snap to Symmetry.


## Sort Elements

.. _bpy.ops.mesh.sort_elements:
.. _mesh-edit-sort-elements:

*************
Sort Elements
*************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Sort Elements...`

This tool (available from the context menu, *Vertices*, *Edges* and *Faces* menus)
allows you to reorder the matching selected mesh elements, following various methods.
Note that when called from the context menu,
the affected element types are the same as the active select modes.

View Z Axis
   Sort along the active view's Z axis, from farthest to nearest by default
   (use *Reverse* if you want it the other way).
View X Axis
   Sort along the active view's X axis, from left to right by default (again, there is the *Reverse* option).
Cursor Distance
   Sort from nearest to farthest away from the 3D cursor position (*Reverse* also available).
Material
   Sort faces, and faces only, from those having the lowest material's index to those having the highest.
   Order of faces inside each of those "material groups" remains unchanged.
   Note that the *Reverse* option only reverses the order of the materials,
   *not* the order of the faces inside them.
Selected
   Move all selected elements to the beginning (or end, if *Reverse* enabled),
   without affecting their relative orders.
   Warning: This option will also affect **unselected** elements' indices!
Randomize
   Randomizes indices of selected elements (*without* affecting those of unselected ones).
   The seed option allows you to get another randomization --
   the same seed over the same mesh or set of selected elements will always give the same result!
Reverse
   Simply reverse the order of the selected elements.

.. hint:: Enabling the Display Indices Option

   Enable the *Developer Extras* Option in :menuselection:`Preferences --> Interface --> Display` panel,
   a checkbox will appear in :menuselection:`Display & Shading Menu --> Viewport Overlay --> Developer --> Indices`.


## Split

.. _bpy.ops.mesh.split:

*****
Split
*****

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Split`
   :Shortcut:  :kbd:`Alt-M`


Selection
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Split --> Selection`
   :Shortcut:  :kbd:`Y`

Splits (disconnects) the selection from the rest of the mesh.
The border edge to any non-selected elements are duplicated.

Note that the "copy" is left exactly at the same position as the original, so you must move it
:kbd:`G` to see it clearly...


.. _bpy.ops.mesh.edge_split:

Faces by Edges
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Split --> Faces by Edges`

*Faces by Edges* is similar to the *Rip* tool. When two or more touching interior edges,
or a border edge is selected, a hole will be created,
and the selected edges will be duplicated to form the border of the hole.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_split_edges-before.png
          :width: 320px

          Selected edges.

     - .. figure:: /images/modeling_meshes_editing_mesh_split_edges-after.png
          :width: 320px

          Adjacent face moved to reveal hole left by split.


Faces & Edges by Vertices
=========================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Split --> Faces & Edges by Vertices`

*Faces & Edges by Vertices* is similar to *Faces by Edges* except that
it also splits the vertices of the adjacent connecting edges.
This has the same functionality as manually ripping all faces and edges away from a vertex.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_split_faces-before.png
          :width: 320px

          Before.

     - .. figure:: /images/modeling_meshes_editing_mesh_split_faces-after.png
          :width: 320px

          After (also moving edges away).


## Symmetrize

.. _bpy.ops.mesh.symmetrize:

**********
Symmetrize
**********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Symmetrize`

The *Symmetrize* tool is a quick way to make a mesh symmetrical.
*Symmetrize* works by cutting the mesh at the pivot point of the object,
and mirroring over the geometry in the specified axis, and merges the two halves together
(if they are connected). Also the mesh data is copied from one side to the other:
e.g. UVs, colors attributes, vertex weights.

Direction
   Specify the axis and direction of the effect. Can be any of the three axes,
   and either positive to negative, or negative to positive.
Threshold
   The vertices in this range will be snapped to the plane of symmetry.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_symmetrize_example-1.png
          :width: 320px

          Mesh before Symmetrize.

     - .. figure:: /images/modeling_meshes_editing_mesh_symmetrize_example-2.png
          :width: 320px

          Mesh after Symmetrize.

.. seealso::

   See :doc:`Mirror </modeling/meshes/editing/mesh/mirror>`
   for information on mirroring, which allows you to flip geometry across an axis.


## Basic


*******************
Move, Rotate, Scale
*******************

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Move, Rotate, Scale`
   :Menu:      :menuselection:`Mesh --> Transform --> Move, Rotate, Scale`
   :Shortcut:  :kbd:`G`, :kbd:`R`, :kbd:`S`

Once you have a selection of one or more elements, you can move :kbd:`G`,
rotate :kbd:`R` or scale :kbd:`S` them, like many other things in Blender,
as described in the :doc:`Manipulation in 3D Space </scene_layout/object/editing/transform/introduction>` section.
To move, rotate and scale selected components, either use the *Move*, *Rotate*, and *Scale* buttons,
the :doc:`transform gizmos </editors/3dview/display/gizmo>`,
or the shortcuts: :kbd:`G`, :kbd:`R`, and :kbd:`S` respectively.

After moving a selection, the options in the :ref:`bpy.ops.screen.redo_last` panel allow you to
fine-tune your changes, limit the effect to certain axes, turn Proportional Editing on and off, etc.
Of course, when you move an element of a given type (e.g. an edge),
you also modify the implicitly related elements of other kinds (e.g. vertices and faces).

Pressing :kbd:`G` twice enters either *Edge Slide* or *Vertex Slide* tool depending on the selection.
You also have in *Edit Mode* an extra option when using these basic manipulations:
the :doc:`Proportional Editing </editors/3dview/controls/proportional_editing>`.


.. _modeling-mesh-transform-panel:

Transform Panel
===============

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Sidebar region --> Transform`

When nothing is selected, the panel is empty.
When more than one vertex is selected, the median values is edited
and "Median" is added in front of the labels.

Vertex
   The first controls (X, Y, Z) show the coordinates of the selected vertex or the median point.
Space
   The Space radio buttons let you choose if those coordinates are relative to the object origin (local) or
   the global origin (global).

   Global, Local


Vertex Data
-----------

.. _modeling-vertex-bevel-weight:

Bevel Weight
   This vertex property, a value between (0.0 to 1.0),
   is used by the :doc:`Bevel Modifier </modeling/modifiers/generate/bevel>`
   to control the bevel intensity of the vertices, when the *Only Vertices* option is active.

.. _modeling-vertex-crease-subdivision:

Crease
   This vertex property, a value between (0.0 to 1.0), is used by
   the :doc:`Subdivision Surface Modifier </modeling/modifiers/generate/subdivision_surface>`
   to control the sharpness of the vertices in the subdivided mesh.


Edge Data
---------

When an edge is selected, the following options are available. More buttons appear:

.. _modeling-edges-bevel-weight:

Bevel Weight
   This edge property, a value between (0.0 to 1.0),
   is used by the :doc:`Bevel Modifier </modeling/modifiers/generate/bevel>`
   to control the bevel intensity of the edges.

   This property can also be set using the :ref:`bpy.ops.transform.edge_bevelweight` operator.

.. todo move to attribute page
.. _modeling-edges-crease-subdivision:

Crease
   This edge property, a value between (0.0 to 1.0), is used by
   the :doc:`Subdivision Surface Modifier </modeling/modifiers/generate/subdivision_surface>`
   to control the sharpness of the edges in the subdivided mesh.


## Bend

.. _bpy.ops.transform.bend:

****
Bend
****

.. reference::

   :Mode:      Object and Edit Modes
   :Menu:      :menuselection:`Object/Mesh/Curve/Surface --> Transform --> Bend`
   :Shortcut:  :kbd:`Shift-W`

.. list-table:: Bend Transform with Clamp on and off.

   * - .. figure:: /images/modeling_meshes_editing_mesh_transform_bend_example-clamp-1.png
          :width: 320px

          Before.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_bend_example-clamp-2.png
          :width: 320px

          Clamp on.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_bend_example-clamp-3.png
          :width: 320px

          Clamp off.

This tool rotates a line of selected elements forming an arc between the mouse cursor and the 3D cursor.


Usage
=====

The *Bend* tool can be used in any case where you might want to bend a shape in two
with a gradual transition between both sides.

This may take a little getting used to, the basics are listed below controls are noted here:

- The initial position of the cursors define the axis to bend on.
- The distance of the mouse cursor to the 3D cursor controls how sharp the bend will be.
- The relative angle of the mouse cursor to the initial axis defines the bend angle.

If this seems overly complicated, it's probably best to try the tool
where it becomes quickly apparent how the tool reacts to your input.

Bend Angle
   The amount of rotation.
Radius
   The sharpness of the bend.
Clamp
   Normally the arc turns through a clamped rotation angle with the selected elements extended along
   a tangent line beyond that (see above left).
   When the clamp is deactivated, the arc continues around aligning the selected elements into a circle (right).

   When off :kbd:`Alt` all selected elements follow a circle,
   even when outside the segment between the 3D cursor and the mouse.

.. note::

   Unlike most other transform modes, *Bend* is not effected by *Pivot Point* or *Transform Orientation*,
   always using the View Plane instead.

.. hint::

   You can turn the bend angle through multiple rotations potentially forming a spiral shape.

.. figure:: /images/modeling_meshes_editing_mesh_transform_bend_example-usage.png

   Bend Transform example.


Known Limitations
=================


Adjust Last Operation Unsupported
---------------------------------

Since the bend tool relies on cursor input, it does not support adjusting the last bend operation.


## Index


##################
  Transformation
##################

.. toctree::
   :maxdepth: 1

   basic.rst
   to_sphere.rst
   shear.rst
   bend.rst
   push_pull.rst
   warp.rst
   randomize.rst
   shrink-fatten.rst
   skin_resize.rst


## Push Pull

.. _bpy.ops.transform.push_pull:
.. _tool-transform-push_pull:

*********
Push/Pull
*********

.. reference::

   :Mode:      Object and Edit Modes
   :Tool:      :menuselection:`Toolbar --> Shrink/Flatten --> Push/Pull`
   :Menu:      :menuselection:`Object/Mesh --> Transform --> Push/Pull`

.. figure:: /images/modeling_meshes_editing_mesh_transform_push-pull_operator-panel.png
   :align: right

   Push/Pull distance.

*Push/Pull* will move the selected elements (objects, vertices, edges or faces)
closer together (Push) or further apart (Pull).
Specifically, each element is moved towards or away from the center by the same distance.
This distance is controlled by moving the mouse up (Push) or down (Pull), numeric input or through slider control.


Usage
=====

See below for the result of using *Push/Pull* on a number of different elements.

.. figure:: /images/modeling_meshes_editing_mesh_transform_push-pull_objects-equidistant.png

   Equidistant objects being pushed together.

.. figure:: /images/modeling_meshes_editing_mesh_transform_push-pull_objects-random.png

   Random objects being pushed together.

.. figure:: /images/modeling_meshes_editing_mesh_transform_push-pull_vertices.png

   Push (middle) vertices around the 3D cursor compared to Scale (right).


## Randomize

.. _bpy.ops.transform.vertex_random:

*********
Randomize
*********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Transform --> Randomize`

The *Randomize* tool in Edit Mode allows you to displace the vertices of a mesh
along their normal.

Amount
   Distance of the displacement.
Uniform
   Adds a random offset of the amount.
Normal
   Adds a random offset to the displacement normal.
Random Seed
   The random seed is an offset to the random transformation.
   A different seed will produce a new result.


.. seealso::

   Object Mode :doc:`Randomize Transform </scene_layout/object/editing/transform/randomize>`


## Shear

.. _bpy.ops.transform.shear:
.. _tool-transform-shear:

*****
Shear
*****

.. reference::

   :Mode:      Object and Edit Mode
   :Tool:      :menuselection:`Toolbar --> Shear`
   :Menu:      :menuselection:`Object/Mesh/Curve/Surface --> Transform --> Shear`
   :Shortcut:  :kbd:`Shift-Ctrl-Alt-S`

Shearing is a form of movement where parallel surfaces move past one another. During this transform,
movement of the selected elements will occur along the horizontal axis of the current view.
The axis location will be defined by
the :doc:`Pivot Point </editors/3dview/controls/pivot_point/index>`.
Everything that is "above" this axis will move (shear)
in the same direction as your mouse pointer (but always parallel to the horizontal axis).
Everything that is "below" the horizontal axis will move in the opposite direction.

.. figure:: /images/modeling_meshes_editing_mesh_transform_shear_operator-panel.png

   Shear Offset Factor.


Tool Settings
=============

Offset
   How far items are shifted from their original location.
Axis
   Defines one axis of the imaginary shearing plane.
Axis Orthographic
   Defines the other axis of the imaginary shearing plane.
Orientation
   See :doc:`Transform Orientations </editors/3dview/controls/orientation>`.
Proportional Editing
   See :doc:`Proportional Editing </editors/3dview/controls/proportional_editing>`.

.. warning::

   The *Axis* and *Axis Orthographic* cannot be the same axis,
   else the imaginary plane is dimensionless and the objects will disappear into a point.


Usage
=====

See below for the result of using *Shear* on a number of different elements.

.. figure:: /images/modeling_meshes_editing_mesh_transform_shear_mesh.png

   The effects of a Shear transform with different Pivot Points.

The three frames of the image above show the effects of shearing
on the selected vertices when the pivot point is altered.
In middle frame, the :doc:`Pivot Point </editors/3dview/controls/pivot_point/index>`
is set to *Median Point* and the mouse was moved to the left during the transform.
In right frame, the *Pivot Point* is set to the 3D cursor which is located above the mesh.
When the mouse is moved to the left during a *Shear* transform,
the selected vertices are moved to the right as they are below the horizontal axis.

.. tip:: Shear Transform Magnitude

   The magnitude of the *Shear* transform applied to the selected elements is
   directly proportional to the distance from the horizontal axis.
   i.e. the further it is away from the axis, the greater the movement.

.. figure:: /images/modeling_meshes_editing_mesh_transform_shear_objects.png

   The effects of a Shear transform on objects with different Pivot Points.


## Shrink-Fatten

.. _bpy.ops.transform.shrink_fatten:
.. _tool-mesh-shrink-fatten:

*************
Shrink Fatten
*************

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Shrink/Fatten`
   :Menu:      :menuselection:`Mesh --> Transform --> Shrink Fatten`
   :Shortcut:  :kbd:`Alt-S`

This tool moved selected vertices/edges/faces along their own normal
(perpendicular to the face), which, on "standard normal meshes", will shrink/fatten them.

This transform tool does not take into account the pivot point or transform orientation.

Offset Even :kbd:`S`, :kbd:`Alt`
   Scale the offset to give it a more even thickness.
   A greater offset factor is obtained vertices, which share faces, forming a more acute angle.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_mesh_transform_shrink-fatten_before.png
          :width: 200px

          Mesh before shrink/fatten.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_shrink-fatten_inflate-positive.png
          :width: 200px

          Inflated using a positive value.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_shrink-fatten_inflate-negative.png
          :width: 200px

          Shrunk using a negative value.


## Skin Resize

.. _bpy.ops.transform.skin_resize:

***********
Skin Resize
***********

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Transform --> Skin Resize`
   :Shortcut:  :kbd:`Ctrl-A`

This tool is used to set a skin radius per vertex when using
a :doc:`Skin Modifier </modeling/modifiers/generate/skin>`.
Non-uniform scaling of the X and Y axes is accessible by the usual axis locking
with :kbd:`X` or :kbd:`Y`. The radius can also be adjusted in the *Transform* panel of
the Sidebar, in the 3D Viewport. The mean radius of all vertices can be previewed
in the 3D Viewport as a dashed circle around a vertex.

.. figure:: /images/modeling_modifiers_generate_skin_example.png

   Simple creature, made with only the Skin and Subdivision Surface modifiers.


## To Sphere

.. _bpy.ops.transform.tosphere:
.. _tool-transform-to_sphere:

*********
To Sphere
*********

.. reference::

   :Mode:      Object and Edit Modes
   :Menu:      :menuselection:`Mesh --> Transform --> To Sphere`
   :Shortcut:  :kbd:`Shift-Alt-S`

The *To Sphere* transformation will give the selection spherical qualities.
The Fig. :ref:`fig-mesh-deform-to-sphere-monkey` below shows the results of applying
the *To Sphere* transformation to the monkey mesh.

.. _fig-mesh-deform-to-sphere-monkey:

.. figure:: /images/modeling_meshes_editing_mesh_transform_to-sphere_suzanne-spherical.png

   Monkey with increasing sphericity.

   The sequence above shows a monkey mesh with
   a 0, 0.25 (25%), 0.5 (50%) and 1 (100%) To Sphere transform applied.


Usage
=====

.. figure:: /images/modeling_meshes_editing_mesh_transform_to-sphere_operator-panel.png

   To Sphere Factor.

As can be seen in the below image, the result
will be smoother and more spherical when there are more mesh elements available to work with.

.. figure:: /images/modeling_meshes_editing_mesh_transform_to-sphere_cubes-spherical.png

   To Sphere applied to cubes with different subdivision levels.

   In this image sequence, To Sphere was applied to the entire cube
   at levels of 0, 0.25 (25%), 0.5 (50%) and 1 (100%) respectively.

The *To Sphere* transform will generate different results depending on the number
and arrangement of elements that were selected (as shown by the below image).

.. figure:: /images/modeling_meshes_editing_mesh_transform_to-sphere_other-spherical.png

   To Sphere applied to different selections.


## Warp


****
Warp
****

.. reference::

   :Mode:      Edit Modes
   :Menu:      :menuselection:`Object/Mesh/Curve/Surface --> Transform --> Warp`

.. figure:: /images/modeling_meshes_editing_mesh_transform_warp_operator-panel.png
   :align: right

   Warp options.

The *Warp* transformation takes selected elements and
warps them around the 3D cursor by a certain angle.
Note that this transformation is always dependent on the location of the 3D cursor.
The Pivot Point is not taken into account.
The results of the *Warp* transformation are also view dependent.


Usage
=====

.. list-table:: In this example, a plane is warped around the 3D cursor by the indicated number of degrees.

   * - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_mesh.png

          Before.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_mesh-90.png

          Warp Angle 90.

   * - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_mesh-180.png

          Warp Angle 180.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_mesh-360.png

          Warp Angle 360.


Cursor Position & View
----------------------

The location of the 3D cursor can be used to alter the results of the *Warp* transformation.
As can be seen from the example in this section, the *Warp* radius
is dependent on the distance of the cursor from the selected elements.
The greater the distance, the greater the radius.

The result of the *Warp* transform is also influenced by your current view.
The example in this section shows the results of a 180 degree *Warp* transform applied
to the same Plane mesh when in different views.

.. list-table:: This image shows how the Warp transform is influenced by the location of the cursor.

   * - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_mesh.png

          Before.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_mesh-180.png

          Warp Angle 180.

   * - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_mesh-cursor.png

          Before.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_mesh-cursor-180.png

          Warp Angle 180.

.. list-table:: This image shows the influence of the current view.

   * - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_view-1.png

          Before.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_view-2.png

          Warp Angle 180 in XZ view.

   * - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_view-3.png

          Warp Angle 180 in YZ view.

     - .. figure:: /images/modeling_meshes_editing_mesh_transform_warp_view-4.png

          Warp Angle 180 in User view.

.. note:: Warping text

   If you want to warp text, you will need to convert it from a text object to mesh
   using :ref:`object-convert-to`.


Example
=======

.. figure:: /images/modeling_meshes_editing_mesh_transform_warp_text.jpg

   Text wrapped around logo.

This was made by creating the Blender logo and text as separate objects.
The text was converted to a mesh and then warped around the Blender logo.


## Bevel Vertices

.. _bpy.ops.mesh.bevel.vertex:

**************
Bevel Vertices
**************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Edge --> Bevel Edges`
   :Shortcut:  :kbd:`Ctrl-B` (Bevel Edges)
   :Menu:      :menuselection:`Vertex --> Bevel Vertices`
   :Shortcut:  :kbd:`Shift-Ctrl-B` (Bevel Vertices)

The *Bevel* tool rounds off edges or corners of a mesh at the point of the selected vertices.
In "vertex only" mode, the *Bevel Vertices* tool works on selected vertices
but the option to switch to *Bevel Edges* is available.
By doing so, more vertices are added in order to smooth out profiles with a specified number of *segments*
(see the options below for details about the bevel algorithm).

.. figure:: /images/modeling_meshes_editing_vertex_bevel-vertices_compare.png
   :align: center

   Cubes with and without bevel.

.. note::

   With the Vertex Only option active, some of the other options available will not work.
   However, they will work with :doc:`Bevel Edges </modeling/meshes/editing/edge/bevel>`.


Options
=======

Affect :kbd:`V`
   :Vertices:
      Only the areas near vertices are beveled, the edges remain unchanged.
   :Edges:
      Bevel the edges, creating intersections at vertices.

Offset :kbd:`A`
   You can change the bevel amount by moving the mouse towards and away from the object,
   like with transform tools.
   The exact meaning of the value depends on the *Amount Type* option (see below).

Width Type :kbd:`M`
   Selects how the *Amount* value controls the size of the bevel. According to the selection, the amount is:

   :Offset:
      The relative distance from the new edge to the original.
   :Width:
      The distance between the two new edges formed by the bevel
      (or the edges on either side of the bevel if there is more than one segment).
   :Depth:
      The perpendicular distance from the original edge to the bevel face.
   :Percent:
      The percentage of the length of adjacent edges that the new edges are slid along.
   :Absolute:
      The exact distance along edges adjacent to the beveled edge.
      A difference from *Offset* is visible when the unbeveled edges
      attached to beveled edges meet at an angle besides a right angle.

   For vertex-only bevels, the Offset and Depth types measure from the original vertex,
   and the Width type is measured from a new vertex to the center of the new face (as half the amount).

Segments :kbd:`S`
   The number of segments in the bevel can be defined by
   scrolling the mouse :kbd:`Wheel` to increase or decrease this value.
   The greater the number of segments, the smoother the bevel.
   Or press :kbd:`S` to change the number with mouse movements, as well as numeric input.

   Alternatively, you can manually enter a segment number value while using the tool,
   or in the Mesh Tool options panel after using the tool.

   .. figure:: /images/modeling_meshes_editing_vertex_bevel-vertices_segments.png
      :width: 320px

      Bevel with four segments.

Shape :kbd:`P`
   This is a number between 0 and 1 that controls the shape of the profile (side view of a beveled edge).
   The default value, 0.5, gives a circular arc (if the faces meet at right angles).
   Values less than that give a flatter profile, with 0.25 being exactly flat,
   and values less than that giving a concave bevel. Values more than 0.5 give a more convex profile.
   Similarly as *Segments* it can be set with mouse movements and numeric input after toggling :kbd:`P`.

Material Index
   The *Material* number specifies which material should be assigned to the new faces created by the *Bevel* tool.
   With the default, -1, the material is inherited from the closest existing face ("closest" can be a bit ambiguous).
   Otherwise, the number is the slot index of the material to use for all newly created faces.

Harden Normals :kbd:`H`
   When enabled, the per-vertex face normals of the bevel faces are adjusted to
   match the surrounding faces, and the normals of the surrounding faces are not affected.
   This will keep the surrounding faces flat (if they were before),
   with the bevel faces shading smoothly into them. For this effect to work,
   a mesh must have :ref:`custom split normals <modeling_meshes_normals_custom>`.
   As a convenience, that option will be enabled for you if it is not already when you enable Harden Normals here.

Clamp Overlap :kbd:`C`
   Limits the width of each beveled edge so that vertices do not overlap with other geometry.

Loop Slide
   If there are un-beveled edges along with beveled edges into a vertex,
   the bevel tries to slide along those edges when possible.
   Turning the option off can lead to more even bevel widths.

Face Strength Mode
   Set *Face Strength* on the faces involved in the bevel, according to the specified mode.
   This can be used in conjunction with
   a :doc:`Weight Normals Modifier </modeling/modifiers/modify/weighted_normal>`
   (with the *Face Influence* option checked).

   :None:
      Do not set face strength.
   :New:
      Set the face strength of new faces along edges to *Medium*,
      and the face strength of new faces at vertices to *Weak*.
   :Affected:
      In addition to those set for the *New* case,
      also set the faces adjacent to new faces to have strength *Strong*.
   :All:
      In addition to those set for the *Affected* option,
      also set all the rest of the faces of the model to have strength *Strong*.

Profile Type :kbd:`Z`
   :Superellipse:
      Creates a bevel with a uniform concave or convex curve.
   :Custom:
      .. figure:: /images/modeling_modifiers_generate_bevel_profile-widget.png
         :align: right
         :width: 300px

         The custom profile widget.

      This widget allows the creation of a user-defined profile with more complexity than
      with the single profile parameter. The modal tool allows toggling the custom profile,
      but the shape of the profile is only editable in the options panel after the operation is confirmed.

      The profile starts at the bottom right of the widget and ends at the top left, as if it
      were between two edges intersecting at a right angle. Control points are created in the widget and
      then the path is sampled with the number of segments from the Bevel modifier.

      Presets
         The *Support Loops* and *Steps* presets are built dynamically depending on the number
         of segments in the bevel. If the number of segments is changed, the preset will have to be re-applied.

   Sampling
      Samples will first be added to each control point, then if there are enough samples,
      they will be divided evenly between the edges. The *Sample Straight Edges* option toggles
      whether the samples are added to edges with sharp control points on either side.
      If there aren't enough samples to give each edge the same number of samples,
      they will just be added to the most curved edges.
      So it is recommended to use at least as many segments as there are control points.

   .. list-table:: Bevel with Custom Profile on.

      * - .. figure:: /images/modeling_meshes_editing_vertex_bevel-vertices_customA.png
             :width: 300px

             Edge Bevel.

        - .. figure:: /images/modeling_meshes_editing_vertex_bevel-vertices_customB.png
             :width: 300px

             Vertex Bevel.

.. seealso::

   The :doc:`Bevel Modifier </modeling/modifiers/generate/bevel>`
   is a non-destructive alternative to the Bevel tool.


## Blend Shape

.. _bpy.ops.mesh.blend_from_shape:
.. _modeling-meshes-editing-vertices-shape-keys:

****************
Blend from Shape
****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Blend from Shape`

Blend in the shape from a :doc:`shape key </animation/shape_keys/index>`.


## Connect Vertex Pairs

.. _bpy.ops.mesh.vert_connect:

********************
Connect Vertex Pairs
********************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Connect Vertex Pairs`

This operator connects selected vertices by creating edges between them and splitting the face.
It can be used on many faces at once.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_connect-vertex-pairs_before.png
          :width: 180px

          Vertices before connecting.

     - .. figure:: /images/modeling_meshes_editing_vertex_connect-vertex-pairs_after.png
          :width: 180px

          After connecting vertices.

     - .. figure:: /images/modeling_meshes_editing_vertex_connect-vertex-pairs_after-faces.png
          :width: 180px

          Resulting face pair.

The main difference between this operator and :doc:`/modeling/meshes/editing/vertex/connect_vertex_path`
is that this operator ignores the selection order and connects all selected vertices that share a face.


## Connect Vertex Path

.. _bpy.ops.mesh.vert_connect_path:

*******************
Connect Vertex Path
*******************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Connect Vertex Path`
   :Shortcut:  :kbd:`J`

This tool connects vertices in the order they are selected, splitting the faces between them.
When there are only two vertices selected, a cut will be made across unselected faces,
a bit like the Knife tool; but this is limited to straight cuts across connected faces.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_connect-vertex-path_pair-before.png

          Two disconnected vertices.

     - .. figure:: /images/modeling_meshes_editing_vertex_connect-vertex-path_pair-after.png

          Result of connecting.

Running a second time will connect the first/last endpoints.
When many vertices are selected, faces will be split by their selected vertices.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_connect-vertex-path_multi-before.png

          Before.

     - .. figure:: /images/modeling_meshes_editing_vertex_connect-vertex-path_multi-after.png

          After.

Vertices not connected to any faces will create edges,
so this can be used as a way to quickly connect isolated vertices too.


## Extrude Cursor

.. _bpy.ops.mesh.dupli_extrude_cursor:

************************
Extrude to Cursor or Add
************************

.. reference::

   :Mode:      Edit Mode
   :Shortcut:  :kbd:`Ctrl-RMB`

Interactively places new vertices with :kbd:`Ctrl-RMB` at the mouse cursor position.

The most basic element, a vertex, can be added with a :kbd:`Ctrl-RMB` click
when no other vertices are selected.
Because the camera space (computer screen) is two-dimensional,
Blender cannot determine all three vertex coordinates from a single mouse click,
so the new vertex is placed at the depth of the 3D cursor.

To create interconnected vertices, you can add a vertex and continuously make subsequent :kbd:`Ctrl-RMB`
operations with the last vertex selected.
This will link the last selected vertex with the vertex created at the mouse position with an edge
(see Fig. :ref:`fig-mesh-basics-add-one`),
and will continuously create and connect new vertices if you continue repeating this operation.

.. _fig-mesh-basics-add-one:

.. figure:: /images/modeling_meshes_tools_extrude-cursor_vertex.png

   Adding vertices one by one.


Creating Faces
==============

.. figure:: /images/modeling_meshes_tools_extrude-cursor_quad.png

   Quad from an Edge with source automatically rotated.

If you have two vertices selected and already connected with an edge, :kbd:`Ctrl-RMB` click
will create a planar face, also known as a quad. Blender will follow your mouse cursor
and will use the planar view from your viewport to create those quads.

For :kbd:`Ctrl-RMB`, Blender will automatically rotate the last selected Edge (the source)
for the subsequent operations if you have at least one face created, dividing the angles created between
the newly created edge and the last two edges, creating a smooth angle between them. Blender will calculate
this angle using the last positive and negative position of the last X and Y coordinates
and the last connected unselected edge. If this angle exceeds a negative limit (following a quadrant rule)
between the recently created edge and the last two, Blender will wrap the faces.
But if you do not want Blender to rotate and smooth edges automatically when extruding from :kbd:`Ctrl-RMB`,
you can also inhibit Blender from rotating sources using the shortcut :kbd:`Shift-Ctrl-RMB`.
In this case, Blender will not rotate the source dividing the angle between those edges when creating a face.

If you have three or more vertices selected, and :kbd:`Ctrl-RMB` click,
you will also create planar faces, but along the vertices selected, following the direction of the cursor.
This operation is similar to an extrude operation.

.. tip::

   When adding objects with :kbd:`Ctrl-RMB`, the extrusions of the selected elements,
   being vertices, edges and faces with the :kbd:`Ctrl-RMB`, are viewport dependent.
   This means, once you change your viewport, for example, from top to left, bottom or right,
   the extrusion direction will also follow your viewport and align the extrusions with your planar view.


## Extrude Vertices

.. _bpy.ops.mesh.extrude_vertices_move:

****************
Extrude Vertices
****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Extrude Vertices`,
               :menuselection:`Mesh --> Extrude --> Extrude Vertices`
   :Shortcut:  :kbd:`E`

Extrude vertices as individual vertices.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_extrude-vertices_before.png
          :width: 320px

          Vertex selected.

     - .. figure:: /images/modeling_meshes_editing_vertex_extrude-vertices_after.png
          :width: 320px

          Vertices extrude.


## Hooks

.. _bpy.ops.object.hook:
.. _bpy.ops.object.hook_add_selob:

*****
Hooks
*****

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Hooks`
   :Shortcut:  :kbd:`Ctrl-H`

Adds a :doc:`Hook Modifier </modeling/modifiers/deform/hooks>`
(using either a new empty, or the current selected object) linked to the selection.
Note that even if it appears in the history menu,
this action cannot be undone in *Edit Mode* -- because it involves other objects...

When the current object has no hooks associated, only the first two options will appear on the menu.

Hook to New Object
   Creates a new Hook Modifier for the active object and assigns it to the selected vertices;
   it also creates an empty at the center of those vertices, which are hooked to it.
Hook to Selected Object
   Does the same as *Hook to New Object*, but instead of hooking the vertices to a new empty,
   it hooks them to the selected object (if it exists).
   There should be only one selected object (besides the mesh being edited).
Hook to Selected Object Bone
   Does the same as *Hook to New Object*,
   but it sets the last selected bone in the also selected armature as a target.
Assign to Hook
   The selected vertices are assigned to the chosen hook. For that to happen,
   a list of the hooks associated to the object is displayed.
   All the unselected vertices are removed from it (if they were assigned to that particular hook).
   One vertex can be assigned to more than one hook.
Remove Hook
   Removes the chosen hook (from the displayed list) from the object.
   Which means that the specific Hook Modifier is removed from its modifier stack.
Select Hook
   Selects all vertices assigned to the chosen hook (from the hook list).
Reset Hook
   It's equivalent to the *Reset* button of the specific Hook Modifier (chosen from the hook list).
Recenter Hook
   It's equivalent to the *Recenter* button of the specific Hook Modifier (chosen from the hook list).


## Index


####################
  Vertex Operators
####################

.. toctree::
   :maxdepth: 2

   extrude_vertices.rst
   extrude_cursor.rst
   bevel_vertices.rst
   make_face_edge.rst
   connect_vertex_path.rst
   connect_vertex_pairs.rst
   rip_vertices.rst
   rip_vertices_fill.rst
   rip_vertices_extend.rst
   slide_vertices.rst
   smooth_vertices.rst
   laplacian_smooth.rst
   blend_shape.rst
   propagate_shapes.rst
   vertex_groups.rst
   hooks.rst
   make_vertex_parent.rst


## Laplacian Smooth

.. _bpy.ops.mesh.vertices_smooth_laplacian:

****************
Laplacian Smooth
****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Context Menu --> Laplacian Smooth`

See the :doc:`Laplacian Smooth Modifier </modeling/modifiers/deform/laplacian_smooth>` for details.

Laplacian smooth uses an alternative smoothing algorithm that better preserves larger details and
this way the overall shape of the mesh. Laplacian smooth exists as a mesh operation and
as a non-destructive modifier.

.. note:: Geometry Smoothing versus Smooth Shading

   Do not mistake this tool with the :ref:`smooth shading <modeling-meshes-editing-normals-shading>` options,
   they do not work the same! This tool modifies the mesh itself, to reduce its sharpness,
   whereas *Set Smooth* only control the way the mesh is shaded,
   creating an *illusion* of softness, but without modifying the mesh at all.


## Make Face Edge

.. _bpy.ops.mesh.edge_face_add:

***************************
New Edge/Face from Vertices
***************************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> New Edge/Face from Vertices`
   :Shortcut:  :kbd:`F`

This is a context-sensitive tool which creates geometry by filling in the selection.
When only two vertices are selected it will create an edge, otherwise it will create faces.

The typical use case is to select vertices and press :kbd:`F`,
yet Blender also supports creating faces from different selections to help to
quickly build up geometry.


Methods
=======

The following methods are used automatically depending on the context.


Isolated Vertices
-----------------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_verts-simple-before.png
          :width: 200px

          Before.

     - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_verts-simple-after.png
          :width: 200px

          After.


Isolated Edges
--------------

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_edge-simple-before.png
          :width: 200px

          Before.

     - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_edge-simple-after.png
          :width: 200px

          After.


N-gon from Edges
----------------

When there are many edges Blender will make an n-gon.
Note that, this does not support holes,
to support holes you need to use the :ref:`modeling-meshes-editing-fill` Faces tool.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_ngon-before.png
          :width: 200px

          Before.

     - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_ngon-after.png
          :width: 200px

          After.


Mixed Vertices/Edges
--------------------

Existing edges are used to make the face as well as an extra vertex.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_mix-simple-before.png
          :width: 200px

          Before.

     - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_mix-simple-after.png
          :width: 200px

          After.


Edge-Net
--------

Sometimes you may have many connected edges without interior faces.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_net-before.png
          :width: 200px

          Before.

     - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_net-after.png
          :width: 200px

          After.


Point Cloud
-----------

When there are many isolated vertices,
Blender will calculate the edges for an n-gon.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_cloud-before.png
          :width: 200px

          Before.

     - .. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_cloud-after.png
          :width: 200px

          After.


Single Vertex Selection
-----------------------

With a single vertex selected on a boundary,
the face will be created along the boundary,
this saves manually selecting the other two vertices.
Notice this tool can run multiple times to continue creating faces.

.. figure:: /images/modeling_meshes_editing_vertex_make-face-edge_create-boundary.png

.. seealso::

   For other ways to create faces see:

   - :ref:`Fill <modeling-meshes-editing-fill>`
   - :ref:`Grid Fill <modeling-meshes-editing-grid-fill>`
   - :ref:`Bridge Edge Loops <modeling-meshes-editing-bridge-edge-loops>`


.. _modeling-mesh-make-face-edge-dissolve:

Dissolve Existing Faces
-----------------------

When you have a region of existing faces, creating a face on this selection
will remove the shared vertices and edges, creating a single face.

This is simply a convenience for accessing :ref:`bpy.ops.mesh.dissolve_faces`.


## Make Vertex Parent

.. _bpy.ops.object.vertex_parent_set:

******************
Make Vertex Parent
******************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Make Vertex Parent`
   :Shortcut:  :kbd:`Ctrl-P`

This will parent the other selected object(s) to the vertices/edges/faces selected,
as described in :doc:`parenting </scene_layout/object/editing/parent>`.


## Propagate Shapes

.. _bpy.ops.mesh.shape_propagate_to_all:

*******************
Propagate to Shapes
*******************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Propagate to Shapes`

Apply selected vertex locations to all other :doc:`shape keys </animation/shape_keys/index>`.


## Rip Vertices

.. _bpy.ops.mesh.rip_move:
.. _tool-mesh-rip_region:

************
Rip Vertices
************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Rip Vertices`
   :Shortcut:  :kbd:`V`

Rip creates a "hole" in the mesh by making a copy of selected vertices and edges,
still linked to the neighboring non-selected vertices,
so that the new edges are borders of the faces on one side, and the old ones,
borders of the faces on the other side of the rip.


Examples
========

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_rip-vertices_before.png
          :width: 260px

          Selected vertex.

     - .. figure:: /images/modeling_meshes_editing_vertex_rip-vertices_after.png
          :width: 260px

          Hole created after using rip on vertex.

   * - .. figure:: /images/modeling_meshes_editing_vertex_rip-vertices_edges-before.png
          :width: 260px

          Edges selected.

     - .. figure:: /images/modeling_meshes_editing_vertex_rip-vertices_edges-after.png
          :width: 260px

          Result of rip with edge selection.

   * - .. figure:: /images/modeling_meshes_editing_vertex_rip-vertices_complexselection-before.png
          :width: 260px

          A complex selection of vertices.

     - .. figure:: /images/modeling_meshes_editing_vertex_rip-vertices_complexselection-after.png
          :width: 260px

          Result of rip operation.


Limitations
===========

Rip will only work when edges and/or vertices are selected.
Using the tool when a face is selected (explicitly or implicitly), will return an error
message *"Cannot perform ripping with faces selected this way"*.
If your selection includes edges or vertices that are not "between" two faces :term:`Manifold`,
it will also fail with the message *"No proper selection or faces include"*.


## Rip Vertices Extend

.. _bpy.ops.mesh.rip_edge_move:
.. _tool-mesh-rip_edge:

***********************
Rip Vertices and Extend
***********************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Rip Vertices and Extend`
   :Shortcut:  :kbd:`Alt-D`

This tool takes any number of selected vertices and duplicate-drags them along the closest edge to the mouse.
When extending an edge loop, it extends the vertices at the endpoints of the loop.
The behavior is similar to the *Extrude* tool, but it creates an n-gon.

It helps to easily add details to existing edges.


## Rip Vertices Fill


*********************
Rip Vertices and Fill
*********************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Rip Vertices and Fill`
   :Shortcut:  :kbd:`Alt-V`

Rip fill works the same as the Rip tool above, but instead of leaving a hole,
it fills in the gap with geometry.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_rip-vertices_edges-before.png
          :width: 260px

          Edges selected.

     - .. figure:: /images/modeling_meshes_editing_vertex_rip-vertices-fill_result.png
          :width: 260px

          Result of rip fill.


## Slide Vertices

.. _bpy.ops.transform.vert_slide:
.. _tool-mesh-vertex-slide:

**************
Slide Vertices
**************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Slide Vertices`
   :Shortcut:  :kbd:`Shift-V`, or :kbd:`G` twice

Vertex Slide will transform a vertex along one of its adjacent edges.
Use :kbd:`Shift-V` to activate tool.
The nearest selected vertex to the mouse cursor will be the control one.
Move the mouse along the direction of the desired edge to specify the vertex position.
Then press :kbd:`LMB` to confirm the transformation.

Even :kbd:`E`
   By default, the offset value of the vertices is a percentage of the edges length along which they move.
   When Even mode is active, the vertices are shifted by an absolute value.
Flipped :kbd:`F`
   When Flipped is active, vertices move the same distance from adjacent vertices,
   instead of moving from their original position.
Clamp :kbd:`Alt` or :kbd:`C`
   Toggle clamping the slide within the edge extents.

.. list-table::

   * - .. figure:: /images/modeling_meshes_editing_vertex_slide-vertices_example-1.png
          :width: 200px

          Selected vertex.

     - .. figure:: /images/modeling_meshes_editing_vertex_slide-vertices_example-2.png
          :width: 200px

          Positioning vertex interactively.

     - .. figure:: /images/modeling_meshes_editing_vertex_slide-vertices_example-3.png
          :width: 200px

          Repositioned vertex.


## Smooth Vertices

.. _bpy.ops.mesh.vertices_smooth:
.. _tool-mesh-smooth:

***************
Smooth Vertices
***************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Vertex --> Smooth Vertices`,
               :menuselection:`Context Menu --> Smooth`

This tool smooths the selected vertices by averaging the angles between the faces.
After using the tool, options appear in the *Toolbar*:

Smoothing
   Smoothing factor.
Repeat
   The number of smoothing iterations.
Axes
   Limit the effect to certain axes.

.. list-table::

   * - .. figure:: /images/modeling_modifiers_deform_smooth_mesh-before.png
          :width: 200px

          Mesh before smoothing.

     - .. figure:: /images/modeling_modifiers_deform_smooth_mesh-one-iteration.png
          :width: 200px

          Mesh after one smoothing iteration.

     - .. figure:: /images/modeling_modifiers_deform_smooth_mesh-ten-iterations.png
          :width: 200px

          Mesh after ten smoothing iterations.

.. tip::

   Using the Smooth tool after :doc:`subdividing </modeling/meshes/editing/edge/subdivide>`
   can help create a more organic shape.

.. seealso:: Smooth Modifier

   The :doc:`Smooth Modifier </modeling/modifiers/deform/smooth>`, which can be limited to a *Vertex Group*,
   is a non-destructive alternative to the Smooth operator.


## Vertex Groups


*************
Vertex Groups
*************

Todo.


## Custom Data


*************
Geometry Data
*************

This panel is used to manage any generic data attributes that a mesh could have.

.. warning::

   Clearing any data will result in the data loss of these values.

.. _bpy.ops.mesh.customdata_mask_clear:

Clear Sculpt Mask Data
   Deletes the internal ``sculpt_mask`` attribute.
   This attribute is used by the :ref:`Sculpt Masking Feature <face_sets>`.

.. _bpy.ops.mesh.customdata_skin_clear:
.. _bpy.ops.mesh.customdata_skin_add:

Add/Clear Skin Data
   Used to manage the skin data which is used by the :doc:`/modeling/modifiers/generate/skin`.
   This operator can be needed in case a Skin modifier is created but no skin data exist.

.. _bpy.ops.mesh.customdata_custom_splitnormals_clear:
.. _bpy.ops.mesh.customdata_custom_splitnormals_add:

Add/Clear Custom Split Normals Data
   Adds :ref:`Custom Split Normals <modeling_meshes_normals_custom>` data, if none exists yet.


## Index


##############
  Properties
##############

.. toctree::
   :maxdepth: 2

   object_data.rst
   vertex_groups/index.rst
   custom_data.rst


## Object Data


***********
Object Data
***********

Meshes
   The mesh :ref:`Data-Block Menu <ui-data-block>` can be used to link the data between objects.


Vertex Groups
=============

Vertex groups can be used to assign a group or weighted group to some operator.
An object can have several weight groups and can be assigned in
:doc:`Weight Paint </modeling/meshes/properties/vertex_groups/vertex_groups>` mode,
or in :doc:`Edit Mode </modeling/meshes/properties/vertex_groups/assigning_vertex_group>` via this panel.

See :doc:`Vertex Groups </modeling/meshes/properties/vertex_groups/index>` for more information.


Shape Keys
==========

Shape Keys can be used to transform one shape into another.
See :doc:`/animation/shape_keys/shape_keys_panel` for more information.


UV Maps
=======

UV Maps are used to map a 3D object onto a 2D plane that determines where a texture appears on the 3D object.
Different UV Maps can be used for different textures. For more information see :ref:`uv-maps-panel`.


.. _bpy.ops.geometry.color_attribute_remove:
.. _bpy.ops.geometry.color_attribute_render_set:
.. _modeling-meshes-properties-object_data-color-attributes:

Color Attributes
================

Color data can be applied directly to an object's vertices rather than using a texture or a material.
There are two modes to paint color attributes in.
Use :doc:`Vertex Paint </sculpt_paint/vertex_paint/index>` mode to paint per face corner
by enabling the paint mask in the header.
This is useful to achieve sharp edges in the color attribute on low-poly assets.
Alternatively use Sculpt mode to paint on a much higher vertex count.


.. _bpy.ops.geometry.color_attribute_add:

Creating a New Color Attribute
------------------------------

To create a new Color Attribute select the plus icon next to the list of attributes.
This action will open a pop-up with the following information.

Name
   The name of the Color Attribute which can be referenced elsewhere in Blender.
Domain
   The associated part of the geometry that stores the attribute.
   See :ref:`attribute-domains` for more information.

   :Vertex: Color Attributes are stored per each vertex.
   :Face Corner: Color Attributes are stored per each corner of a face.
Data Type
   The data type to represent colors internally.

   :Color: RGBA color with floating-point precision.
   :Byte Color: RGBA color with 8-bit precision.
Color
   The default color to fill for every element in the domain.


Color Attribute Specials
------------------------

These are operators that are available in the menu to the right of the attribute list.

.. _bpy.ops.geometry.color_attribute_duplicate:

Duplicate Color Attribute
   Creates a copy of the active color attribute in the list.

.. _bpy.ops.geometry.color_attribute_convert:

Convert Color Attribute
   Changes how the color attribute is stored.

   Domain
      The associated part of the geometry that stores the attribute.
      See :ref:`attribute-domains` for more information.

      :Vertex: Color Attributes are stored per each vertex.
      :Face Corner: Color Attributes are stored per each corner of a face.
   Data Type
      The data type to represent colors internally.

      :Color: RGBA color with floating-point precision.
      :Byte Color: RGBA color with 8-bit precision.


.. _bpy.types.AttributeGroup:

Attributes
==========

An attribute is data stored per mesh element. Every attribute has a data type, domain and name.
This panel only lists custom attributes which excludes all the built-in attributes like ``position`` and
other attributes like vertex groups.

See :doc:`Attributes Reference </modeling/geometry_nodes/attributes_reference>` for more information.


Texture Space
=============

Each object can have an automatically generated UV map, these maps can be adjusted here.

See :ref:`Generated UV Properties <properties-texture-space>` for more information.


Remesh
======

Mesh objects, in particular meshes that have been modeled to represent organic objects,
often have geometry that is not particularly uniform.
This can cause problems if the object needs to be :ref:`rigged <animation-rigging>`
or just needs simpler geometry for workflows such as 3D printing.
Remeshing is a technique that rebuilds the geometry with a more uniform topology.
Remeshing can either add or remove the amount of topology depending on the defined resolution.
Remeshing is especially useful for :doc:`sculpting </sculpt_paint/sculpting/index>`,
to generate better topology after blocking out the initial shape.

See :doc:`Mesh Retopology </modeling/meshes/retopology>` for more information.


Geometry Data
=============

Mesh objects can have different types of custom data attached to them.
This data is mostly used internally and can be exported by some :doc:`exporters </files/import_export/index>`.
See :doc:`/modeling/meshes/properties/custom_data` for more information.


## Assigning Vertex Group


************************
Assigning a Vertex Group
************************

Creating Vertex Groups
======================

.. figure:: /images/modeling_meshes_properties_vertex-groups_assigning-vertex-group_empty.png
   :align: right

   Empty Vertex Groups panel.

Vertex groups are maintained within the *Object Data* tab (1) in the Properties.
As long as no vertex groups are defined (the default for new mesh objects),
the panel is empty (2).

You create a vertex group by :kbd:`LMB` on the *Add* button ``+`` on the right panel border (3).
Initially the group is named "Group" (or "Group.nnn" when the name already exists) and
gets displayed in the panel (2) (see next image).

.. container:: lead

   .. clear


Vertex Groups Panel Controls
----------------------------

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-groups_panel-edit.png
   :align: right

   One vertex group.

Once a new vertex group has been added, the new group appears
in the Vertex Groups panel. There you find three clickable elements:

Group Name
   The group name can be changed by double-clicking :kbd:`LMB` on the name itself.
   Then you can edit the name as you like.

Filter (arrow icon)
   When the little arrow icon in the left lower corner is clicked, a new row opens up
   where you can enter a search term. This becomes handy when the number of
   vertex groups gets big.

Drag Handle
   If you have a large number of vertex groups and you want to see more
   than a few groups, you can :kbd:`LMB` on the small drag handle to make
   the vertex groups list larger or smaller.

Active Group
   When a vertex group is created,
   then it is also automatically marked as the *Active Group*.
   This is indicated by setting the background of the panel entry
   to a light gray color. If you have two or more groups in the list,
   then you can change the active group by :kbd:`LMB` on
   the corresponding entry in the Vertex Groups panel.


Deleting Vertex Groups
======================

.. figure:: /images/modeling_meshes_properties_vertex-groups_assigning-vertex-group_delete.png
   :align: right

   Delete a vertex group.

You delete a vertex group by first making it the active group
(select it in the panel) and then :kbd:`LMB`
the *Remove* button ``-`` at the right panel border.

Deleting a vertex group only deletes the vertex assignments to the group.
The vertices themselves are not deleted.


Locking Vertex Groups
=====================

.. figure:: /images/modeling_meshes_properties_vertex-groups_assigning-vertex-group_lock.png
   :align: right

   Lock a vertex group.

Right after creation of a vertex group,
an open padlock icon shows up on the right side of the list entry.
This icon indicates that the vertex group can be edited.
You can add vertex assignments to the group or remove assignments from the group.
And you can change it with the weight paint brushes, etc.

When you click on the icon,
it changes to a closed padlock icon and all vertex group modifications get disabled.
You can only rename or delete the group, and unlock it again.
No other operations are allowed on locked vertex groups,
thus all corresponding buttons become disabled for locked vertex groups.


Working with Content of Vertex Groups
=====================================

Assigning Vertices to a Group
-----------------------------

.. figure:: /images/modeling_meshes_properties_vertex-groups_assigning-vertex-group_assign.png
   :align: right

   Assign weights to active group.

You add vertices to a group as follows:

- Select the group from the group list, thus making it the active group (1).
- From the 3D Viewport select :kbd:`Shift-LMB` all vertices that you want to add to the group.
- Set the weight value that shall be assigned to all selected vertices (2).
- :kbd:`LMB` the *Assign* button to assign the selected vertices to the active group using the given weight (3).

Note that weight assignment is not available for locked vertex groups.
The *Assign* button is grayed out in that case.

.. note:: Assign is additive

   The *Assign* button only adds the currently
   selected vertices to the active group. Vertices already
   assigned to the group are not removed from the group.

   Also keep in mind that a vertex can be assigned to multiple groups.


Checking Assignments
--------------------

To be sure the selected vertices are in the desired vertex group,
you can try press the deselect button.
If the vertices remain selected then they are not yet in the current vertex group.

At this point you may assign them, but take care since all selected vertices
will have their weight set to the value in the *Weight:* field.


Removing Assignments from a Group
---------------------------------

You remove vertices from a group as follows:

- Select the group from the group list (make it the active group).
- Select all vertices that you want to remove from the group.
- :kbd:`LMB` click the *Remove* button.

Note that removing weight assignments is not available for locked vertex groups.
The *Remove* button is grayed out in that case.


Using Groups for Selecting/Deselecting
--------------------------------------

You can quickly select all assigned vertices of a group:

- (Optionally) press :kbd:`Alt-A` to deselect all vertices.
- Select the group from the group list (make it the active group).
- When you now :kbd:`LMB` click the *Select* button,
  then the vertices assigned to the active group will be selected and highlighted in the 3D Viewport.
- When you :kbd:`LMB` click the *Deselect* button instead,
  then the vertices assigned to the active group will be deselected in the 3D Viewport.

.. note:: Selecting/Deselecting is additive

   If you already have vertices selected in the 3D Viewport,
   then selecting the vertices of a group will add the vertices
   but also keep the already selected vertices selected.
   Vice versa, deselecting the vertices of a vertex group
   will only deselect the vertices assigned to the group
   and keep all other vertices selected.


Finding Ungrouped Vertices
--------------------------

You can find ungrouped vertices as follows:

- Press :kbd:`Alt-A` to deselect all vertices.
- In the header of the 3D Viewport, navigate to
  :menuselection:`Select --> Select All by Trait --> Ungrouped Vertices`.


## Index

.. _bpy.types.VertexGroups:

#################
  Vertex Groups
#################

.. toctree::
   :maxdepth: 2

   introduction.rst
   vertex_groups.rst
   assigning_vertex_group.rst
   vertex_weights.rst


## Introduction


************
Introduction
************

.. figure:: /images/modeling_meshes_properties_vertex-groups_introduction_panel.png
   :align: right

   The Vertex Groups panel.

Vertex groups are mainly used to tag the vertices belonging
to parts of a mesh object or :term:`Lattice`. Think of the legs of a chair or
the hinges of a door, or hands, arms, limbs, head, feet, etc. of a character.
In addition you can assign different weight values
(in the range 0 to 1) to the vertices within a vertex group.
Hence vertex groups are sometimes also named 'weight groups'.


Usage
=====

Vertex groups are most commonly used for armatures.
But they are also used in many other areas of Blender, like for example:

- Armature deformation *(also called skinning)*
- Shape keys
- Modifiers
- Particle generators
- Physics simulations

.. seealso::

   :doc:`Skinning Mesh Objects </animation/armatures/skinning/introduction>`.

Many more usage scenarios are possible.
Actually you can use vertex groups for whatever makes sense to you.
In some contexts vertex groups can also be automatically generated
(e.g. for rigged objects). However, in this section we will focus
on manually created (user-defined) vertex groups.

.. note::

   Vertex groups only apply to mesh and lattice objects.


## Vertex Groups


*******************
Vertex Groups Panel
*******************

.. reference::

   :Mode:      All Modes
   :Panel:     :menuselection:`Object Data tab --> Vertex Groups`

.. figure:: /images/modeling_meshes_properties_vertex-groups_introduction_panel.png
   :align: right

   The Vertex Group panel.

Vertex groups are maintained within the *Object Data* Properties, in the *Vertex Groups* panel.

.. _bpy.ops.object.vertex_group_add:
.. _bpy.ops.object.vertex_group_sort:
.. _bpy.ops.object.vertex_group_copy:
.. _bpy.ops.object.vertex_group_copy_to_selected:
.. _bpy.ops.object.vertex_group_remove_from:
.. _bpy.ops.object.vertex_group_remove:
.. _bpy.ops.object.vertex_group_move:
.. _bpy.types.VertexGroups.active_index:

Active Vertex Group
   A :ref:`List view <ui-list-view>`.

   Lock
      Locks the group from being editable. You can only rename or delete the group.

   Add ``+``
      Create an empty vertex group.
   Remove ``-``
      Deletes the active vertex group.

   Specials
      Sort by Name
         Sorts vertex groups alphabetically.
      Sort by Bone Hierarchy
         (Todo)

      Duplicate Vertex Group
         Add a copy of the active vertex group as a new group.
         The new group will be named like the original group with "_copy" appended at the end of its name.
         And it will contain associations to exactly the same vertices
         with the exact same weights as in the source vertex group.
      Copy Vertex Group to Selected
         Copy all vertex groups to other selected objects provided they have matching indices
         (typically this is true for copies of the mesh which are only deformed and not otherwise edited).

      Mirror Vertex Group
         Mirrors weights and/or flips group names.
         See :ref:`Mirror Vertex Group <bpy.ops.object.vertex_group_mirror>` for more information.
      Mirror Vertex Group (Topology)
         Performs the *Mirror Vertex Group* with the *Topology Mirror* option enabled.

      Remove from All Groups
         Unassigns the selected vertices from all (even locked) groups.
         After this operation has been performed, the vertices will no longer be contained in any vertex group.
         (Not available for locked groups.)
      Clear Active Group
         Remove all assigned vertices from the active group. The group is made empty.
         Note that the vertices may still be assigned to other vertex groups of the object.
         (Not available for locked groups.)
      Delete All Unlocked Groups
         Remove all vertex groups from the object that are *not* locked.
      Delete All Groups
         Remove all vertex groups from the object.

      Lock All
         Lock all groups.
      Unlock All
         Unlock all groups.
      Lock Invert All
         Invert group locks.


Editing Vertex Groups
=====================

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Object Data tab --> Vertex Groups`
   :Menu:      :menuselection:`Vertex --> Vertex Groups`
   :Shortcut:  :kbd:`Ctrl-G`

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-groups_panel-edit.png
   :align: right

   Vertex Group panel in Edit or Weight Paint Mode.

When you switch either to Edit Mode or to Weight Paint Mode, vertex weights can be edited.
The same operations are available in the 3D Viewport's
:menuselection:`Vertex --> Vertex Groups` menu or :kbd:`Ctrl-G`.

Assign
   To assign the selected vertices to the active group with the weight as defined in the *Weight* (see below).
Remove
   To remove the selected vertices from the active group (and thus also delete their weight values).
Select
   To select all vertices contained in the group.
Deselect
   To deselect all vertices contained in the group.

Weight
   The weight value that gets assigned to the selected vertices.

Set Active Group
   Lets you select the group that will become the active one (menu only).


## Vertex Weights


**************
Vertex Weights
**************

.. reference::

   :Mode:      Edit and Weight Paint Modes
   :Panel:     :menuselection:`Sidebar region --> Vertex Weights`

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_panel-overview.png
   :width: 260px

   Vertex Weights panel.

A :doc:`vertex group </modeling/meshes/properties/vertex_groups/index>` assigns a weight
(a number between 0 and 1) to each vertex it contains. A group can have multiple vertices,
and each vertex can be part of multiple groups.

The *Vertex Weights* panel in the 3D Viewport's Sidebar shows the vertex groups for
the active vertex, and lets you see and edit the associated weights.
It's available in Edit Mode, as well as in Weight Paint Mode when Vertex Selection
is enabled in the header.

.. _bpy.types.ToolSettings.vertex_group_subset:

Vertex Group Categories
=======================

While all vertex groups are technically the same, we can still divide them into two types
depending on how they're used:

Deform Groups
   Also sometimes called "weight group" or "weight map," this type of vertex group determines
   which vertices are affected by a certain bone in the
   :doc:`Armature </animation/armatures/introduction>`. In other words, it defines which part
   of the mesh deforms when the bone moves around.

Other Groups
   The remaining vertex groups are used with shape keys, modifiers, and other areas.

The deform vertex groups are related to each other: the deformation weights of every vertex
typically need to add up to 1. For this reason, you can use the filter buttons at the top
of the panel to show only these vertex groups (or to exclude them).

Weight Table
============

The Weight Table shows all the weights associated with the *active vertex*, which is the
vertex that was selected last (and is highlighted in white). If there is no active vertex,
or it isn't part of any vertex group, the panel is not displayed.

Set the Active Group
--------------------

You can click the name of a vertex group to make it the active one.

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_editor-name.png
   :width: 260px

   Changing the active vertex group.

Display Weights in Edit Mode
----------------------------

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_show.png
   :align: right

   Enable display of weights in Edit Mode.

When you are in Edit Mode, you can make the weights of the active group visible on the mesh:
open the *Mesh Edit Mode Overlays* popover and enable the *Vertex Group Weights* option.

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_edit-mode.png
   :width: 260px

   Weights in Edit Mode.


Change a Weight
---------------

You can change the weight for a vertex group by either clicking the number and typing a new
one or by dragging left and right with :kbd:`LMB`. You can also click the arrows
(only shown when hovering) to change the weight in steps of 0.01.

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_editor-weight.png
   :width: 260px

   Changing a weight value.


.. _bpy.ops.object.vertex_weight_paste:

Copy a Weight
-------------

The *Paste Weight to Selected* button copies the weight from the active vertex to the other selected
vertices. Note that, even though it uses the word "paste," it doesn't interact with the *Copy* button
and in fact doesn't use the clipboard at all.

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_editor-paste.png
   :width: 260px

   Copying a weight.


.. _bpy.ops.object.vertex_weight_delete:

Delete a Weight
---------------

The *Delete Weight* button removes the active vertex from the vertex group,
making the row disappear from the list.

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_editor-delete.png
   :width: 260px

   Deleting a weight.


Operators
=========

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_editor-functions.png
   :width: 260px

   Vertex weight operators.

Normalize
   Recalculates the weights of the active vertex so that they add up to 1.0 while
   retaining their relative magnitude.

.. _bpy.ops.object.vertex_weight_copy:

Copy
   Copies all the weights from the active vertex to the other selected vertices.

.. tip::

   Both tools only work on the vertex groups that match the current filter setting.


Locking
=======

.. figure:: /images/modeling_meshes_properties_vertex-groups_vertex-weights_editor-locked.png
   :width: 260px

   Locked vertex group.

If a vertex group is locked, its weights become uneditable, and the buttons for copying
and normalizing weights become disabled.

.. tip::

   The *Normalize* and *Copy* buttons only become disabled if there's a locked vertex
   group in the current list. If (for example) only non-deforming vertex groups are locked,
   you can switch to the *Deform* filter and normalize the groups that way.


## All By Trait


*******************
Select All by Trait
*******************

.. _bpy.ops.mesh.select_non_manifold:

Non-Manifold
============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select All by Trait --> Non-Manifold`

Selects the :term:`Non-manifold` geometry of a mesh.
This entry is available when editing a mesh, in Vertex and Edge selection modes only.

Extend
   Lets you extend the current selection.
Wire
   Selects all the edges that do not belong to any face.
Boundaries
   Selects edges in boundaries and holes.
Multiple Faces
   Selects edges that belong to three or more faces.
Non Contiguous
   Selects edges that belong to exactly two faces with opposite normals.
Vertices
   Selects vertices that belong to *wire* and *multiple face* edges,
   isolated vertices, and vertices that belong to non-adjoining faces.


.. _bpy.ops.mesh.select_loose:

Loose Geometry
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select All by Trait --> Loose Geometry`

This selection depends on the currently selected :ref:`Selection Modes <bpy.types.ToolSettings.mesh_select_mode>`;
In vertex and edge selection mode it selects all vertices or edges that do not form part of a face.
In face selection mode it selects all faces that do not share edges with other faces.


.. _bpy.ops.mesh.select_interior_faces:

Interior Faces
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select All by Trait --> Interior Faces`

Selects faces where all edges have more than two faces.


.. _bpy.ops.mesh.select_face_by_sides:

Faces by Sides
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select All by Trait --> Faces by Sides`

Selects all faces that have a specified number of edges.


.. _bpy.ops.mesh.select_ungrouped:

Ungrouped Vertices
==================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select All by Trait --> Ungrouped Vertices`

Selects all vertices which are not part of
a :doc:`vertex group </modeling/meshes/properties/vertex_groups/index>`.


## By Attribute

.. _bpy.ops.mesh.select_by_attribute:

************
By Attribute
************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> By Attribute`

Selects vertices, edges, or faces based on the :term:`Active`
:doc:`Attribute </modeling/geometry_nodes/attributes_reference>`.


Usage
=====

.. note::

   - The active attribute must have a boolean :ref:`type <attribute-data-types>`.
   - The active attribute must be on the vertex, edge, or face :ref:`domain <attribute-domains>`.

#. Select the desired attribute from the :ref:`Attribute List <bpy.types.AttributeGroup>`.
#. Execute the *By Attribute* operator.


## Checker Deselect

.. _bpy.ops.mesh.select_nth:

****************
Checker Deselect
****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Checker Deselect`

This tool applies an alternating selected/deselected checker pattern.
This only works if you already have more than one mesh element selected.

Changes the current selection so that only every Nth elements (vertices, edges or faces,
depending on the active selection mode) will remain selected, starting from the active one.

In case of islands of selected elements, this tool will affect
only the island of the active element (if there is one), or the island of the first element
in the order of internal storage (if there is no active element).

Deselected
   The number of deselected elements in each pattern repetition.
Selected
   The number of selected elements in each pattern repetition.
Offset
   Offset from the starting point.


## Index


#############
  Selecting
#############

.. toctree::
   :maxdepth: 2

   introduction.rst
   mirror.rst
   random.rst
   checker_deselect.rst
   more_less.rst
   similar.rst
   all_by_trait.rst
   linked.rst
   loops.rst
   sharp_edges.rst
   side_of_active.rst
   by_attribute.rst


## Introduction


************
Introduction
************

There are many ways to select elements, and it depends on what *Mesh Select Mode*
you are in as to what selection tools are available.
First we will go through these modes and after that a look is taken at basic selection tools.


.. _bpy.types.ToolSettings.mesh_select_mode:
.. _bpy.ops.mesh.select_mode:

Selection Modes
===============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`3D Viewport Header --> Select Mode`
   :Shortcut:  :kbd:`1`, :kbd:`2`, :kbd:`3`
               (:kbd:`Shift` `Multiple Selection Modes`_,
               :kbd:`Ctrl` `Expand/Contract Selection`_).

In *Edit Mode* there are three different selection modes.
You can enter the different modes by selecting one of the three buttons in the header.

.. figure:: /images/modeling_meshes_selecting_introduction_mode-buttons.png
   :align: center

   Edit Mode selection buttons from right to left: Vertex, Edge, Face.

Vertex
   In this mode vertices are shown as points.
   Selected vertices are displayed in orange, unselected vertices in black,
   and the active or last selected vertex in white.
Edge
   In this mode the vertices are not shown.
   Instead the selected edges are displayed in orange,
   unselected edges black, and the active or last selected edge in white.
Face
   In this mode the faces are displayed with a selection point in the middle which is used for selecting a face.
   Selected faces and their selection point are displayed in orange,
   unselected faces are displayed in black, and the active or last selected face is highlighted in white.

When using these buttons, you can make use of modifier keys, see: `Switching Select Mode`_.

Almost all tools are available in all three mesh selection modes.
So you can *Rotate*, *Scale*, *Extrude*, etc. in all modes.
Of course rotating and scaling a *single* vertex will not do anything useful
(*without* setting the pivot point to another location), so some tools
are more or less applicable in some modes.

See Fig. :ref:`fig-mesh-select-intro-selection-modes` for examples of the different modes.


Multiple Selection Modes
------------------------

By holding :kbd:`Shift-LMB` when selecting a selection mode,
you can enable multiple *Selection Modes* at once.
This allows you to quickly select vertices, edges, or faces,
without first having to switch mode.

.. _fig-mesh-select-intro-selection-modes:

.. list-table:: Selection modes.

   * - .. figure:: /images/modeling_meshes_selecting_introduction_vertex-mode-example.png
          :width: 310px

          Vertex mode example.

     - .. figure:: /images/modeling_meshes_selecting_introduction_edge-mode-example.png
          :width: 310px

          Edge mode example.

   * - .. figure:: /images/modeling_meshes_selecting_introduction_face-mode-example.png
          :width: 310px

          Face mode example.

     - .. figure:: /images/modeling_meshes_selecting_introduction_mixed-mode-example.png
          :width: 310px

          Mixed mode example.


Switching Select Mode
---------------------

When switching modes in an "ascendant" way (i.e. from simpler to more complex),
from *Vertices* to *Edges* and from *Edges* to *Faces*,
the selected parts will still be selected if they form a complete element in the new mode.

For example, if all four edges in a face are selected,
switching from *Edges* mode to *Faces* mode will keep the face selected.
All selected parts that do not form a complete set in the new mode will be unselected.

.. list-table::

   * - .. figure:: /images/modeling_meshes_selecting_introduction_edge-mode-example.png
          :width: 310px

          Edge mode, the initial selection.

     - .. figure:: /images/modeling_meshes_selecting_introduction_face-mode-switched-from-edge.png
          :width: 310px

          Switching to Face mode.

Hence, switching in a "descendant" way (i.e. from more complex to simpler),
all elements defining the "high-level" element (like a face) will be selected
(the four vertices or edges of a quadrangle, for example).


Expand/Contract Selection
^^^^^^^^^^^^^^^^^^^^^^^^^

By holding :kbd:`Ctrl` when selecting a higher selection mode,
all elements touching the current selection will be added,
even if the selection does not form a complete higher element.
Or contracting the selection when switching to a lower mode.

.. list-table::

   * - .. figure:: /images/modeling_meshes_selecting_introduction_vertex-mode-example.png
          :width: 310px

          Vertex mode, the initial selection.

     - .. figure:: /images/modeling_meshes_selecting_introduction_edge-mode-expanding-from-vertex.png
          :width: 310px

          Expanding to Edge mode.


.. _bpy.ops.view3d.toggle_xray:

X-Ray
=====

The :ref:`X-Ray <3dview-shading-xray>` setting is not just for shading, it impacts selection too.
When enabled, selection isn't occluded by the objects geometry (as if the object was solid).

.. list-table::

   * - .. figure:: /images/modeling_meshes_selecting_introduction_limit-selection-to-visible-off.png
          :width: 310px

          X-ray enabled.

     - .. figure:: /images/modeling_meshes_selecting_introduction_limit-selection-to-visible-on.png
          :width: 310px

          X-ray disabled.


Select Menu
===========

All :kbd:`A`
   Select all.
None :kbd:`Alt-A`
   Select none.
Invert :kbd:`Ctrl-I`
   Selects all the geometry that is not selected, and deselect currently selected components.

----

:ref:`Box Select <tool-select-box>` :kbd:`B`
   Interactive box selection.
:ref:`Circle Select <tool-select-circle>` :kbd:`C`
   Interactive circle selection.
:ref:`Lasso Select <tool-select-lasso>`
   Interactive free-form selection.

----

Select Mirror :kbd:`Shift-Ctrl-M`
   Select mesh items at the mirrored location across the chosen axis.
:ref:`Select Random <bpy.ops.mesh.select_random>`
   Selects a random group of vertices, edges, or faces, based on a percentage value.
:ref:`Checker Deselect <bpy.ops.mesh.select_nth>`
   Deselect alternate elements relative to the active item.

----

More/Less
   More :kbd:`Ctrl-NumpadPlus`
      Expands the selection to the adjacent elements of the selection type.
   Less :kbd:`Ctrl-NumpadMinus`
      Contracts the selection from the adjacent elements of the selection type.
   Next Active :kbd:`Shift-Ctrl-NumpadPlus`
      This uses selection history to select the next vertex, edge, or face based on surrounding topology.
   Previous Active :kbd:`Shift-Ctrl-NumpadMinus`
      Select previous just removes the last selected element.

----

:ref:`Select Similar <bpy.ops.mesh.select_similar>` :kbd:`Shift-G`
   Select elements similar to the current selection.
:doc:`Select All by Trait </modeling/meshes/selecting/all_by_trait>`
   Select geometry by querying its characteristics.
Select Linked
   :ref:`Select Linked <bpy.ops.mesh.select_linked>`
      Selects all components that are connected to the current selection.
   :ref:`Shortest Path <bpy.ops.mesh.shortest_path_select>`
      Path between two selected elements.
   Linked Flat Faces
      Select connected faces based on a threshold of the angle between them.
      This is useful for selecting faces that are planar.
Select Loops
   :ref:`Edge Loops <bpy.ops.mesh.loop_multi_select>`
      Select connected edges.
   :ref:`Face Loops <modeling-meshes-selecting-face-loops>`
      Select connected faces.
   :ref:`Edge Rings <modeling-meshes-selecting-edge-rings>`
      Select connected edge ring.

Sharp Edges
   This tool selects all edges between two faces forming an angle greater than the angle value,
   where an increasing angle selects sharper edges.

Side of Active
   Selects all vertices on the mesh in a single axis relative to the active vertex.
   In Vertex selection mode only.


Known Issues
============

Dense Meshes
------------

Selecting dense meshes with X-Ray disabled, has a limitation where dense meshes may not have
all the elements selected.
When selecting regions with Box, Circle and Lasso select, vertices may overlap each other causing
some vertices not to be selected.
This is a limitation with the current selection method, you may workaround this by zooming in or enabling X-Ray.


N-Gons in Face Select Mode
--------------------------

.. figure:: /images/modeling_meshes_selecting_introduction_face-mode-ngon-visual-problem.png

   N-gon face having its center dot inside another face.

As already noted, in X-Ray and Wireframe mode faces are marked with a dot in the middle.
With n-gons that can lead in certain cases to a confusing display.
The example shows the center dot of the U-shaped n-gon being inside of the oblong face inside the "U".
It is not easy to identify which dot belongs to which face (the orange dot in the image is the object origin).


## Linked


*************
Select Linked
*************

.. _bpy.ops.mesh.select_linked:

Linked
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Linked --> Linked`
   :Shortcut:  :kbd:`Ctrl-L`

Select geometry connected to already selected elements.
This is often useful when a mesh has disconnected, overlapping parts,
where isolating it any other way would be tedious.
To give more control, you can also enable delimiters in the :ref:`bpy.ops.screen.redo_last` panel,
so the selection is constrained by seams, sharp edges, materials or UV islands.

With *Pick Linked* you can also select connected geometry directly under the cursor,
using the :kbd:`L` shortcut to select or :kbd:`Shift-L` to deselect linked.
This works differently in that it uses the geometry under the cursor instead of the existing selection.


.. _bpy.ops.mesh.shortest_path_select:
.. _bpy.ops.mesh.shortest_path_pick:

Shortest Path
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Linked --> Shortest Path`
   :Shortcut:  :kbd:`Ctrl-LMB`

.. figure:: /images/modeling_meshes_selecting_linked_shortest-path.png

   Select a face or vertex path with :kbd:`Ctrl-LMB`.

Selects all geometry along the shortest path from
the active vertex, edge, or face to the one which was selected.

Edge Tag (in Edge select mode only)
   This select button indicates what should be done when selecting a vertex path with :kbd:`Ctrl-LMB`:

   Select
      Just selects all the edges in the path.
   Tag Seam
      Marks all edges in the path as seams for UV unwrapping.
   Tag Sharp
      Marks all edges in the path as sharp for the Edge Split Modifier.
   Tag Crease
      Marks all edges in the path as creases for the Subdivision Surface Modifier, with weight 1.0.
   Tag Bevel
      Gives bevel weight 1.0 (for the Bevel Modifier) to all edges in the path.
   Tag Freestyle Edge Mark
      Marks all edges in the path as Freestyle edges.

Face Stepping
   Supports diagonal paths for vertices and faces, and
   selects edge rings with edges.
Topology Distance
   Only takes into account the number of edges of the path and
   not the length of the edges to calculate the distances.
Fill Region :kbd:`Shift-Ctrl-LMB`
   Selects all elements in the shortest paths from the active selection to the clicked area.
Checker Deselect Options
   Allows to quickly select alternate elements in a path.

   Deselected
      The number of deselected elements in the repetitive sequence.
   Selected
      The number of selected elements in the repetitive sequence.
   Offset
      Offset from the starting point.


.. _bpy.ops.mesh.faces_select_linked_flat:

Linked Flat Faces
=================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Linked --> Linked Flat Faces`

Selects all connected faces with a similar angle.

Sharpness
   Select connected faces with a reference angle less than the value specified.

.. figure:: /images/modeling_meshes_selecting_linked_flat-faces.png

Looking at the image above, when at least one face is selected (as seen on the left),
*Linked Flat Faces* will select all connecting faces that lie
on the same or similar plane (as shown in the middle image).
If the corners are smoothed, those faces are no longer lined up with the selected faces.
At this point, increasing the *Sharpness* value in the tool options could include the smoothed faces.


## Loops


************
Select Loops
************

.. _bpy.ops.mesh.loop_select:
.. _bpy.ops.mesh.loop_multi_select:

Select Edge Loops
=================

.. reference::

   :Mode:      Edit Mode (Vertex or Edge select mode)
   :Menu:      :menuselection:`Select --> Select Loops --> Edge Loops`
   :Shortcut:  :kbd:`Alt-LMB`, or :kbd:`Shift-Alt-LMB` for modifying existing selection.

Holding :kbd:`Alt` while selecting an edge selects a loop of edges that are connected in
a line end-to-end, passing through the edge under the mouse pointer.
Holding :kbd:`Shift-Alt` while clicking adds to the current selection.

.. note:: *Vertex* mode

   In *Vertex* select mode, you can also select edge loops, by using the same shortcuts,
   and clicking on the *edges* (not on the vertices).

.. figure:: /images/modeling_meshes_selecting_loops_edge-loops.png

   Longitudinal and latitudinal edge loops.

The left sphere shows an edge that was selected longitudinally. Notice how the loop is open.
This is because the algorithm hit the vertices at the poles and is terminated
because the vertices at the pole connect to more than four edges. However,
the right sphere shows an edge that was selected latitudinally and has formed a closed loop.
This is because the algorithm hit the first edge that it started with.


Select Edge Loops (All Boundaries)
----------------------------------

All boundary edges can be selected by performing a second loop select action on a boundary edge.

This can be useful for selecting boundaries for meshes that include triangles and n-gons,
where loop select would not otherwise select the full boundary.

.. figure:: /images/modeling_meshes_selecting_loops_edge-boundary-loops.png

   The second loop select action is shown on the right.


.. _modeling-meshes-selecting-face-loops:

Select Face Loops
=================

.. reference::

   :Mode:      Edit Mode (Face or Vertex select modes)
   :Shortcut:  :kbd:`Alt-LMB` or :kbd:`Shift-Alt-LMB` for modifying existing selection.

In face select mode, holding :kbd:`Alt` while selecting an *edge* selects a loop of
faces that are connected in a line end-to-end, along their opposite edges.

In vertex select mode,
the same can be accomplished by using :kbd:`Ctrl-Alt` to select an edge,
which selects the face loop implicitly.

.. figure:: /images/modeling_meshes_selecting_loops_face-loops.png

   Face loop selection.

This face loop was selected by clicking with :kbd:`Alt-LMB` on an edge,
in *face* select mode.
The loop extends perpendicular from the edge that was selected.

.. figure:: /images/modeling_meshes_selecting_loops_face-loops-vertex.png

   :kbd:`Alt` versus :kbd:`Ctrl-Alt` in vertex select mode.

A face loop can also be selected in *Vertex* select mode.
Technically :kbd:`Ctrl-Alt-LMB` will select an *Edge Ring*,
however, in *Vertex* select mode, selecting an *Edge Ring* implicitly
selects a *Face Loop* since selecting opposite edges of a face implicitly selects
the entire face.


.. _modeling-meshes-selecting-edge-rings:
.. _bpy.ops.mesh.select_edge_ring:

Select Edge Rings
=================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Loops --> Edge Rings`
   :Shortcut:  :kbd:`Ctrl-Alt-LMB`

In *Edge* select mode, holding :kbd:`Ctrl-Alt`
while selecting an edge (or two vertices) selects a sequence of edges that are not connected,
but on opposite sides to each other continuing along a :doc:`face loop </modeling/meshes/structure>`.

As with edge loops, you can also select edge rings based on current selection,
using either :menuselection:`Select --> Select Loops --> Edge Rings`.

.. note:: *Vertex* mode

   In *Vertex* select mode, you can use the same shortcuts when *clicking on the edges* (not on the vertices),
   but this will directly select the corresponding face loop...

.. _fig-mesh-select-advanced-loop-ring:

.. figure:: /images/modeling_meshes_selecting_loops_edge-ring.png

   A selected edge loop, and a selected edge ring.

In Fig. :ref:`fig-mesh-select-advanced-loop-ring` the same edge was clicked on,
but two different "groups of edges" were selected, based on the different tools.
One is based on edges during computation and the other is based on faces.

.. note:: Convert Selection to Whole Faces

   If the edge ring selection happened in Edge Select Mode, switching to Face Select Mode will erase the selection.

   This is because none of those faces had all its (four) edges selected,
   just two of them.

   Instead of selecting the missing edges manually or by using :kbd:`Shift-Alt-LMB` twice,
   it is easier to first switch to Vertex Select Mode, which will kind of "flood" the selection.
   A subsequent switch to Face Select Mode will then properly select the faces.


.. _bpy.ops.mesh.loop_to_region:

Select Loop Inner-Region
========================

.. reference::

   :Mode:      Edit Mode (Edge select mode)
   :Menu:      :menuselection:`Select --> Select Loops --> Select Loop Inner-Region`

*Select Loop Inner-Region* selects all faces that are inside a closed loop of edges.
While it is possible to use this operator in *Vertex* and *Face* selection modes, results may be unexpected.
Note that if the selected loop of edges is not closed,
then all connected edges on the mesh will be considered inside the loop.

.. figure:: /images/modeling_meshes_selecting_loops_inner-region1.png

   Loop to Region.

.. figure:: /images/modeling_meshes_selecting_loops_inner-region2.png

   This tool handles multiple loops fine, as you can see.

.. figure:: /images/modeling_meshes_selecting_loops_inner-region3.png

   This tool handles "holes" just fine as well.


.. _bpy.ops.mesh.region_to_loop:

Select Boundary Loop
====================

.. reference::

   :Mode:      Edit Mode (Edge select mode)
   :Menu:      :menuselection:`Select --> Select Loops --> Select Boundary Loop`

*Select Boundary Loop* does the opposite of *Select Loop Inner-Region*,
based on all regions currently selected, it selects only the edges at the border (contour) of these islands.
It can operate in any select mode, but when in *Face* mode it will switch to *Edge* select mode after running.

All this is much more simple to illustrate with examples:

.. figure:: /images/modeling_meshes_selecting_loops_boundary-loop.png

   Select Boundary Loop does the opposite and forces into Edge Select Mode.


## Mirror

.. _bpy.ops.mesh.select_mirror:

*************
Select Mirror
*************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Mirror`
   :Shortcut:  :kbd:`Shift-Ctrl-M`

Select Mirror flips a selection to the opposite side of the mesh.

Axis
   Choose on which axis the selection will occur. The axis is based on the meshes origin.
   Therefore, if the origin is not centered within the mesh, the selection will have varying results.

Extend
   The new selection will include the mirrored selection as well as the original.

.. figure:: /images/modeling_meshes_selecting_mirror_extend.png

   (From left to right) initial selection, after Select Mirror on the X axis, with Extend.

.. tip::

   With *Extend* activated, hold :kbd:`Shift` while choosing an axis to include more than one axis in the selection.
   Otherwise, with *Extend* off, the mirror will take into account two to three axes.


Example
=======

.. figure:: /images/modeling_meshes_selecting_mirror_axis-xz-extend.png

   (From left to right) initial selection, mirrored along X and Z axes, with Extend.


## More Less

.. _bpy.ops.mesh.select_more:
.. _bpy.ops.mesh.select_less:

****************
Select More/Less
****************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select More/Less --> More`
   :Shortcut:  :kbd:`Ctrl-NumpadPlus`
   :Menu:      :menuselection:`Select --> Select More/Less --> Less`
   :Shortcut:  :kbd:`Ctrl-NumpadMinus`

With at least one vertex, edge, or face selected, *Select More/Less* expands or shrinks the selection.
However, if there is only one selection in any selection mode, *Less* will deselect it.

Face Step
   With *Face Step* on, each use of the tool
   will affect the size of the selection on a face by face basis.
   When deactivated, it will be based on either vertices or edges depending on which
   :doc:`Selection Mode </modeling/meshes/selecting/introduction>` is active.

.. figure:: /images/modeling_meshes_selecting_more-less_example.png

   (From left to right) initial selection, without Face Step,
   with Face Step, and in edge selection mode.


.. _bpy.ops.mesh.select_next_item:
.. _bpy.ops.mesh.select_prev_item:

Select Next/Previous Active
===========================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select More/Less --> Next Active`
   :Shortcut:  :kbd:`Shift-Ctrl-NumpadPlus`
   :Menu:      :menuselection:`Select --> Select More/Less --> Previous Active`
   :Shortcut:  :kbd:`Shift-Ctrl-NumpadMinus`

Next Active
   This uses selection history to select the next vertex, edge, or face based on the surrounding topology.
   Which means that, it will derive the next selection from the previous two selections.

.. list-table::

   * - .. figure:: /images/modeling_meshes_selecting_more-less_select-active-1.png
          :width: 200px

          Initial selection.

     - .. figure:: /images/modeling_meshes_selecting_more-less_select-active-2.png
          :width: 200px

          Using Next Active once.

     - .. figure:: /images/modeling_meshes_selecting_more-less_select-active-3.png
          :width: 200px

          Using Next Active twice.

Previous Active
   Only the last selected element will be removed.


## Random

.. _bpy.ops.mesh.select_random:

*************
Select Random
*************

.. reference::

   :Mode:      Object Mode
   :Menu:      :menuselection:`Select --> Select Random`

Randomly selects unselected vertices, edges, or faces based on percentage probability.

Percent
   The likelihood of an unselected mesh element being selected.
   Note that this is not the percentage amount of elements that will be selected.


## Sharp Edges


******************
Select Sharp Edges
******************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Sharp Edges`

Selects edges whose faces intersect at an acute angle. This can be useful to find hard edges in a mesh.

Sharpness
   Determines how sharp of an angle at an edge needs to be in order for it to be selected.


## Side Of Active


**************
Side of Active
**************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Side of Active`

With an active vertex, this tool will select all vertices in a specified direction.
It is similarly to the *Loop Inner-Region* tool in that it will fill select faces within its perimeters,
however, it is determined by direction and not by a closed loop.

Axis Mode
   Determines the behavior of the selection.
   More information on this can be found in :doc:`Transform Orientations </editors/3dview/controls/orientation>`.

Axis Sign
   Positive/Negative Axis
      Depending on which *Axis* is chosen, the selection will encompass the positive or negative axis
      starting from the active vertex outward.

   Aligned Axis
      Where *Positive and Negative Axis* select all vertices in a given direction,
      *Aligned Axis* will only select the vertices that are in-line with the active vertex.

.. figure:: /images/modeling_meshes_selecting_side-of-active_sign.png

   While following along the X axis: (from left to right) active vertex, Aligned, Positive, and Negative.

Axis
   Chooses the direction of the selection.

Threshold
   The amount of influence the selection has outside the original perimeters.
   The higher the *Threshold* the more vertices will be selected.


## Similar

.. _bpy.ops.mesh.select_similar:

**************
Select Similar
**************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Similar`
   :Shortcut:  :kbd:`Shift-G`

Select geometry that has similar certain properties to the ones selected,
based on a threshold that can be set in tool properties after activating the tool.
Tool options change depending on the selection mode:

Vertex Selection Mode:
   Normal
      Selects all vertices that have normals pointing in similar directions to those currently selected.
   Amount of Adjacent Faces
      Selects all vertices that have the same number of faces connected to them.
   Vertex Groups
      Selects all vertices in the same :doc:`vertex group </modeling/meshes/properties/vertex_groups/index>`.
   Amount of Connecting Edges
      Selects all vertices that have the same number of edges connected to them.

Edge Selection Mode:
   Length
      Selects all edges that have a similar length as those already selected.
   Direction
      Selects all edges that have a similar direction (angle) as those already selected.
   Amount of Faces Around an Edge
      Selects all edges that belong to the same number of faces.
   Face Angles
      Selects all edges that are between two faces forming a similar angle, as with those already selected.
   Crease
      Selects all edges that have a similar :ref:`Crease <modeling-edges-crease-subdivision>`
      value as those already selected.
   Bevel
      Selects all edges that have the same *Bevel Weight* as those already selected.
   Seam
      Selects all edges that have the same *Seam* state as those already selected.
      *Seam* is a mark used in :ref:`UV texturing <editors-uv-index>`.
   Sharpness
      Selects all edges that have the same *Sharp* state as those already selected.
      *Sharp* is a mark used by the :doc:`Edge Split Modifier </modeling/modifiers/generate/edge_split>`.

Face Selection Mode:
   Material
      Selects all faces that use the same material as those already selected.
   Area
      Selects all faces that have a similar area as those already selected.
   Polygon Sides
      Selects all faces that have the same number of edges.
   Perimeter
      Selects all faces that have a similar perimeter (added values of its edge lengths).
   Normal
      Selects all faces that have a similar normal as those selected.
      This is a way to select faces that have the same orientation (angle).
   Co-planar
      Selects all faces that are (nearly) in the same plane as those selected.
   Flat/Smooth
      Selects all faces with similar :doc:`face shading </modeling/meshes/editing/face/shading>`.
   Freestyle Face Marks
      Selects all faces with similar :ref:`Freestyle Face Marks <bpy.ops.mesh.mark_freestyle_face>`.

Compare
   For quantitative properties, this property selects the type of comparison to between the two numerical values.

   :Equal: Select items with the same value as the active item's chosen property.
   :Greater: Select items with a larger value as the active item's chosen property.
   :Less: Select items with a smaller value as the active item's chosen property.

Threshold
   For quantitative properties, this property controls how
   close the property's values have to be in the comparison.


.. _bpy.ops.mesh.select_similar_region:

Face Regions
============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Similar --> Face Regions`

Select matching features on a mesh that has multiple similar areas based on the topology.


## Extrude Cursor

.. _tool-mesh-extrude_cursor:

*****************
Extrude to Cursor
*****************

.. reference::

   :Mode:      Edit Mode
   :Shortcut:  :kbd:`Ctrl-RMB`

Interactively places new vertices with :kbd:`Ctrl-RMB` at the mouse cursor position.

The most basic element, a vertex, can be added with a :kbd:`Ctrl-RMB` click
when no other vertices are selected.
Because the camera space (computer screen) is two-dimensional,
Blender cannot determine all three vertex coordinates from a single mouse click,
so the new vertex is placed at the depth of the 3D cursor.

To create interconnected vertices, you can add a vertex and continuously make subsequent :kbd:`Ctrl-RMB`
operations with the last vertex selected.
This will link the last selected vertex with the vertex created at the mouse position with an edge
(see Fig. :ref:`fig-mesh-basics-add-one-tool`),
and will continuously create and connect new vertices if you continue repeating this operation.

.. _fig-mesh-basics-add-one-tool:

.. figure:: /images/modeling_meshes_tools_extrude-cursor_vertex.png

   Adding vertices one by one.


Creating Faces
==============

.. figure:: /images/modeling_meshes_tools_extrude-cursor_quad.png

   Quad from an Edge with source automatically rotated.

If you have two vertices selected and already connected with an edge, :kbd:`Ctrl-RMB` click
will create a planar face, also known as a quad. Blender will follow your mouse cursor
and will use the planar view from your viewport to create those quads.

For :kbd:`Ctrl-RMB`, Blender will automatically rotate the last selected Edge (the source)
for the subsequent operations if you have at least one face created, dividing the angles created between
the newly created edge and the last two edges, creating a smooth angle between them. Blender will calculate
this angle using the last positive and negative position of the last X and Y coordinates
and the last connected unselected edge. If this angle exceeds a negative limit (following a quadrant rule)
between the recently created edge and the last two, Blender will wrap the faces.
But if you do not want Blender to rotate and smooth edges automatically when extruding from :kbd:`Ctrl-RMB`,
you can also inhibit Blender from rotating sources using the shortcut :kbd:`Shift-Ctrl-RMB`.
In this case, Blender will not rotate the source dividing the angle between those edges when creating a face.

If you have three or more vertices selected, and :kbd:`Ctrl-RMB` click,
you will also create planar faces, but along the vertices selected, following the direction of the cursor.
This operation is similar to an extrude operation.

.. tip::

   When adding objects with :kbd:`Ctrl-RMB`, the extrusions of the selected elements,
   being vertices, edges and faces with the :kbd:`Ctrl-RMB`, are viewport dependent.
   This means, once you change your viewport, for example, from top to left, bottom or right,
   the extrusion direction will also follow your viewport and align the extrusions with your planar view.


## Extrude Manifold

.. _bpy.ops.view3d.edit_mesh_extrude_manifold_normal:

****************
Extrude Manifold
****************

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Extrude Manifold`
   :Menu:      :menuselection:`Mesh --> Extrude --> Extrude Manifold`

This tool is very similar to :doc:`/modeling/meshes/editing/face/extrude_faces`
but enables *Dissolve Orthogonal Edges* by default.
This causes the tool to automatically split and remove adjacent faces when extruding inwards.


Example
=======

.. figure:: /images/modeling_meshes_tools_extrude-manifold_example.gif

   Extrude Manifold Example.


## Extrude Region

.. _bpy.ops.mesh.extrude_region:
.. _tool-mesh-extrude_region:

**************
Extrude Region
**************

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Extrude Region`
   :Shortcut:  :kbd:`E`

Extrusion tools duplicate vertices, while keeping the new geometry connected with the original vertices.
Vertices are turned into edges and edges will form faces.

.. list-table::

   * - .. figure:: /images/modeling_meshes_tools_extrude-region_vert.png
          :width: 320px

          Single vertex extruded.

     - .. figure:: /images/modeling_meshes_tools_extrude-region_edge.png
          :width: 320px

          Single edge extruded.

This tool is of paramount importance for creating new geometry.
It allows you to create parallelepipeds from rectangles and cylinders from circles,
as well as easily creating such things as tree limbs.

The axis on which vertices and edges are extruded along can be set interactively.
Faces are extruded by default along their averaged normal.
The extrusion can be limited to a single axis by specifying an axis;
see :doc:`/scene_layout/object/editing/transform/control/axis_locking`.

The extrude tools differentiate in how the new geometry is connected in itself.

Only the border loop gets extruded.
The inner region of the selection gets moved unchanged with the extrusion.

.. list-table::

   * - .. figure:: /images/modeling_meshes_tools_extrude-region_face-before.png
          :width: 200px

          Selected face.

     - .. figure:: /images/modeling_meshes_tools_extrude-region_face-after.png
          :width: 200px

          During extrude.

     - .. figure:: /images/modeling_meshes_tools_extrude-region_face-after-zaxis.png
          :width: 200px

          Set to Z axis.


Details
=======

Although the process is quite intuitive,
the principles behind *Extrude* are fairly elaborate as discussed below:

- First, the algorithm determines the outside edge loop of the extrude; that is,
  which among the selected edges will be changed into faces. By default (see below),
  the algorithm considers edges belonging to two or more selected faces as internal, and hence not part of the loop.
- The edges in the edge loop are then changed into faces.
- If the edges in the edge loop belong to only one face in the complete mesh,
  then all of the selected faces are duplicated and linked to the newly created faces. For example,
  rectangles will result in parallelepipeds during this stage.
- In other cases, the selected faces are linked to the newly created faces but not duplicated.
  This prevents undesired faces from being retained "inside" the resulting mesh.
  This distinction is extremely important since it ensures the construction of consistently coherent,
  closed volumes at all times when using *Extrude*.
- When extruding completely closed volumes (like e.g. a cube with all its six faces),
  extrusion results merely in a duplication, as the volume is duplicated, without any link to the original one.
- Edges not belonging to selected faces, which form an "open" edge loop,
  are duplicated and a new face is created between the new edge and the original one.
- Single selected vertices which do not belong to selected edges
  are duplicated and a new edge is created between the two.


## Index


#########
  Tools
#########

.. toctree::
   :maxdepth: 2

   toolbar.rst
   tool_settings.rst


Types
=====

.. toctree::
   :maxdepth: 1

   extrude_region.rst
   extrude_manifold.rst
   extrude_cursor.rst
   loop.rst
   poly_build.rst
   spin.rst


## Loop

.. _tool-mesh-loop_cut:

********
Loop Cut
********

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Loop Cut`
   :Shortcut:  :kbd:`Ctrl-R`

The *Loop Cut* tool is a modal tool version of the :ref:`bpy.ops.mesh.loopcut_slide` operator.
This tool splits a loop of faces by inserting new edge loops intersecting the chosen edge.


Usage
=====

The tool is interactive and has two steps:

#. Pre-Visualizing the Cut

   After the tool is activated, move the cursor over a desired edge.
   The cut to be made is marked with a magenta colored line as you move the mouse over the various edges.
   The to be created edge loop stops at the poles (tris and n-gons) where the existing face loop terminates.

#. Perform the Cut

   Once the desired location of the new edge loop is found, the edge loop can be created via :kbd:`LMB`.

.. list-table::

   * - .. figure:: /images/modeling_meshes_tools_loop_before.png

          Mesh before inserting edge loop.

     - .. figure:: /images/modeling_meshes_tools_loop_preview.png

          Preview of edge loop location.

     - .. figure:: /images/modeling_meshes_tools_loop_placement.png

          Interactive placement of edge loop between adjacent loops.


Tool Settings
=============

Number of Cuts
   Increases and decreases the number of cuts to create.
   These cuts are uniformly distributed in the original face loop,
   and you will *not* be able to control their positions.

Correct UVs
   Corrects the corresponding UV coordinates, if these exist, to avoid image distortions.


Options
=======

After the modal tool is run
the :ref:`Loop Cut and Slide Options <modeling-meshes-editing-edge-loopcut-slide-options>`
are available in the :ref:`bpy.ops.screen.redo_last` panel.


## Poly Build

.. _bpy.ops.mesh.polybuild:
.. _tool-mesh-poly-build:

**********
Poly Build
**********

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Poly Build`

The *Poly Build* tool uses many built operators in an interactive way to add, delete, or move geometry.
This is extremely useful for retopology.


Tool Settings
=============

Create Quads
   Automatically split edges in triangles to maintain the quad topology.


Controls
========

Add Geometry :kbd:`Ctrl-LMB`
   Vertices or faces can be created by moving the cursor close to
   an element and using the hotkey to add a vertex or face.
   The tool first tries to create a face, however, if not enough geometry
   exists to create a face it will try to extrude a vertex to the cursor.
   When creating a face, the face can be previewed by holding :kbd:`Ctrl`.
Delete Mesh Elements :kbd:`Shift-LMB`
   Vertices, edges, and faces will be deleted by hovering over the element and using the hotkey.
   Elements with two or more connected elements will be :ref:`Dissolved <bpy.ops.mesh.dissolve>`.
   The element you are trying to delete will be highlighted in red while holding :kbd:`Ctrl`.
Moving Vertices :kbd:`LMB`
   Vertices can be moved by hovering over the vertex and
   using to hotkey to grab and move the vertex to the desired location.
   The vertex you are trying to move will be highlighted in blue while hovering over it.
Extruding Edges :kbd:`LMB`
   Edges can be :doc:`extruded </modeling/meshes/editing/edge/extrude_edges>`
   by moving the cursor close to an edge and using the hotkey to extrude the edge to the desired location.
   The edge you are trying to extrude will be highlighted in blue while hovering over it.

.. tip::

   It is useful to enable :ref:`vertex snapping <bpy.types.ToolSettings.snap_elements_base>`
   and use :ref:`bpy.ops.mesh.remove_doubles` while tweaking vertices to combine them.


## Spin

.. _bpy.ops.mesh.spin:
.. _tool-mesh-spin:

****
Spin
****

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Mesh --> Extrude --> Spin`
   :Tool:      :menuselection:`Toolbar --> Spin`

The *Spin* tool extrudes (or duplicates it if the selection is manifold) the selected elements,
rotating around a specific point and axis.

Use the tool to create the sort of objects that you would produce on a lathe
(this tool is often called "lathe" tool or "sweep" tool in the literature, for this reason).
In fact, it does a sort of circular extrusion of your selected elements,
centered on the 3D cursor, and around the axis perpendicular to the working view...

- The point of view will determine around which axis the extrusion spins...
- The position of the 3D cursor will be the center of the rotation.


Tool Settings
=============

Steps
   Specifies how many copies will be extruded along the "sweep".
Use Duplicates
   When enabled, will keep the original selected elements as separated islands in the mesh
   (i.e. unlinked to the result of the spin extrusion).
Axis
   Specifies the axis to use as the pivot of the spin operation.


Options
=======

Steps
   Specifies how many copies will be extruded along the "sweep".
Angle
   Specifies the angle "swept" by this tool, in degrees (e.g. set it to 180 for half a turn).
Auto Merge
   Automatically merges the first a last duplicates,
   if they make a full revolution which results in overlapping geometry.
Flip Normals
   Reverses the :term:`Normal's <Normal>` direction for any resulting geometry.
Center X, Y, Z
   Specifies the center of the spin. By default it uses the cursor position.
Axis X, Y, Z
   Specify the spin axis as a vector. By default it uses the view axis (viewport).


Example
=======

.. _fig-mesh-spin-glass:

.. figure:: /images/modeling_meshes_tools_spin_glass-profile.png
   :width: 300px

   Glass profile.

First, create a mesh representing the profile of your object.
If you are modeling a hollow object, it is a good idea to thicken the outline.
Fig. :ref:`fig-mesh-spin-glass` shows the profile for a wine glass we will model as a demonstration.

We will be rotating the object around the cursor in the top view,
so switch to the top view with :kbd:`Numpad7`.

.. _fig-mesh-spin-glass-top:

.. figure:: /images/modeling_meshes_tools_spin_glass-profile-before.png
   :width: 300px

   Glass profile, top view in Edit Mode, just before spinning.

Place the cursor along the center of the profile by entering Edit Mode
and selecting one of the vertices along the center, and snapping the 3D cursor to
that location with :menuselection:`Mesh --> Snap --> Cursor to Selection`.
(Fig. :ref:`fig-mesh-spin-glass-top`) shows the wine glass profile from
top view, with the cursor correctly positioned.

Select all the vertices with :kbd:`A` and select the *Spin* tool from the Toolbar
and use the Gizmo to spin the vertices. Fig. :ref:`fig-mesh-spin-profile` shows the result of a successful spin.


Angle
-----

.. _fig-mesh-spin-profile:

.. list-table:: Spun profile.

   * - .. figure:: /images/modeling_meshes_tools_spin_spun-profile360.png
          :width: 320px

          Spun profile using an angle of 360.

     - .. figure:: /images/modeling_meshes_tools_spin_spun-profile120.png
          :width: 320px

          Spun profile using an angle of 120.


Duplicate
---------

.. list-table::

   * - .. figure:: /images/modeling_meshes_tools_spin_result.png
          :width: 320px

          Result of spin operation.

     - .. figure:: /images/modeling_meshes_tools_spin_dubli.png
          :width: 320px

          Result of *Duplicate* enabled.


Merge Duplicates
----------------

.. _fig-mesh-screw-duplicate:

.. figure:: /images/modeling_meshes_tools_spin_dublicate-vertices.png
   :width: 300px

   Duplicate vertices.

The spin operation leaves duplicate vertices along the profile.
You can select all vertices at the seam with Box select :kbd:`B`
(shown in Fig. :ref:`fig-mesh-screw-duplicate`) and perform a *Merge by Distance* operation.

Notice the selected vertex count before and after the *Merge by Distance* operation
``Vertex count after removing doubles``. If all goes well, the final vertex count
(38 in this example) should match the number of the original profile noted in
:menuselection:`Mesh data --> Vertex and face numbers`.
If not, some vertices were missed and you will need to weld them manually.
Or, worse, too many vertices will have been merged.

.. note:: Merging Two Vertices into One

   To merge (weld) two vertices together, select both of them by :kbd:`Shift-LMB`
   clicking on them. Press :kbd:`S` to start scaling and hold down :kbd:`Ctrl`
   while scaling to scale the points down to 0 units in the X, Y and Z axis. :kbd:`LMB`
   to complete the scaling operation and click :menuselection:`Mesh --> Merge --> By Distance`
   to merge the vertices. Alternatively, you can use :menuselection:`Context Menu --> Merge Vertices` (or :kbd:`M`).
   Then, in the new pop-up menu, choose to merge *By Distance*.


Recalculate Normals
-------------------

All that remains now is to recalculate the normals to the outside by selecting all vertices,
pressing :kbd:`Alt-N` and validating *Recalculate Normals Outside* in the pop-up menu.


## Toolbar

.. _mesh-toolbar-index:

*******
Toolbar
*******

Mesh Edit Mode tools:

:ref:`Select <tool-select-tweak>`
   Select or move.

   :ref:`Select Box <tool-select-box>`
      Select geometry by dragging a box.
   :ref:`Select Circle <tool-select-circle>`
      Select geometry by dragging a circle.
   :ref:`Select Lasso <tool-select-lasso>`
      Select geometry by drawing a lasso.

Cursor
   Change the location of the 3D Cursor.

Move
   Translation tool.

Rotate
   Rotation tool.

Scale
   Scale tool.

   :ref:`Scale Cage <tool-scale-cage>`
      Change the scale of an object by controlling its cage.

Transform
   Tool to adjust the objects translation, rotations and scale.

:ref:`Annotate <tool-annotate-freehand>`
   Draw free-hand annotation.

   :ref:`Annotate Line <tool-annotate-line>`
      Draw straight line annotation.
   :ref:`Annotate Polygon <tool-annotate-polygon>`
      Draw a polygon annotation.
   :ref:`Annotate Eraser <tool-annotate-eraser>`
      Erase previous drawn annotations.

:ref:`Measure <tool-measure>`
   Measure distances in the scene.

:ref:`Add Cube <tool-add-cube>`
   Interactively add a cube mesh object.

   :ref:`Add Cone <tool-add-cone>`
      Interactively add a cone mesh object.
   :ref:`Add Cylinder <tool-add-cylinder>`
      Interactively add a cylinder mesh object.
   :ref:`Add UV Sphere <tool-add-cylinder>`
      Interactively add a UV sphere mesh object.
   :ref:`Add Icosphere <tool-add-icosphere>`
      Interactively add an icosphere mesh object.

:ref:`Extrude Region <tool-mesh-extrude_region>`
   Extrude the selected region together freely or along an axis.

   :doc:`Extrude Manifold </modeling/meshes/tools/extrude_manifold>`
      Extrudes region and dissolves overlapping geometry.
   :doc:`Extrude Along Normals </modeling/meshes/editing/face/extrude_faces_normal>`
      Extrude Region along their local normal.
   :ref:`Extrude Individual <tool-mesh-extrude_individual>`
      Extrude each individual element along their local normal.
   :ref:`Extrude To Cursor <tool-mesh-extrude_cursor>`
      Extrude selected vertices, edges or faces towards the mouse cursor.

:ref:`Inset Faces <tool-mesh-inset_faces>`
   Inset selected faces.
:ref:`Bevel <tool-mesh-bevel>`
   Create a bevel from the selected elements.
:ref:`Loop Cut <tool-mesh-loop_cut>`
   Create a loop cut along the mesh.

   :ref:`Offset Edge Loop Cut <bpy.ops.mesh.offset_edge_loops_slide>`
      Add two edge loops on either side of selected loops.

:ref:`Knife <tool-mesh-knife>`
   Create a knife cut in the mesh. Press enter to confirm the cut.

   :ref:`Bisect <tool-mesh-bisect>`
      Bisect the mesh.

:ref:`Poly Build <tool-mesh-poly-build>`
   Create geometry by adding vertices one by one.

:ref:`Spin <tool-mesh-spin>`
   Create new geometry by extruding and rotating.

:ref:`Smooth <tool-mesh-smooth>`
   Flatten angles of selected vertices.

   :ref:`Randomize <tool-mesh-smooth>`
      Randomize selected vertices.

:ref:`Edge Slide <tool-mesh-edge_slide>`
   Slide edge along a face.

   :ref:`Vertex Slide <tool-mesh-vertex-slide>`
      Slide vertex along an edge.

:ref:`Shrink/Flatten <tool-mesh-shrink-fatten>`
   Shrink selected vertices along their normals.

   :ref:`Push/Pull <tool-transform-push_pull>`
      Push or pull (scale) selected elements.

:ref:`Shear <tool-transform-shear>`
   Shear selected elements.

   :ref:`To Sphere <tool-transform-to_sphere>`
      Move vertices outwards in a spherical shape around object center.

:ref:`Rip Region <tool-mesh-rip_region>`
   Rip Polygons and move the result.

   :ref:`Rip Edge <tool-mesh-rip_edge>`
      Extend vertices and move the result.


## Tool Settings


*************
Tool Settings
*************

Options
=======

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Sidebar --> Tool tab --> Options panel`


Transform
---------

.. _bpy.types.ToolSettings.use_transform_correct_face_attributes:

Correct Face Attributes
   Adjust geometry attributes like :doc:`UVs </modeling/meshes/uv/index>`
   and :doc:`Color Attributes </sculpt_paint/vertex_paint/index>` while transforming.

.. _bpy.types.ToolSettings.use_transform_correct_keep_connected:

Keep Connected
   Merge attributes connected to the same vertex while using *Correct Face Attributes*.

   .. tip::

      Keeping UVs connected is useful for organic modeling, but not for architectural modeling.


.. _bpy.types.Mesh.use_mirror_x:
.. _bpy.types.Mesh.use_mirror_y:
.. _bpy.types.Mesh.use_mirror_z:
.. _modeling_meshes_tools-settings_mirror:

Mirror
^^^^^^

Mirror allows you to transform vertices symmetrically according to the chosen axis.
When you transform an element (vertex, edge or face),
if there is its exact axis-mirrored counterpart (in local space),
it will be transformed accordingly, through a symmetry along the chosen axis.

.. note::

   The conditions for *Mirror* to work are quite strict, which can make it difficult to use.
   To have an exact mirrored version of a (half) mesh,
   it's easier and simpler to use the :doc:`Mirror Modifier </modeling/modifiers/generate/mirror>`.


.. _bpy.types.Mesh.use_mirror_topology:

Topology Mirror
^^^^^^^^^^^^^^^

.. note::

   For *Topology Mirror* to work, at least one of the three *Mirror Axis* must be enabled.

When using any of the three *Mirror Axis* options to work on a mirrored Mesh Geometry, the vertices that
are mirrored must be perfectly placed. If they are not exactly positioned in their mirror
locations then the *Mirror Axis* will not treat those vertices as mirrored.

*Topology Mirror* tries to address this problem by determining which vertices are mirrored vertices not only by
using their positions but also by looking at how those vertices are related to others in the Mesh Geometry.
It looks at the overall topology to determine if particular vertices will be treated as mirrored.
The effect of this is that mirrored vertices can be non-symmetrical and yet still be treated as mirrored.

.. note::

   The *Topology Mirror* functionality will work more reliably on mesh geometry
   which is more detailed. If you use very simple geometry, for example
   a *Cube* or *UV Sphere*, the *Topology Mirror* option will often not work.


Example
"""""""

For an example of how to use *Topology Mirror* open up a new Blender scene,
then delete the default cube and add a Monkey object to the 3D Viewport.

#. Press :kbd:`Tab` to put the Monkey object into *Edit Mode*.
#. With all the *Mirror Axis* options disabled move one of the Monkey object's vertices slightly.
#. Then Turn the *X Axis Mirror* on but leave *Topology Mirror* disabled.
#. If you now move that vertex again, the *X Axis Mirror* will not work and the mirrored
   vertices will not be altered.
#. If you then enable *Topology Mirror* and move the same vertices again,
   then *X Axis Mirror* should still mirror the other vertex,
   even though they are not perfectly positioned.


.. _bpy.types.ToolSettings.use_mesh_automerge:

Auto Merge
^^^^^^^^^^

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Sidebar --> Tool --> Options --> Auto Merge`

When enabled, as soon as a vertex moves closer to another one
than the *Threshold* setting, they are automatically merged.
This option affects interactive operations only
(tweaks made in the :ref:`bpy.ops.screen.redo_last` panel are considered interactive too).
If the exact spot where a vertex is moved contains more than one vertex,
then the merge will be performed between the moved vertex and one of those.

.. _bpy.types.ToolSettings.use_mesh_automerge_and_split:

Split Edges & Faces
   Detects the intersection of each transformed edge, creating a new vertex in place
   and sectioning the edge and the face if any.

.. _bpy.types.ToolSettings.double_threshold:

Threshold
   Defines the maximum distance between vertices that are merged.


UVs
---

.. _bpy.types.ToolSettings.use_edge_path_live_unwrap:

Live Unwrap
   Automatically recalculates the UV unwrapping every time an edge has its seam property changed.
   Note, this is different than the :ref:`Live Unwrap <bpy.types.SpaceUVEditor.use_live_unwrap>`
   option in the UV Editor.


## Applying Image


*************
Using UV Maps
*************

Sooner or later, you may want to use an image texture on your model.
The UV Editor allows you to map textures directly to the mesh faces.
The 3D Viewport shows you the object being textured.
If you set the 3D Viewport into Textured viewport shading,
you will immediately see any changes made in the UV Editor, and vice versa.
This is because no real rendering is taking place; it is all just viewport shading.
If you were to apply an image to UVs then render, the texture would not show up by default.
So to render an image, you must:

- Create a Material for the object.
- Tell Blender to use the UV textures on faces when rendering.

To create a Material, you have to click *Add New* Material in the Shading context.

There are two ways to tell Blender to use the UV texture when rendering;
the quick way and the proper way.

The quick way is to use generated UV coordinates. Generated coordinates is used by
default by all :doc:`Texture nodes </render/shader_nodes/textures/index>`,
with the exception of Image textures that use UV coordinates by default.
To use generated coordinates for images as well use the *Generated* output of
the :doc:`Texture Coordinate node </render/shader_nodes/input/texture_coordinate>`.

The proper way is to use :doc:`UV Unwrapping </modeling/meshes/uv/unwrapping/index>`
to manually generate UV coordinates. To use UV mapping,
use the :doc:`Texture Coordinate node </render/shader_nodes/input/texture_coordinate>`
(UV output) or the :doc:`UV Map node </render/shader_nodes/input/uv_map>`
and select the UV map to use, "UVMap" by default.

Full details of using Image textures are on
the :doc:`Image Textures </render/materials/legacy_textures/types/image_movie>` page.

.. note:: Material is Required for Rendering

   You can perform UV texturing on a mesh within Blender without assigning a material,
   and you will even see it in your 3D Viewport in textured viewport mode. However, when you render,
   you will just get a default gray if the object does not have a Material assigned.
   You will get a black if you do not load an image. If you do not create a texture that uses the image,
   your object will render according to the procedural material settings.


Using the Test Grid
-------------------

If your image is a base uniform pattern and
you want the application of that image to your model to look like cloth,
you do **not** want any stretching (unless you want the cloth to look like spandex).
You may also need to test your UV mapping with a test image:

.. list-table::

   * - .. figure:: /images/modeling_meshes_uv_applying-image_test-grid-uvs.png
          :width: 320px

          The test grid applied to the UVs.

     - .. figure:: /images/modeling_meshes_uv_applying-image_test-grid-geometry.png
          :width: 320px

          A preview of the texture on the geometry.

When you render, the mesh will have the test grid as its colors,
and the UV texture will be the size image you specified.
Note that Blender has a built-in test image. To use it, press the New button of the data-block menu
in the Image editor header and change the *Generated Type* to UV Grid.


Modifying Your Image Texture
============================

.. seealso::

   - :doc:`Render Bake </render/cycles/baking>`
   - :doc:`Texture Paint </sculpt_paint/texture_paint/introduction>`

The advantage to saving as a separate file is that you can easily switch textures just by
copying other image files over it, and you can use external editing programs to work on it.
The advantage of packing is that your whole project is kept in the blend-file,
and that you only have to manage one file.


## Editing


*******
Editing
*******

After unwrap, you will likely need to arrange the UV maps,
so that they can be used in texturing or painting. Your goals for editing are:

- Stitch pieces (of UV maps) back together.
- Minimize wasted space in the image.
- Enlarge the faces where you want more detail.
- Re-size/enlarge the faces that are stretched.
- Shrink the faces that are too grainy and have too much detail.

With a minimum of dead space,
the most pixels can be dedicated to giving the maximum detail and fineness to the UV texture.
A UV face can be as small as a pixel (the little dots that make up an image)
or as large as an entire image. You probably want to make major adjustments first,
and then tweak the layout.


Transform
=========

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Move, Rotate, Scale, Transform`
   :Menu:      :menuselection:`UV --> Transform`

- Move :kbd:`G`
- Rotate :kbd:`R`
- Scale :kbd:`S`
- Shear :kbd:`Shift-Ctrl-Alt-S`


.. rubric:: Axis Locking

Transformations can be locked to an axis by pressing :kbd:`X` or :kbd:`Y` after one of the transform tools.
Also, holding the :kbd:`MMB` will constrain movement to the X or Y axis.


Vertex Slide
------------

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Transform --> Vertex Slide`

Vertex Slide will transform a vertex along one of its adjacent edges.
Use :kbd:`Shift-V` to activate tool.
The nearest selected vertex to the mouse cursor will be the control one.
Move the mouse along the direction of the desired edge to specify the vertex position.
Then press :kbd:`LMB` to confirm the transformation.

Factor
   Determines the amount of slide performed.
   Negative values correspond to slides toward one vertex, while positive ones, refer to the other one.
Even :kbd:`E`
   By default, the offset value of the vertices is a percentage of the edges length along which they move.
   When Even mode is active, the vertices are shifted by an absolute value.
Flipped :kbd:`F`
   When Flipped is active, vertices move the same distance from adjacent vertices,
   instead of moving from their original position.
Clamp :kbd:`Alt` or :kbd:`C`
   Toggle clamping the slide within the edge extents.


Edge Slide
----------

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Transform --> Edge Slide`

Slides one or more edges across adjacent faces with a few restrictions involving the selection
of edges (i.e. the selection *must* define a valid loop, see below).

Factor
   Determines the amount of slide performed.
   Negative values correspond to slides toward one face, while positive ones, refer to the other one.
Even :kbd:`E`
   Forces the edge loop to match the shape of the adjacent edge loop.
   You can flip to the opposite vertex using :kbd:`F`.
Flipped :kbd:`F`
   When Even mode is active, this flips between the two adjacent edge loops the active edge loop will match.
Clamp :kbd:`Alt` or :kbd:`C`
   Toggle clamping the slide within the edge extents.
Mirror Editing
   Lets you propagate the operation to the symmetrical elements of the mesh (if present, in local X direction).


Randomize
=========

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Transform --> Randomize`

Randomize the scale, rotation and offset of selected UV islands.
The *Randomize Transform* tool in the UV editor works
similar to *Randomize Transform* tool in the 3d view.

Random Seed
   Changes the random :term:`seed` used by the pseudo-random number generator,
   producing a different transform result for each seed value.
Location
   Amount to randomize location.
Rotation
   Amount to randomize rotation.
Scale Even
   Apply the same scale to the U coordinate and V coordinate.
Scale
   Amount to randomize scale in U and V coordinates.


Mirror
======

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Mirror`
   :Shortcut:  :kbd:`Ctrl-M`

UVs can be mirrored on the Y axis or the X axis:

- Mirror X
- Mirror Y

You can also use the hotkeys :kbd:`X` or :kbd:`Y`,
or hold the :kbd:`MMB` and drag in the mirror direction.


Copy Mirrored UV Coordinates
----------------------------

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Copy Mirrored UV Coordinates`

Copies UVs from one side of the mirrored mesh to the other.
Affects only selected vertices (on both sides).

Axis Direction
   Positive/Negative
Precision
   Tolerance for finding vertex duplicates.


.. _bpy.ops.uv.snap_selected:
.. _bpy.ops.uv.snap_cursor:

Snap
====

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Snap`
   :Shortcut:  :kbd:`Shift-S`

Snapping in the UV Editor is similar to
:doc:`Snapping in 3D </editors/3dview/controls/snapping>`.
For the snap to pixel options to work an image has to be loaded.

Selected to Pixels
   Moves selection to nearest pixel. See also *Round to Pixels* below.
Selected to Cursor
   Moves selection to 2D cursor location.
Selected to Cursor (Offset)
   Moves selection center to 2D cursor location, while preserving the offset of the vertices from the center.
Selected to Adjacent Unselected
   Moves selection to adjacent unselected element.

Cursor to Pixels
   Snaps the cursor to the nearest pixels.
Cursor to Selected
   Moves the Cursor to the center of the selection.
Cursor to Origin
   Places the cursor to the location (0, 0, 0).


.. _bpy.ops.uv.weld:

Merge
=====

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Merge`
   :Shortcut:  :kbd:`M`

At Center
   Moves selected UVs to their average position.
At Cursor
   Moves selection UVs to 2D cursor location.

.. _bpy.ops.uv.remove_doubles:

By Distance
   Merges selected UVs within the specified *Merge Distance*.


.. _bpy.ops.uv.select_split:

Split
=====

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Split`
   :Shortcut:  :kbd:`Alt-M`

Selection :kbd:`Y`
   Splits (disconnects) the selection from the rest of the UV.
   The border edge to any non-selected elements are duplicated.

   Note that the "copy" is left exactly at the same position as the original,
   so you must move it to see it clearly.


Unwrap
======

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Unwrap`
   :Shortcut:  :kbd:`U`

Blender offers several ways of mapping UVs.
The simpler projection methods use formulas that map 3D space onto 2D space,
by interpolating the position of points toward a point, axis or plane through a surface.
The more advanced methods can be used with more complex models, and have more specific uses.

- :ref:`bpy.ops.uv.unwrap`
- :ref:`bpy.ops.uv.smart_project`
- :ref:`bpy.ops.uv.lightmap_pack`
- :ref:`bpy.ops.uv.follow_active_quads`
- :ref:`bpy.ops.uv.cube_project`
- :ref:`bpy.ops.uv.cylinder_project`
- :ref:`bpy.ops.uv.sphere_project`


.. _bpy.ops.uv.pin:

Pin & Unpin
===========

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Pin/Unpin`
   :Shortcut:  :kbd:`P`, :kbd:`Alt-P`

You can pin UVs so they do not move between multiple unwrap operations.
When Unwrapping a model it is sometimes useful to "Lock" certain UVs,
so that parts of a UV layout stay the same shape, and/or in the same place.
Pinning is done by selecting a UV, then selecting *Pin* from the *UVs* menu,
or the shortcut :kbd:`P`. You can *Unpin a UV* with the shortcut :kbd:`Alt-P`.

Pinning is most effective when using the Unwrap method of UV mapping, for organic objects.
An example is when you are modeling a symmetrical object using
the :doc:`Mirror Modifier </modeling/modifiers/generate/mirror>`.
Some of the UVs on the mirror axis may be shared across the mirrored counterparts.
You could pin the UVs that correspond to the midline, then align them on the X axis,
and they will stay in that location.

The sculpting tools, *Pinch* and *Relax*, will not move any pinned UVs. This allows
you to pin the borders, or around interior holes, and gives even more control to the
sculpt tools.

Pinning also works great with the *Live Unwrap* tool. If you pin two or more UVs,
with *Live Unwrap* on, moving or scaling the pinned UVs will interactively unwrap the model.
You can even use the *Grab* sculpting tool to move the pinned UVs.
This helps with fitting a UV island to a certain shape or region.


Invert Pins
===========

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Invert Pins`

Pin all un-pinned selected UVs and un-pin all currently selected pinned UVs.


Mark/Clear Seams
================

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Mark/Clear Seam`

See :doc:`/modeling/meshes/uv/unwrapping/seams`.


.. _bpy.ops.uv.seams_from_islands:

Seams from Islands
==================

.. reference::

   :Mode:      View mode
   :Menu:      :menuselection:`UV --> Seams from Islands`

Adds seams at the boundaries of existing UV islands.
This is useful when modifying the UVs of already unwrapped meshes.


.. _bpy.ops.uv.pack_islands:

Pack Islands
============

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Pack Islands`

The *Pack Islands* tool can be used to optimize the UV layout by adjusting existing islands
to efficiently fill the :term:`Texture Space`. Based on the options selected,
the tool will scale, translate and rotate the islands,
ensuring a specified margin exists between them to maximize the usage of the UV space.
Pinned islands can have additional restrictions applied to customize the packing process even further.

Shape Method
   The method to use when considering the shape of each island.

   :Exact Shape (Concave):
      Use the complete shape of the island, including filling any holes or concave regions around the island.
   :Boundary Shape (Convex):
      Takes into account the boundary (Convex Hull) of the island.
      This method will not place islands inside holes.
   :Bounding Box: Uses the simple bounding box of the island.
Scale
   Scale the islands to fill the unit square, or pack islands towards the lower left corner.
Rotate
   Allows the rotation of islands, as well as translation and scaling, to optimize texture usage.
Rotation Method
   The allowable rotations to use for each each island.

   :Any:
      Any rotation which improves the packing is allowed.
   :Axis-aligned:
      The island will first be rotated into a smallest rectangle.
      Additional rotation will only be in 90-degree turns.
   :Cardinal:
      Like the four cardinal directions on a compass, North, South, East and West,
      only 90-degree turns will be allowed.
Margin Method
   The method to use when calculating the empty space between islands.

   :Scaled: Use scale of existing UVs to multiply margin.
   :Add: Simple method, just add the margin.
   :Fraction: Precisely specify the fraction of the UV unit square for margin. (Slower than other two methods.)
Margin
   The scale for the empty space between islands.
Lock Pinned Islands
   An island which has any of its UVs pinned is considered a *Pinned Island*.
   With this option, *Pinned Islands* will be unable to move. The other islands will pack around them.
Lock Method
   Change the way *Pinned Islands* are packed

   :Scale: The scale of the *Pinned Islands* will not change.
   :Rotation: *Pinned Islands* will not rotate.
   :Rotation and Scale: *Pinned Islands* can translate, but not scale nor rotate.
Merge Overlapping
   Before the main packing operation, overlapping islands are detected and temporarily combined.
   During packing, the relative rotation and position of the merged islands are preserved.
Pack To
   Determines the final placement of UV islands after completing the packing operation.

   :Closest UDIM: Pack islands to the :doc:`UDIM </modeling/meshes/uv/workflows/udims>` grid
       nearest to the center of the selection.
   :Active UDIM: Pack islands to the active UDIM image tile or, if no image is available,
       the UDIM grid tile where the 2D cursor is located.
   :Original bounding box: Find the original bounding box of the selection,
     packs the islands, and then moves them back inside the original box.

.. note::

   The performance of the *Pack Islands* operator is heavily affected by the options selected,
   and sometimes the options can combine in different ways to produce unexpectedly slower results.

   The fastest results can be obtained by using the "Bounding Box" shape method and the "Add" margin method.

   Although enabling the "Rotate" option slightly impacts performance, it will often enhance efficiency,
   making it a good choice to always keep enabled.

   However the "Fraction" margin method requires significantly more computation to find the exact scale.
   For certain layouts, it may even take up to 10 times longer to complete then using the simpler
   "Add" or "Scaled" methods.

   Similarly, the "Exact shape" and "Boundary shape" methods are much slower than the simple "Bounding Box" method.


.. _bpy.ops.uv.average_islands_scale:

Average Island Scale
====================

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Average Island Scale`

Using the *Average Island Scale* tool, will scale each
UV island so that they are all approximately the same scale.

Non-Uniform
   Reduces average texture stretching within islands by scaling the U and V axes independently.
Shear
   Reduces average texture shearing within islands by shearing the U axis.


.. _bpy.ops.uv.minimize_stretch:

Minimize Stretch
================

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Minimize Stretch`

The *Minimize Stretch* tool, reduces UV stretch by minimizing the difference between
the angles in 3D and the angles in UV space.
This operation is similar to the :doc:`/modeling/meshes/uv/tools/relax`
tool with the *Geometry* :ref:`Relaxation Method <bpy.types.ToolSettings.uv_relax_method>`,
but uses a different algorithm.

Fill Holes
   Just during *minimize stretch*, internal holes will be filled with temporary polygons
   to prevent stretching and overlaps of the surrounding UVs.
Blend
   The fraction between 0 and 1 of the original UVs to blend in once the stretch is minimized.
   A blend of 0 is the fully minimized stretch. Blend of 0.5 is halfway between the original UVs
   and the minimize stretch UVs.
Iterations
   More iterations result in smoother UVs, but take longer to process.


.. _bpy.ops.uv.stitch:

Stitch
======

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Stitch`
   :Shortcut:  :kbd:`Alt-V`

The *Stitch* tool, will join selected UVs that share vertices.
You set the tool to limit stitching by distance in the :ref:`bpy.ops.screen.redo_last` panel,
by activating *Use Limit* and adjusting the *Limit Distance*.


.. _bpy.ops.uv.align:

Align
=====

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Align`
   :Shortcut:  :kbd:`Shift-W`

The *Align* tool will move the selected UVs to a line, where that line is specified in different ways by *Axis*.

The *Straighten* option will calculate a line segment between two endpoints and move all selected UVs onto that line.

The *Align X* and *Align Y* options will axis-align all selected UVs to the midpoint of the current selection.

Axis
   :Straighten: Move UV to closest point on line segment.
   :Straighten X: Move *U* co-ordinates onto the line.
   :Straighten Y: Move *V* co-ordinates onto the line.
   :Align X: Move *U* co-ordinates to the midpoint of the selection.
   :Align Y: Move *V* co-ordinates to the midpoint of the selection.
   :Align Auto: Choose between *Align X* or *Align Y* automatically.


.. _bpy.ops.uv.align_rotation:

Align Rotation
==============

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Align Rotation`

The *Align Rotation* tool aligns entire islands to either the U or V axis.

The tool has three different methods of operation.
The different methods specify the source for the alignment,
and also whether to align with both the U and V axes,
or just the V axis alone.

When using the *Auto* method, islands are aligned so that UV edges are aligned
to either the U axis or the V axis. This method works best with quads
and meshes representing organic subjects.

When using the *Edge* method, only the selected edges are considered,
and the islands will be aligned such that the selected edges are aligned
with the V axis. This method works with the selection, so it works best
when a particular edge, or edge loop, needs to be aligned in UV coordinates.

When using the *Geometry* method, the geometry is taken into consideration.
Either the *X* axis, the *Y* axis, or the *Z* axis can be used. Suppose
the *X* axis is chosen. Using this method, edges which have a positive extent
in the *X* axis will be rotated in the UV map so that the edge
extends upwards in the *V* axis.
This method works best to align multiple islands which share some common
geometric property, either in the X, Y or Z axis.

Note that in the *Auto* method, edges can end up aligned either up or down or left or right
depending on the orientation of the island prior to activating the tool.
In the *Edge* method, the alignment of selected edges can be either up
or down in the V axis, whatever is closest to the current orientation of the UV island.
By comparison, in the *Geometry* method, the alignment will always be pointing up in the V axis,
ignoring any previous orientation.


.. _bpy.ops.uv.copy:

Copy UVs
========

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Copy UVs`

For each selected UV island, the *Copy UVs* tool will copy it's topology and UV coordinates into a temporary clipboard
for later use with the *Paste UVs* tool.

.. note::

   The *Copy UVs* tool currently uses an internal clipboard which is not shared between instances of blender.


.. _bpy.ops.uv.paste:

Paste UVs
=========

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Paste UVs`

For each selected UV island, the *Paste UVs* tool will attempt to match the topology of an island stored in the
internal clipboard. If a match is found, the UVs stored in the clipboard for the original island will be pasted
onto the currently selected island.

For example, if a triangle attached to a quad attached to a quad is in the clipboard, then a different triangle
<=> quad <=> quad is selected, then the topologies match, and the UVs will be pasted over the current selection.

For best results, you may want to use the Rip tool, or :menuselection:`UV > Split > Selection`, prior to using
*Paste UVs*.


.. _bpy.ops.uv.hide:
.. _bpy.ops.uv.reveal:

Show/Hide Faces
===============

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Show/Hide Faces`

- Reveal Hidden :kbd:`Alt-H`
- Hide Selected :kbd:`H`
- Hide Unselected :kbd:`Shift-H`


Export UV Layout
================

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UV --> Export UV Layout`

If you are using an external application, you need to know where on the mesh you are painting.

.. note::

   This is an :doc:`add-on </addons/import_export/mesh_uv_layout>` activated by default.


Proportional Editing
====================

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Header:    :menuselection:`Proportional Editing`
   :Menu:      :menuselection:`UV --> Proportional Editing`
   :Shortcut:  :kbd:`O`

Proportional Editing is available in UV editing. The controls are the same as in the 3D Viewport.
See :doc:`Proportional Editing in 3D </editors/3dview/controls/proportional_editing>`
for a full reference.


UV Options
==========

.. reference::

   :Editor:    UV Editor
   :Mode:      Edit Mode
   :Menu:      :menuselection:`UVs`

.. _bpy.types.SpaceUVEditor.use_live_unwrap:

Live Unwrap
   Continuously unwraps the selected UV islands while transforming pinned vertices.
   Note, this is different than the :ref:`Live Unwrap <bpy.types.ToolSettings.use_edge_path_live_unwrap>`
   option in the 3D Viewport.

.. _bpy.types.SpaceUVEditor.pixel_round_mode:

Round to Pixels
   During UV transforms, you can use Round to Pixels to help with matching features in the image
   or ensure your UVs have precise horizontal, vertical or diagonal alignment.

   Note that Round to Pixels is applied after any snapping modes.

   :Disabled: UVs will not be rounded.
   :Corner:
      Will force the UVs to round to the corner of the nearest pixel of an image if loaded.
   :Center:
      Will force the UVs to round to the center of the nearest pixel of an image if loaded.

.. _bpy.types.SpaceUVEditor.lock_bounds:

Constraining to Image Bounds
   For standard textures, this option prevents UVs from being moved outside the 0 to 1 UV range.
   For :doc:`UDIMs </modeling/meshes/uv/workflows/udims>` textures,
   this option prevents UVs from being moved outside the nearest UDIM tile.


3D Viewport
===========

.. _bpy.ops.mesh.uvs_rotate:

Rotate UVs
----------

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Rotate UVs`

The orientation of the UV texture is defined by each face.
If the image is, for example, upside down or laying on its side,
use the :menuselection:`Face --> Rotate UVs` (in the 3D Viewport in Face Select mode)
menu to rotate the UVs per face in 90-degree turns.


.. _bpy.ops.mesh.uvs_reverse:

Reverse UVs
-----------

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Face --> Face Data --> Reverse UVs`

The :menuselection:`Face --> Reverse UVs` tool mirrors the UVs per face,
which flips the image over, showing you the image reversed.


## Index


#######
  UVs
#######

.. toctree::
   :maxdepth: 2

   uv_texture_spaces.rst
   unwrapping/index.rst
   tools/index.rst
   editing.rst
   workflows/index.rst
   applying_image.rst


## Uv Texture Spaces


*******************
UVs & Texture Space
*******************

.. _uv-maps-panel:

UV Maps
=======

.. reference::

   :Mode:      All Modes
   :Panel:     :menuselection:`Properties --> Data --> UV Maps`

.. figure:: /images/modeling_meshes_uv_uv-texture-spaces_uv-maps.png

   The UV Maps panel in the Data tab.

If you have a mesh object selected, you'll find its UV maps in the Data tab of the
:doc:`Properties editor </editors/properties_editor>`. After selecting a map,
you can view and edit it in the :doc:`UV editor </editors/uv/introduction>`.

One mesh can have multiple UV maps (e.g. one map per texture), although it's
also possible to reuse a UV map for multiple textures.

Active Render
   Click the camera icon to make a certain UV map the default one for rendering.
   This will be the map that's used by the *UV* output of the
   :doc:`/render/shader_nodes/input/texture_coordinate`.
   You can use the :doc:`/render/shader_nodes/input/uv_map` to access any other maps.

Add ``+``
   Duplicates the selected UV map, or creates a new one if the list is empty.

Remove ``-``
   Removes the selected UV map.


.. _bpy.types.*texspace:
.. _bpy.types.Mesh.texture_mesh:
.. _bpy.ops.curve.match_texture_space:
.. _properties-texture-space:

Texture Space
=============

.. reference::

   :Mode:      All Modes
   :Panel:     :menuselection:`Properties --> Data --> Texture Space`

This panel lets you configure the object's :term:`Texture Space`, which is a 3D box
used for generating texture coordinates without the use of a UV map.
You can visualize the texture space using the option in the
:doc:`/scene_layout/object/properties/display` panel.

Auto Texture Space
   Calculates the texture space automatically.

   Location, Size
      Lets you define the texture space manually, relative to the object.
      Note that you can also edit it in the 3D Viewport -- see `Editing`_ below.

Texture Mesh :guilabel:`Mesh objects`
   Use another mesh for texture indices. The vertices of the two objects must be perfectly aligned
   or the UV map will be distorted.

Match Texture Space :guilabel:`Curve objects`
   Modifies the *Location* and *Size* to match the object's bounding box.
   This disables Auto Texture Space.

   .. is Match Texture Space the same thing as Auto Texture Space?


.. _properties-texture-space-editing:

Editing
-------

.. reference::

   :Mode:      Object Mode and Edit Mode
   :Menu:      :menuselection:`Object --> Transform --> Move/Scale Texture Space`

Click one of these menu items, then move the mouse to adjust the texture space
and press :kbd:`LMB` to confirm. While transforming, you can use keyboard shortcuts to lock
certain axes; see the status bar.


Accessing
---------

When setting up a material shader, you can use the *Generated* output of the
:doc:`/render/shader_nodes/input/texture_coordinate` to read the 3D coordinate
inside the object's texture space. You can then pass this coordinate to a texture
node.

.. tip::

   Texture spaces do not have rotation support. You can use a
   :doc:`/render/shader_nodes/vector/mapping` to manually rotate the coordinate
   in the material shader instead.


## Grab

****
Grab
****

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Grab`

The Grab tool moves UVs around.


Tool Settings
=============

Radius
   This option controls the radius of the brush, measured in pixels.
   :kbd:`F` allows you to change the brush size interactively by dragging the mouse and then :kbd:`LMB`.
   Typing a number then enter while using :kbd:`F` allows you to enter the size numerically.

Strength
   Controls how much each application of the brush affects the UVs.
   You can change the brush strength interactively by pressing :kbd:`Shift-F`
   in the 3D Viewport and then moving the brush and then :kbd:`LMB`.
   You can enter the size numerically also while in :kbd:`Shift-F` sizing.

Falloff
   The Falloff allows you to control the *Strength* falloff of the brush.
   The falloff is mapped from the center of the brush (left part of the curve)
   towards its borders (right part of the curve).
   Changing the shape of the curve will make the brush softer or harder.
   Read more about using the :ref:`ui-curve-widget`.

   Curve Preset
      :Custom:
         You can choose how the strength of the falloff is determined from the center of the brush
         to the borders by manually manipulating the control points within the curve widget.
         There are also a couple of preset custom curves displayed at the bottom of the curve widget
         that can be used on their own or as a starting point for tweaking.

         .. list-table:: Custom Preset types.

            * - .. figure:: /images/sculpt-paint_brush_falloff_custom-smooth.png

                  Smooth.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-sphere.png

                    Sphere.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-root.png

                  Root.

            * - .. figure:: /images/sculpt-paint_brush_falloff_custom-sharp.png

                  Sharp.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-linear.png

                  Linear.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-constant.png

                  Constant.

      :Smooth:
         The center strength, the border strength, and the falloff transition between them are evenly distributed.
      :Smoother:
         Similar to *Smooth* but produces a wider center point of the brush before tapering off.
      :Sphere:
         The strength of the brush is predominately at its strongest point
         with a steep falloff near the border of the brush.
      :Root:
         Similar to a Sphere but the center is a more concentrated point.
      :Sharp:
         The center of the brush is the strongest point
         then exponentially tapers off to a lower strength, creating a fine point.
      :Linear:
         With the center being the strongest,
         the strength will consistently weaken as it reaches the border of the brush.
      :Sharper:
         Similar to *Sharp* but the center point is more condensed.
      :Inverse Square:
         A hybrid between *Smooth* and *Sphere*.
      :Constant:
         The strength of the brush remains unified across the entire brush.
         This will create a sharp edge at the border of the brush.

Options
   Lock Borders
      Locks the boundary of UV islands from being affected by the brush.
      This is useful to preserve the shape of UV islands.
   Sculpt All Islands
      To edit all islands and not only the island nearest to the brush center
      when the sculpt stroke was started.


## Index


#########
  Tools
#########

.. toctree::
   :maxdepth: 2

   toolbar.rst


Types
=====

.. toctree::
   :maxdepth: 1

   rip.rst
   grab.rst
   relax.rst
   pinch.rst


## Pinch

*****
Pinch
*****

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Pinch`

The Pinch tool moves UVs toward the brush's center.
The pinch tool can be inverted by pressing :kbd:`Ctrl-LMB`.


Tool Settings
=============

Radius
   This option controls the radius of the brush, measured in pixels.
   :kbd:`F` allows you to change the brush size interactively by dragging the mouse and then :kbd:`LMB`.
   Typing a number then enter while using :kbd:`F` allows you to enter the size numerically.

Strength
   Controls how much each application of the brush affects the UVs.
   You can change the brush strength interactively by pressing :kbd:`Shift-F`
   in the 3D Viewport and then moving the brush and then :kbd:`LMB`.
   You can enter the size numerically also while in :kbd:`Shift-F` sizing.

Falloff
   The Falloff allows you to control the *Strength* falloff of the brush.
   The falloff is mapped from the center of the brush (left part of the curve)
   towards its borders (right part of the curve).
   Changing the shape of the curve will make the brush softer or harder.
   Read more about using the :ref:`ui-curve-widget`.

   Curve Preset
      :Custom:
         You can choose how the strength of the falloff is determined from the center of the brush
         to the borders by manually manipulating the control points within the curve widget.
         There are also a couple of preset custom curves displayed at the bottom of the curve widget
         that can be used on their own or as a starting point for tweaking.

         .. list-table:: Custom Preset types.

            * - .. figure:: /images/sculpt-paint_brush_falloff_custom-smooth.png

                  Smooth.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-sphere.png

                  Sphere.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-root.png

                  Root.

            * - .. figure:: /images/sculpt-paint_brush_falloff_custom-sharp.png

                  Sharp.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-linear.png

                  Linear.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-constant.png

                  Constant.

      :Smooth:
         The center strength, the border strength, and the falloff transition between them are evenly distributed.
      :Smoother:
         Similar to *Smooth* but produces a wider center point of the brush before tapering off.
      :Sphere:
         The strength of the brush is predominately at its strongest point
         with a steep falloff near the border of the brush.
      :Root:
         Similar to a Sphere but the center is a more concentrated point.
      :Sharp:
         The center of the brush is the strongest point
         then exponentially tapers off to a lower strength, creating a fine point.
      :Linear:
         With the center being the strongest,
         the strength will consistently weaken as it reaches the border of the brush.
      :Sharper:
         Similar to *Sharp* but the center point is more condensed.
      :Inverse Square:
         A hybrid between *Smooth* and *Sphere*.
      :Constant:
         The strength of the brush remains unified across the entire brush.
         This will create a sharp edge at the border of the brush.

Options
   Lock Borders
      Locks the boundary of UV islands from being affected by the brush.
      This is useful to preserve the shape of UV islands.
   Sculpt All Islands
      To edit all islands and not only the island nearest to the brush center
      when the sculpt stroke was started.


## Relax

*****
Relax
*****

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Relax`

The Relax tool can be used to distribute UVs more evenly.
It works by pulling vertices along UV edges to bring the UV unwrap into balance.

The Relax tool can be compared with the :ref:`bpy.ops.uv.minimize_stretch` tool which works directly
on faces to reduce texture stretching and shearing.
You may find that sometimes minimize stretch works better, sometimes the unwrap
tool and other times the Relax tool.

First using Unwrap, then Minimize Stretch and touching up with the Relax tool often gives the best results.
Remember, you can use "Undo" at any time to return to an earlier state.


Tool Settings
=============

Radius
   This option controls the radius of the brush, measured in pixels.
   :kbd:`F` allows you to change the brush size interactively by dragging the mouse and then :kbd:`LMB`.
   Typing a number then enter while using :kbd:`F` allows you to enter the size numerically.

Strength
   Controls how much each application of the brush affects the UVs.
   You can change the strength interactively by pressing :kbd:`Shift-F`
   in the 3D Viewport and then moving the brush and then :kbd:`LMB`.
   You can enter the size numerically also while in :kbd:`Shift-F` sizing.

Falloff
   The Falloff allows you to control the *Strength* falloff of the brush.
   The falloff is mapped from the center of the brush (left part of the curve)
   towards its borders (right part of the curve).
   Changing the shape of the curve will make the brush softer or harder.
   Read more about using the :ref:`ui-curve-widget`.

   Curve Preset
      :Custom:
         You can choose how the strength of the falloff is determined from the center of the brush
         to the borders by manually manipulating the control points within the curve widget.
         There are also a couple of preset custom curves displayed at the bottom of the curve widget
         that can be used on their own or as a starting point for tweaking.

         .. list-table:: Custom Preset types.

            * - .. figure:: /images/sculpt-paint_brush_falloff_custom-smooth.png

                  Smooth.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-sphere.png

                  Sphere.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-root.png

                  Root.

            * - .. figure:: /images/sculpt-paint_brush_falloff_custom-sharp.png

                  Sharp.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-linear.png

                  Linear.

              - .. figure:: /images/sculpt-paint_brush_falloff_custom-constant.png

                  Constant.

      :Smooth:
         The center strength, the border strength, and the falloff transition between them are evenly distributed.
      :Smoother:
         Similar to *Smooth* but produces a wider center point of the brush before tapering off.
      :Sphere:
         The strength of the brush is predominately at its strongest point
         with a steep falloff near the border of the brush.
      :Root:
         Similar to a Sphere but the center is a more concentrated point.
      :Sharp:
         The center of the brush is the strongest point
         then exponentially tapers off to a lower strength, creating a fine point.
      :Linear:
         With the center being the strongest,
         the strength will consistently weaken as it reaches the border of the brush.
      :Sharper:
         Similar to *Sharp* but the center point is more condensed.
      :Inverse Square:
         A hybrid between *Smooth* and *Sphere*.
      :Constant:
         The strength of the brush remains unified across the entire brush.
         This will create a sharp edge at the border of the brush.

Options
   Lock Borders
      Locks the boundary of UV islands from being affected by the brush.
      This is useful to preserve the shape of UV islands.
   Sculpt All Islands
      To edit all islands and not only the island nearest to the brush center
      when the sculpt stroke was started.

.. _bpy.types.ToolSettings.uv_relax_method:

Method
   There are three ways to determine the edge weighting:

   :Laplacian:
     The classic discrete laplace operator applied to the UV graph. Each edge has equal weighting,
     resulting in triangles which resemble a honeycomb shape, or quads aligned into square grid.
   :HC:
     Similar to Laplacian, the HC method uses equal weighting while trying to preserve
     a gradient between dense regions of the mesh and regions with fewer edges.e

     Note, this method uses the "Humphrey's Classes" operator as described in the paper:
     `"Improved Laplacian Smoothing of Noisy Surface Meshes"
     <http://informatikbuero.com/downloads/Improved_Laplacian_Smoothing_of_Noisy_Surface_Meshes.pdf>`__.
   :Geometry:
     Edges are weighted according to the discrete laplace operator (cotangent formula) applied to the 3D geometry.
     This tries to bring the relative lengths of edges in UV closer to the relative lengths of edges in 3D,
     resulting in a UV unwrap with less distortion across edge boundaries.


## Rip

.. _bpy.ops.uv.rip:
.. _bpy.ops.uv.rip_move:

***
Rip
***

.. reference::

   :Mode:      Edit Mode
   :Tool:      :menuselection:`Toolbar --> Rip`
   :Shortcut:  :kbd:`V`

The Rip tool separates UV components (vertices, edges, faces) from connected components.
The components are ripped in the direction of the mouse pointer position.

.. list-table::

   * - .. figure:: /images/modeling_meshes_uv_tools_rip_before.png

          Before.

     - .. figure:: /images/modeling_meshes_uv_tools_rip_after.png

          After.

.. seealso::

   Mesh editing :ref:`Rip <bpy.ops.mesh.rip_move>` operation.


## Toolbar


*******
Toolbar
*******

:ref:`Select <tool-select-tweak>`
   Select or moved.

   :ref:`Select Box <tool-select-box>`
      Select UVs by dragging a box.
   :ref:`Select Circle <tool-select-circle>`
      Select UVs by painting on it.
   :ref:`Select Lasso <tool-select-lasso>`
      Select UVs by drawing a lasso.

Cursor
   Change the location of the 2D Cursor.

Move
   Translation tool.
Rotate
   Rotation tool.
Scale
   Scale tool.

Transform
   Tool to adjust the UVs translation, rotation and scale.

:ref:`Annotate <tool-annotate-freehand>`
   Draw free-hand annotation.

   :ref:`Annotate Line <tool-annotate-line>`
      Draw straight line annotation.
   :ref:`Annotate Polygon <tool-annotate-polygon>`
      Draw a polygon annotation.
   :ref:`Annotate Eraser <tool-annotate-eraser>`
      Erase previous drawn annotations.

:doc:`Rip </modeling/meshes/uv/tools/rip>`
   The Rip tool separates UV faces from each other.

:doc:`Grab </modeling/meshes/uv/tools/grab>`
   The Grab tool moves UVs around using a brush.
:doc:`Relax </modeling/meshes/uv/tools/relax>`
   The Relax tool makes UVs more evenly distributed using a brush.
:doc:`Pinch </modeling/meshes/uv/tools/pinch>`
   The Pinch tool moves UVs toward the brush's center.


## Index


##############
  Unwrapping
##############

.. toctree::
   :maxdepth: 2

   introduction.rst
   seams.rst


## Introduction


************
Introduction
************

The first step is to unwrap your mesh. Generally, it is recommended to start unwrapping
when only minor adjustments to the geometry of your model are required.
If you do add faces or subdivide existing faces when a model is already unwrapped,
Blender will add those new faces for you,
but you may need to do additional mapping or editing. In this fashion,
you can use the UV texture image to guide additional geometry changes.


About UVs
=========

Every point in the UV map corresponds to a vertex in the mesh.
The lines joining the UVs correspond to edges in the mesh.
Each face in the UV map corresponds to a mesh face.
Think of a UV map as projecting the surface of your 3D model onto a 2D image.

Each face of a mesh can have many UV textures. Each UV texture can have an individual image assigned to it.
When you unwrap a face to a UV texture in the UV Editor, each face of the mesh is automatically assigned
four UV coordinates: These coordinates define the way an image or a texture is mapped onto the face.
To distinguish from XYZ coordinates, the U and V axes are used to mark the coordinates of each point.
Hence the name, UV unwrapping. These coordinates can be used for rendering or for real-time viewport
display as well.

Every face in Blender can have a link to a different image.
The UV coordinates define how this image is mapped onto the face.
This image then can be rendered or displayed in real-time.
A 3D Viewport has to be in "Face Select" mode to be able to assign Images or
change UV coordinates of the active mesh object.
This allows a face to participate in many UV textures.
A face at the hairline of a character might participate in the facial UV texture,
*and* in the scalp/hair UV texture.

These are described more fully in the next sections.


Getting Started
===============

.. figure:: /images/modeling_meshes_uv_unwrapping_introduction_uvtab.png
   :width: 620px

   Default UV editing workspace.

By default, meshes are not created with UVs. First you must map the faces, then
you can :doc:`edit them </modeling/meshes/uv/editing>`.
The process of unwrapping your model is done within Edit Mode in the 3D Viewport.
This process creates one or more UV Islands in the :ref:`UV Editor <editors-uv-index>`.

To begin, choose the *UV Editing* :doc:`workspace </interface/window_system/workspaces>`
from the selection list at the top of your screen in the Preferences header.
This sets one of the areas to show you the UV Editor, and the other area to the 3D Viewport.

Enter *Edit Mode*, as all unwrapping is done in Edit Mode.
You can be in vertex, face, or edge selection mode.


Workflow
--------

The general workflow is as follows, but know that different models may require
different approaches to unwrapping:

#. Mark Seams if necessary. See more about :doc:`marking seams </modeling/meshes/uv/unwrapping/seams>`.
#. Select mesh faces in the 3D Viewport.
#. Select a UV mapping method from the :menuselection:`UV --> Unwrap` menu or
   the UV menu in the 3D Viewport.
#. Adjust the unwrap settings in the :ref:`Adjust Last Operation <bpy.ops.screen.redo_last>` panel.
#. Add a test image to see if there will be any distortion.
   See :doc:`Applying Images to UVs </modeling/meshes/uv/applying_image>`.
#. Adjust UVs in the UV editor. See :doc:`Editing UVs </modeling/meshes/uv/editing>`.


## Seams


*****
Seams
*****

For many cases, using the Unwrap calculations of Cube, Cylinder, Sphere,
or the regular "Unwrap" operators will produce a good UV layout.
But for more complex meshes, especially those with lots of indentations,
you may want to define a *seam* to limit and guide the :ref:`bpy.ops.uv.unwrap` operator.

Just like in sewing, a seam is where the ends of the image/cloth are sewn together.
In unwrapping, the UV map is discontinuous at the seams.
Think of this method as peeling an orange or skinning an animal.
You make a series of cuts in the skin, then peel it off. You could then flatten it out,
applying some amount of stretching. These cuts are the same as seams.

.. figure:: /images/modeling_meshes_uv_unwrapping_seams_cylinder.png

   Simple seam on a cylinder.

When using this method, you need to be aware of how much stretching there is.
The more seams there are, the less stretching there is,
but this is often an issue for the texturing process.
It is a good idea to have as few seams as possible while having the least amount of stretching.
Try to hide seams where they will not be seen. In productions where 3D paint is used,
this becomes less of an issue, as projection painting can easily deal with seams,
as opposed to 2D texturing, where it is difficult to match the edges of different UV islands.

The workflow is the following:

#. Mark seams.
#. Unwrap.
#. Adjust seams and repeat.
#. Manually adjust UVs.


.. _bpy.ops.uv.mark_seam:

Mark Seam
=========

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Tool:      :menuselection:`UV --> Mark/Clear Seam`
   :Menu:      :menuselection:`Edge --> Mark/Clear Seam`

.. reference::

   :Editor:    UV Editor
   :Mode:      View mode
   :Menu:      :menuselection:`UV --> Mark/Clear Seam`

.. figure:: /images/modeling_meshes_uv_unwrapping_seams_suzanne.png
   :width: 250px

   Seamed Suzanne.

To add an edge to a seam, simply select the edge and press :kbd:`Ctrl-E` to *Mark Seam*,
or to remove it, use :kbd:`Ctrl-E` to *Clear Seam*.

In the example to the right, the back-most edge of the cylinder was selected as the seam
(to hide the seam), and the default unwrap calculation was used.
In the UV Editor, you can see that all the faces are nicely unwrapped,
just as if you cut the seam with a scissors and spread out the fabric.

When marking seams, you can use the :menuselection:`Select --> Linked Faces`
or :kbd:`Ctrl-L` in Face Select Mode to check your work.
This menu option selects all faces connected to the selected one, up to a seam.
If faces outside your intended seam are selected, you know that your seam is not continuous.
You do not need continuous seams, however, as long as they resolve regions that may stretch.

Just as there are many ways to skin a cat, there are many ways to go about deciding where seams should go.
In general though, you should think as if you were holding the object in one hand, and a pair of
sharp scissors in the other, and you want to cut it apart and spread it on the table with as little
tearing as possible. Note that we seamed the outside edges of her ears, to separate the front from the back.
Her eyes are disconnected sub-meshes, so they are automatically unwrapped by themselves.
A seam runs along the back of her head vertically, so that each side of her head is flattened out.

Another use for seams is to limit the faces unwrapped. For example, when texturing a head, you
do not really need to texture the scalp on the top and back of the head since it will be
covered in hair. So define a seam at the hairline. Then, when you select a frontal face,
and then select linked faces before unwrapping,
the select will only go up to the hairline seam, and the scalp will not be unwrapped.

When unwrapping anything that is bilateral, like a head or a body, seam it along the mirror axis.
For example, cleave a head or a whole body right down the middle in front view. When you unwrap,
you will be able to overlay both halves onto the same :term:`Texture Space`,
so that the image pixels for the right hand will be shared with the left;
the right side of the face will match the left, etc.

.. note::

   You **do not** have to come up with "one unwrapping that works perfectly for everything everywhere".
   As we will discuss later, you can easily have multiple UV unwrappings,
   using different approaches in different areas of your mesh.


Seams from Islands
------------------

.. reference::

   :Mode:      View mode
   :Menu:      :menuselection:`UV --> Seams from Islands`

Adds seams at the boundaries of existing UV islands.
This is useful when modifying the UVs of already unwrapped meshes.


## Index


#############
  Workflows
#############

.. toctree::
   :maxdepth: 2

   layout.rst
   udims.rst


## Layout


***************
Layout Workflow
***************

Transferring UV Maps
====================

You can copy a UV map from one mesh to another mesh provided both meshes have the same geometry/vertex order.
This is useful for example when you want to recreate a UV map from an earlier version of your model with intact UVs.
This works by:

#. Select the target mesh (to which you want to copy the UV map).
#. :kbd:`Shift` select the source mesh (that contains the intact UV map).
#. :menuselection:`Object menu --> Make Links... --> Transfer UV Layouts` (Shortcut: :kbd:`Ctrl-L` ...).

The target mesh will now have a UV map that matches the original mesh.


Multiple UV Maps
================

You are not limited to one UV map per mesh.
You can have multiple UV maps for parts of the mesh by creating new UV maps.
This can be done by clicking the *Add* button next to :ref:`UV maps list <uv-maps-panel>`
and unwrapping a different part of the mesh. UV maps always include the whole mesh.

.. TODO2.8 add: Continue image clipping.


Optimizing the UV Layout
========================

When you have unwrapped, possibly using seams, your UV layout may be quite disorganized and chaotic.
You may need to proceed with the following tasks: Orientation of the UV mapping,
arranging the UV maps, stitching several maps together.

The next step is to work with the UV layouts that you have created through the unwrap process.
If you do add faces or subdivide existing faces when a model is already unwrapped,
Blender will add those new faces for you. In this fashion,
you can use the UV texture image to guide additional geometry changes.

When arranging, keep in mind that the entire view is your workspace,
but only the UV coordinates within the grid are mapped to the image.
So, you can put pieces off to the side while you arrange them.
Also, each UV unwrap is its own linked set of coordinates.

You can lay them on top of one another, and they will onion skin
(the bottom one will show through the top one). To move only one though,
:kbd:`RMB` select one of the UV coordinates,
and use :menuselection:`Select --> Linked UVs`, :kbd:`Ctrl-L`
to select connected UVs, not box select because UVs from both will be selected.


Combining UV Maps
-----------------

.. figure:: /images/modeling_meshes_uv_workflows_layout_combining-uv-maps-1.png

   Bad unwrap, note ear and neck.

Very often you will unwrap an object, such as the face example we have been using,
and get it "mostly right" but with parts of the mesh that did not unwrap properly,
or are horribly confusing. The picture to the right shows an initial unwrap of the face using
the Unwrap from sphere option. The issues are with the ear; it is just a mush of UVs,
and the neck, it is stretched and folded under. Too much work to clean up.

.. figure:: /images/modeling_meshes_uv_workflows_layout_combining-uv-maps-2.png

   Unwrap face only, without ear or neck.

We can tell that the ear would unwrap nicely with just a straightforward projection from
the side view, and the neck with a tubular unwrap.
So, our general approach will be to unwrap different parts of the object (face, ears, and so on)
using different unwrap tool,
selecting each tool according to which one works best for that part. So let us begin:
We select only the "face" faces, unwrap them using the *Sphere* projection, and scale and
rotate them a bit to fit logically within the image area of the UV Editor.

.. figure:: /images/modeling_meshes_uv_workflows_layout_combining-uv-maps-3.png

   Unwrap ear only, using *Project from View*.

Once we are satisfied with the face, it is time to turn our attention to the ear. First, deselect
the faces you were working with. Their UVs will disappear from the UV Editor, but they are still there,
just not shown. (To verify this, you can select a few faces in 3D Viewport and it will show up in the UV Editor.)

To work on the ear, in the 3D Viewport, we now select only the "ear" faces.
You can use vertex groups to select the ear faces. Selecting sub-meshes is easy too,
since they are not connected to the rest of the mesh.
Simply selecting linked vertices will select that entire submesh. Basically,
since you are in Edit Mode, all the selecting/deselecting features are available to you.

Now unwrap the ear again using the *Project* tool from side view,
and scale and rotate them a bit (discussed in the next section),
and place them off to the side. You can do this repetitively, using different unwrapping algorithms;
each re-apply just puts those UVs for the selected faces somewhere else.
Choose the tool for each part that gives you the best fit and
most logical layout for subsequent painting of that part.

When all parts of the mesh have been unwrapped using the various methods,
you should end up with something that looks like the example to the right.
All sections of the mesh have been mapped,
and all those maps are laid out in the same UV texture map. Congratulations! From here,
it is a simple matter of "stitching" (discussed in the next section)
to construct the entire UV map as a single map.

.. figure:: /images/modeling_meshes_uv_workflows_layout_combining-uv-maps-4.png

   UV maps arranged together and stitched.

When you have completed arranging and stitching, you will end up with a consolidated UV map,
like that shown to the right, arranged such that a single image will cover, or paint,
all of the mesh that needs detailed painting.
All the detailed instructions on how to do this are contained in the next section.
The point of this paragraph is to show you the ultimate goal.
Note that the mesh shown is Mirrored along the Z axis,
so the right side of the face is virtual; it is an exact copy of the right,
so only one set of UVs actually exist. (If more realism is desired,
the Mirror Modifier would be applied, resulting in a physical mirror and a complete head.
You could then make both side physically different by editing one side and not the other.
Unwrapping would produce a full set of UVs (for each side)
and painting could thus be different for each side of the face, which is more realistic).


Iteration & Refinement
----------------------

At least for common people, we just do not "get it right the first time." It takes building on
an idea and iterating our creative process until we reach that magical milestone called "Done".
In software development, this is called the 'spiral methodology'.

Applied to computer graphics, we cycle between modeling, texturing, animating,
and then back to making modifications to mesh, UV mapping, tweaking the animation,
adding a bone or two, finding out we need a few more faces, so back to modeling, etc.
We continue going round and round like this until we either run out of time, money,
or patience, or, in rare cases, are actually happy with our results.


Refining the Layout
===================

Refinement comes into play when we finally look at our character,
and realize that we need more detail in a particular spot. For example,
areas around the eyes might need crow's feet, or we need to add a logo to the vest.
As you start to edit the image,
you realize that there just are not enough pixels available to paint the detail that you want.

Your only choice is to expand the size (scale out) that UV face.
Using the *Minimize Stretch* or *Scale* tools,
you expand the UV faces around the eyes or chest, allocating more pixels to those areas,
but at the same time taking away pixels (detail) from somewhere else,
like the back of the head. After refining the UV map,
you then edit the image so that it looks right and contains the details you want.


Reusing Textures
----------------

Another consideration is the need to conserve resources. Each image file is loaded in memory.
If you can reuse the same image on different meshes, it saves memory. So, for example,
you might want to have a generic face painting, and use that on different characters,
but alter the UV map and shape and props (sunglasses) to differentiate.

You might want to have a "faded blue jeans" texture,
and unwrap just the legs of characters to use that image.
It would be good to have a generic skin image, and use that for character's hands, feet, arms,
legs, and neck. When modeling a fantasy sword,
a small image for a piece of the sword blade would suffice,
and you would *Reset Unwrap* the sword faces to reuse that image down the length of the blade.


## Udims


*****
UDIMs
*****

Using UV maps can have one disadvantage, they consist of one texture for the entire mesh.
Most of the time this is sufficient but the disadvantage is that the texture is one resolution for the entire mesh.
This causes issues if you have a very large mesh with geometry of different importance.
When using a singular texture, the resolution might be too low to cover larger UV islands
while being inefficient for smaller, less important islands.

UDIM offers a solution to this by being able to spread UV islands across several different textures.
UDIM which stands for U DIMension is based on a tile system
where each tile is a different texture in the overall UDIM texture array.
Basically each tile consists of its own UV space (0-1, 1-2, 2-3) and have its own image assigned to that tile.
Tiles are managed in the `UDIM Tiles`_ panel where they can have a generated image assigned to them.
Generally, you create several textures of different resolutions;
for example, you may have a 4k resolution texture for the major details,
and 2k and/or 1k textures for less important details.

The UDIM array consists of one main tile, this tile is given the index number of ``1001``.
The next tile that gets added will be ``1002`` and will be placed to the right of the main tile.
The overall UDIM array is ten tiles wide, so tiles ``1001`` through ``1010`` are created on the first row.
After ten tiles a new row of tiles is started above the main tile; so ``1011`` will be place directly above ``1001``.


Workflow
========

To start using a UDIM workflow, you should unwrap a mesh as you would for any other UV map.
After that you should decide how many textures you want to split your UV map into.
This will be different for every mesh and workflow but a good minimum is 3: one 4k, one 2k, and one 1k image.
Then create the desired textures to match how many textures you want.

After this it is the same process of moving UVs to the appropriate tile
and scaling and managing them like any other UV map.
See :doc:`/modeling/meshes/uv/workflows/layout` for information on laying out UVs.

When the UVs are correctly set up across the multiple UV islands it is time to add proper textures the UDIM array.
Currently, existing textures cannot be added to a tile,
to fill a tile with an existing texture you first must:

#. Create the desired tiles.
#. Save the image.
#. Replace the saved image file with the desire texture by deleting the file
   and replacing it with a new image file, keeping the old file name.
   Or by opening the image in another application and modifying the contents of the image.

Other than using a third-party application to edit the UDIM texture it is possible to paint on UDIM textures.
This works for either 2D Painting or :doc:`3D Painting </sculpt_paint/texture_paint/index>`.


File Substitution Tokens
========================

Substitution tokens are special sequences of characters in a filename
that can be replaced with more meaningful and context aware information.
In this case, tokens are identified by being text wrapped in angle bracket characters.

This substitution is used while load loading or saving an image
to automatically identify the tile associated with a particular texture in the UDIM array.

The following tokens are supported:

- ``<UDIM>``: A 4-digit notation calculated as ``1001 + u-tile + v-tile * 10``.
- ``<UVTILE>``: A notation defined as ``u(u-tile + 1)_v(v-tile + 1)``.

Examples:

- ``monster-basecolor.<UDIM>.png`` will load/save files like ``monster-basecolor.1021.png`` etc.
- ``monster-basecolor.<UVTILE>.png`` will load/save files like ``monster-basecolor.u1_v3.png`` etc.


.. _bpy.ops.image.tile:
.. _bpy.types.UDIMTiles:

UDIM Tiles
==========

.. reference::

   :Editor:    Image Editor, UV Editor
   :Mode:      All Modes
   :Panel:     :menuselection:`Sidebar --> Image --> UDIM Tiles`

In this panel UDIM tiles are managed;
new tiles can be added, tiles can be removed, or tiles can filled with a generated texture.

UDIM Tile List
   List all UDIM tiles associated with the main index (``1000`` tile).
   Double clicking on the tile name allows you to alter the tiles *Label*.

Add Tile ``+``
   Adds new UDIM tiles to the group.

   Number
      The starting tile index number.
      UDIMs must start with the ``1001`` tile and typically increase in incremental order.
   Count
      The number of tiles to add.
   Label
      An optional label can be used instead of the index number.
      These labels are shown in the 2D Viewport.
   Fill
      Occupy the UDIM tile with a generated image; see *Fill Tile* below.

Remove Tile ``-``
   Deletes the selected UDIM tile from the group.
   If this tile is not saved and contains data, that data will be lost.

Fill Tile
   Occupy the UDIM tile with a :ref:`Generated Image <image-generated>`.

   .. warning::

      If a tile is not filled, it will not be saved with the image.


## Editing

.. _meta-ball-editing:

*******
Editing
*******

In addition to having several meta objects in a same family,
you can also have several meta primitives in a single object (just add some more while in Edit Mode).
Each will be an element, with its own shape, editing rings (in the viewport), and settings.


.. _bpy.ops.mball.delete_metaelems:

Deleting Elements
=================

.. reference::

   :Shortcut:  :kbd:`X`, :kbd:`Delete`

You can only delete the active element, no fancy options here.


Conversion
==========

To convert the meta to a real mesh, use :ref:`object-convert-to` in Object Mode.


.. _meta-ball-object-families:

Object Families
===============

A "family" is a way to regroup several meta objects,
producing something very similar to having several metas inside the same object.

It is defined by the left part of an object's name (the one before the first dot).
Remember, an object's name is the one in the *Object Name* field, in most panels,
**not** the *Metaball Name* field, which is the meta data-block's name...
For example, the *family* part of "MetaPlane.001" is ``MetaPlane``.
Each meta object in the same "family" is associated with one another as discussed below.

.. figure:: /images/modeling_metas_editing_family.png
   :align: center
   :width: 450px

   Metaball family.

Families of metas are controlled by a *base* meta object which is identified by
an object name **without** a dot in it. For example,
if we have three metas called ``MetaThing``, ``MetaThing.001``,
``MetaThing.round``, the *base* meta object would be ``MetaThing``.

The *base* meta object determines the basis, the resolution, the threshold,
*and* the transformations. It also has the material and texture area.
In a way, the *base* meta is the "owner" of the other metas in the family
(i.e. it is as if the other metas were "included" or joined into the base one).

.. hint::

   When working with multiple scenes,
   take care naming your meta objects so the *base* is always in the same scene as other metas.

   Failing to do so will give confusing behaviors (like invisible meta objects).


Examples
========

Fig. :ref:`fig-meta-ball-base` shows the *base* meta labeled "B".
The other two *Meta* objects are *children*. Children's selection rings are always black,
while the group's mesh is orange. Because the metas are grouped,
they form a unified mesh which can always be selected by selecting the mesh of any meta in the group.

.. _fig-meta-ball-base:

.. figure:: /images/modeling_metas_editing_base-example.png
   :align: center
   :width: 450px

   Meta ball base.

For example, in Fig. :ref:`fig-meta-ball-base`, only the lower sphere (the parent) has been selected,
and you see that both the parent's mesh *and* all of the children's meshes are now highlighted.

.. _fig-meta-ball-scale:

.. figure:: /images/modeling_metas_editing_base-example-scale.png
   :align: center
   :width: 450px

   Scaling the "base".

The *base* meta object controls the *polygonalization* (mesh structure) for the group, and
as such, also controls the polygonalization for the children (non-base) metas.
If we transform the *base* meta, the children's polygonalization changes.
However, if we transform the children, the polygonalization remains unchanged.

.. hint::

   This discussion of "polygonalization" does *not* mean that the various meshes do not deform
   towards or away from each other (meta objects always influence one another in the usual way,
   within a same family).

   Rather, it means that the underlying mesh structure changes only when the *base* object transforms.
   For example, if you scale the *base*, the children's mesh structure changes.

   In Fig. :ref:`fig-meta-ball-scale`, the *base* has been scaled down,
   which has the effect of scaling the mesh structure of each of the children. As you can see,
   the children's mesh resolution has increased, while the *base* decreased.
   The children did *not* change size!


## Index

.. _modeling-metas-index:
.. _bpy.types.MetaBall:
.. _bpy.ops.mball:

############
  Metaball
############

.. toctree::
   :maxdepth: 2

   introduction.rst
   toolbar/index.rst
   structure.rst
   primitives.rst
   editing.rst
   properties.rst


## Introduction


************
Introduction
************

Metaball objects (short meta) are *implicit surfaces*,
meaning that they are *not explicitly* defined by vertices (as meshes are)
or control points (as surfaces are): they exist *procedurally*.
Meta objects are literally mathematical formulas that are calculated on-the-fly by Blender.

A very distinct visual characteristic of metas is that they are fluid *mercurial*,
or *clay-like* forms that have a "rounded" shape. Furthermore,
when two meta objects get close to one another, they begin to interact with one another.
They "blend" or "merge", as water droplets do, especially in zero-g (which, by the way,
makes them very handy for modeling streams of water when you do not want to do a fluid simulation).
If they subsequently move away from one another, they restore their original shape.

Each of these is defined by its own underlying mathematical :doc:`structure </modeling/metas/structure>`,
and you can at any time switch between them using the *Active Element* panel.

Typically *Meta* objects are used for special effects or as a basis for modeling.
For example, you could use a collection of metas to form the initial shape of your model and
then convert it to a mesh for further modeling or sculpting. Meta objects are also very efficient for ray tracing.

.. warning::

   Names of *Meta* objects are very important, as they define :ref:`families <meta-ball-object-families>`,
   and only objects within a same family interact with each other.
   Unlike other object types, even edition (transformations) in Object Mode will affect the generated geometry
   within the edited families.


Visualization
=============

In Object Mode, the calculated mesh is shown, along with a black "selection ring".

.. _fig-meta-ball-example:

.. figure:: /images/modeling_metas_introduction_influence-selection.png
   :width: 450px

   Meta Ball in Edit Mode.

In Edit Mode (Fig. :ref:`fig-meta-ball-example`), a meta is displayed as a mesh
(either shaded or as black wireframe, but without any vertex of course),
with two colored circles: a red one for selection (pink when selected),
and a green one for a direct control of the meta's stiffness (light green when active).
Note that except for the :ref:`scale transformation <bpy.ops.transform.resize>`,
having the green circle highlighted is equivalent to having the red one.


## Primitives


**********
Primitives
**********

.. reference::

   :Mode:      Object Mode and Edit Mode
   :Menu:      :menuselection:`Add --> Metaball`
   :Shortcut:  :kbd:`Shift-A`

There are five predefined metaball "primitives" (or configurations)
available in the :menuselection:`Add --> Metaball` submenu:

.. figure:: /images/modeling_metas_primitives_all-five.png
   :width: 620px

   The five Metaball primitives.


Options
=======

Primitive
   Ball
      Adds a meta with a point underlying structure.
   Capsule
      Adds a meta with a line segment underlying structure.
   Plane
      Adds a meta with a planar underlying structure.
   Ellipsoid
      Adds a meta with an ellipsoidal underlying structure.
   Cube
      Adds a meta with a volumetric cubic underlying structure.

   .. seealso::

      A more detailed explanation of each primitive in the :doc:`Structure </modeling/metas/structure>` page.

Radius, Align to View, Location, Rotation
   See :ref:`Common Object Options <object-common-options>`.


## Properties


**********
Properties
**********

All meta objects of a same :ref:`family <meta-ball-object-families>` in a scene interact with each other.
The settings in the *Metaball* section apply to all meta objects of the active family. In Edit Mode,
the *Active Element* panel is shown for :ref:`editing <meta-ball-editing>` individual metaball elements.


Metaball
========

.. reference::

   :Mode:      Object and Edit Mode
   :Panel:     :menuselection:`Properties --> Metaball --> Metaball`

.. figure:: /images/modeling_metas_properties_metaball-panel.png

   Family meta properties.

Resolution Viewport
   Controls the resolution of the resultant mesh as generated by the *Meta* objects.
   The 3D Viewport resolution of the generated mesh; finest to coarsest.
Render
   The rendered resolution of the generated mesh; finest to coarsest.

.. tip::

   One way to see the underlying mathematical structure is to lower the *Resolution*,
   increase the *Threshold* and set the *Stiffness* (see below)
   a fraction above the *Threshold*. Fig. :ref:`fig-meta-intro-underlying` is a meta cube
   with the above mentioned configuration applied as follows:
   *Resolution* of 0.410, *Threshold* of 5.0 and *Stiffness* a fraction above at 5.01.

   .. list-table::

      * - .. _fig-meta-intro-underlying:

          .. figure:: /images/modeling_metas_properties_underlying-structure.png

             Underlying structure.

        - .. figure:: /images/modeling_metas_properties_underlying-structure-shape.png

             Meta cube shape.

   You can clearly see the underlying cubic structure that gives the meta cube its shape.

Influence Threshold
   Defines how much a meta's surface "influences" other metas.
   It controls the *field level* at which the surface is computed.
   The setting is global to a group of *Meta* objects.
   As the threshold increases, so does the influence that each meta has on each other.

   There are two types of :ref:`influence <meta-ball-editing-negative-influence>`: *positive* or *negative*.

Update on Edit
   While transforming metas (move, scale, etc.), you have four "modes" of visualization.

   This should help you if you experience difficulties (metas are quite computationally intensive...),
   but with modern computers, this should not happen, unless you use many metas,
   or very high resolutions...

   :Always:
      Fully display the meta during transformations.
   :Half:
      During transformations, display the meta at half its *Viewport* resolution.
   :Fast:
      Do not display meta during transformations.
   :Never:
      Never show meta mesh (not a very recommended option, as the meta is only visible at render time!).


Active Element
==============

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Properties --> Metaball --> Active Element`

.. figure:: /images/modeling_metas_properties_active-element-panel.png
   :align: right

   Active Element panel.

These settings apply only to the selected metaball element.

Type
   Changes the :doc:`primitive shape </modeling/metas/primitives>` of the meta object.

Stiffness
   Controls the influence range for individual metaball elements, unlike *Influence Threshold*
   which controls the influence for the entire :ref:`meta family <meta-ball-object-families>`.
   This essentially defines how sensitive a meta is to being affected by other metas.
   With a low stiffness, the meta will begin to deform from further away.
   A higher value means the meta needs to be close to another one to begin merging.
   The *Stiffness* is visualized by the *green ring* and can be selected and :ref:`scaled <bpy.ops.transform.resize>`
   to also change the *Stiffness* value.

   To be visible, the *Stiffness* must be slightly larger than the *Threshold* value.

   .. _fig-meta-edit-stiffness:

   .. figure:: /images/modeling_metas_editing_stiffness.png
      :align: center
      :width: 450px

      The left meta ball, has a smaller *Stiffness* value than the right one.

Radius
   Controls the physical size of the metaball.
   This works the same as scaling the metaball in Object Mode.
   The *Radius* is visualized by the *white ring* and can be selected and :ref:`scaled <bpy.ops.transform.resize>`
   to also change the *Radius* value.

.. _meta-ball-editing-negative-influence:

Negative
   Controls whether the influence is *positive* or *negative*.

   A *positive* influence is defined as an attraction,
   meaning that the meshes will stretch towards each other as the *rings of influence* intersect.
   The opposite effect would be a *negative* influence where the objects repel each other.

   .. note::

      If a metaball has *Negative* influence the meta is not visible in the 3D Viewport,
      only the surrounding circles are shown.

   .. list-table::

      * - .. figure:: /images/modeling_metas_editing_family.png

             Positive influence of three metaballs.

        - .. figure:: /images/modeling_metas_editing_negative-influence.png

             Negative influence of a meta ball;
             the first is negative and the second positive.

.. _bpy.ops.mball.hide_metaelems:
.. _bpy.ops.mball.reveal_metaelems:

Hide
   As in :ref:`object-show-hide` in Object Mode, you can hide the selected meta(s),
   and then reveal what was hidden. This is very handy for cleaning your views up a bit.

   .. note::

      - Hiding a meta does not *only* hide it, but also disables it from the meta computation,
        which will affect the final geometry.

      - The two red and green rings always remain visible in Edit Mode,
        as well as the select circle in Object Mode.


## Structure


*********
Structure
*********

Technical Details
=================

A more formal definition of a meta object can be given as a *directing structure* which can
be seen as the source of a static field. The field can be either positive or negative and
hence the field generated by neighboring directing structures can attract or repel.

The implicit surface is defined as the surface where the 3D field generated by
all the directing structures assume a given value. For example a meta ball,
whose directing structure is a point, generates
an isotropic (i.e. identical in all directions) field around it and
the surfaces at constant field value are spheres centered at the directing point.

*Meta* objects are nothing more than mathematical formula that perform logical operations on one another
(AND, OR), and that can be added and subtracted from each other.
This method is also called *Constructive Solid Geometry* (CSG).
Because of its mathematical nature, CSG uses little memory, but requires lots of processing power to compute.

.. seealso::

   The Wikipedia page about `metaballs <https://en.wikipedia.org/wiki/Metaballs>`__.


Type
====

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Sidebar region --> Transform panel --> Type`,
               :menuselection:`Metaball tab --> Active Element panel --> Type`

Blender has five types of metas, each determined by its underlying (or directing) structure.

In Edit Mode, you can change this structure,
either using the relevant buttons in the *Active Element* panel,
or the selector in the *Transform* panel in the Sidebar region.
Depending on the structure, you might have additional parameters,
located in both *Transform* panel and *Active Element* panel.

Ball (point, zero-dimensional structure)
   This is the simplest meta, without any additional setting. As it is just a point,
   it generates an isotropic field, yielding a spherical surface
   (this is why it is called *Meta Ball* or *Ball* in Blender).

Capsule (straight line, one-dimensional structure)
   This is a meta which surface is generated by the field produced by a straight line of a given length.
   This gives a cylindrical surface, with rounded closed ends.

   Size X
      The length of the line (and hence, of the capsule).

Plane (rectangular plane, two-dimensional structure)
   This is a meta which surface is generated by the field produced by a rectangular plane.
   This gives a parallelepipedal surface, with a fixed thickness, and rounded borders.

   Size X/Y
      The length and width of the rectangle.

Ellipsoid (ellipsoidal volume, three-dimensional structure)
   This is a meta which surface is generated by the field produced by an ellipsoidal volume.
   This gives an ellipsoidal surface.

   Size X/Y/Z
      The length, width and height of the ellipsoid.

Cube (parallelepipedal volume, three-dimensional structure)
   This is a meta which surface is generated by the field produced by a parallelepipedal volume.
   This gives a parallelepipedal surface, with rounded edges.

   Size X/Y/Z
      The length, width and height of the parallelepiped.


## Index

.. _meta-toolbar-index:

*******
Toolbar
*******

Metaball Edit Mode tools:

:ref:`Tweak <tool-select-tweak>`
   Select or move.

   :ref:`Select Box <tool-select-box>`
      Select objects by dragging a box.
      All objects that intersect the box will be selected.
   :ref:`Select Circle <tool-select-circle>`
      Select objects by dragging a circle. All objects that intersect the path of
      the circle will be selected.
   :ref:`Select Lasso <tool-select-lasso>`
      Select objects by drawing a lasso.

Cursor
   Change the location of the 3D Cursor.

Move
   Translation tool.

Rotate
   Rotation tool.

Scale
   Scale tool.

   :ref:`Scale Cage <tool-scale-cage>`
      Change the scale of an object by controlling its cage.

Transform
   Tool to adjust the objects translation, rotations and scale.

:ref:`Annotate <tool-annotate-freehand>`
   Draw free-hand annotation.

   :ref:`Annotate Line <tool-annotate-line>`
      Draw straight line annotation.
   :ref:`Annotate Polygon <tool-annotate-polygon>`
      Draw a polygon annotation.
   :ref:`Annotate Eraser <tool-annotate-eraser>`
      Erase previous drawn annotations.

:ref:`Measure <tool-measure>`
   Measure distances in the scene.

Shear
   Shear selected items along a defined axis.


## Common Options


***********************
Common Modifier Options
***********************

Some options are commonly used by many modifiers, and share the same behavior across all of those.
In particular, many offer ways to precisely mask and weight their effect on a vertex basis
(using either vertex groups and/or textures).


.. _modifiers-common-options-masking:

Vertex Group
============

.. figure:: /images/modeling_modifiers_common-options_vertex-group.png
   :align: right

   Typical modifier Vertex Group options.

:doc:`Vertex Groups </modeling/meshes/properties/vertex_groups/introduction>` are an easy way to control
which vertices are affected by a modifier, and to which extent (using their weights).
They are available when modifying meshes or lattices.

.. tip::

   Vertex groups can also be edited and even animated using
   the :ref:`Vertex Weight modifiers <bpy.types.VertexWeightEditModifier>`.

Vertex Group
   The vertex group name.

   .. warning::

      The group is referenced by its name. That means that if you rename it, the link to the renamed vertex group
      will be lost by all modifiers using it (their field will turn red),
      and you'll have to select the proper group again in all of them.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.
      Only available in some modifiers.


Texture
=======

.. figure:: /images/modeling_modifiers_common-options_texture.png
   :align: right

   Typical modifier Texture options.

Those options allow to use any kind of image (including parametric ones) to control the modifier's effect.
Most of the time, only the value (grayscale) of the texture is used,
but in some cases (like with some modes of the :ref:`Displace modifier <bpy.types.DisplaceModifier>`),
the whole RGB color components might be exploited.

.. tip::

   Textures can be animated (either using videos, or by animating the mapping coordinates...).

Texture
   The :doc:`texture data-block </render/materials/legacy_textures/introduction>` to use.

   .. tip::

      By clicking on the right-most button of this field (with the settings icon),
      you can go directly to the selected texture's settings in the *Texture Properties* tab.

Texture Coordinates
   The texture's coordinates to get each vertex' value:

   UV
      Take texture coordinates from face UV coordinates.

      UV Map
         The :term:`UV Map` from which to take texture coordinates. If the object has no
         UV coordinates, it falls back to the *Local* coordinate system. If this field is blank,
         but there is a UV map available (e.g. just after adding the first UV map to the mesh),
         the currently active UV map will be used.

      .. note::

         Since UV coordinates are specified per face, the UV texture coordinate system currently determines the UV
         coordinate for each vertex from the first face encountered which uses that vertex.
         Any other faces using that vertex are ignored.

         This may lead to artifacts if the mesh has non-contiguous UV coordinates.

   Object
      Take the texture coordinates from another object's coordinate system.

      Object
         The object from which to take texture coordinates.
         Moving the object will therefore alter the coordinates of the texture mapping.

         If this field is blank, it falls back to the *Local* coordinate system.

      .. note::

         Moving the original object will **also** result in a texture coordinate update.
         As such, if you need to maintain a displacement coordinate system while moving the modified object,
         consider :ref:`parenting <bpy.ops.object.parent_set>` the coordinate object to the modified object.

   Global
      Take the texture coordinates from the global coordinate system.
   Local
      Take the texture coordinates from the object's local coordinate system.

Use Channel
   Which channel to use as value source
   (only available with a few modifiers currently, others follow the *Intensity* behavior,
   unless otherwise specified).

   Intensity
      The average of the RGB channels (if RGB(1.0, 0.0, 0.0) value is 0.33).
   Red/Green/Blue/Alpha
      One of the color channels' values.
   Hue
      The hue from the HSV color model
      (i.e; the color in the standard wheel, e.g. blue has a higher hue value than yellow).
   Saturation
      The saturation from the HSV color model (e.g. the value for pure red is 1.0, for gray is 0.0).
   Value
      The value from the HSV color model.

   .. note::

      All of the channels above are gamma corrected, except for *Intensity*.


## Index

.. _bpy.types.Modifier:

#############
  Modifiers
#############

.. toctree::
   :maxdepth: 2

   introduction.rst
   common_options.rst


Built-In Modifiers
==================

.. toctree::
   :maxdepth: 2

   modify/index.rst
   generate/index.rst
   deform/index.rst
   physics/index.rst


## Introduction

.. index:: Modifiers; Modeling Modifiers
.. index:: Modeling Modifiers

************
Introduction
************

Modifiers are automatic operations that affect an object's geometry in a non-destructive way.
With modifiers, you can perform many effects automatically that would otherwise be too tedious to do manually
(such as subdivision surfaces) and without affecting the base geometry of your object.

They work by changing how an object is displayed and rendered, but not the geometry which you can edit directly.
You can add several modifiers to a single object to form `The Modifier Stack`_
and *Apply* a modifier if you wish to make its changes permanent.

They can be added to the active object using the :ref:`bpy.ops.object.modifier_add` operator,
the "Add Modifier" button at the top of Modifiers tab in the :doc:`/editors/properties_editor`,
or using :kbd:`Shift-A` in the same tab.
New modifiers are always added at the bottom of the :ref:`stack <modifier-stack>` (i.e. will be applied last).

There are many built-in modifiers but Blender also allows users
to make their own modifiers through :doc:`/modeling/geometry_nodes/index`.


Categories
==========

There are four categories of built-in modifiers:

Edit
   Similar to the *Deform*  modifiers (see below),
   however, they usually do not directly affect the geometry of the object,
   but some other data, such as vertex groups.
Generate
   Constructive/destructive modifiers that will affect the whole :term:`Topology` of the mesh.
   They can change the general appearance of the object, or add new geometry to it...
Deform
   Unlike *Generate* ones above, these modifiers only change the shape of an object, without altering its topology.
Simulate
   Represent :doc:`physics simulations </physics/index>`. In most cases, they are automatically added to
   the modifiers stack whenever a *Particle System* or *Physics* simulation is enabled. Their only role is to define
   the position in the modifier stack from which is taken the base data for the simulation they represent.
   As such, they typically have no properties, and are controlled by settings exposed in
   separate sections of the :doc:`/editors/properties_editor`.

You will also notice a category called "Hair",
this category comes from a bundled :term:`Asset Library` that is distributed with Blender.
See :doc:`/modeling/geometry_nodes/hair/index` for more information.

Users can make their own categories by making geometry node groups :term:`assets <Asset>`
and assigning them to a :term:`Asset Catalog`. This catalog name will be the category name.
If a user creates a catalog with the same name as one of the built-in categories
the node group will be added to the bottom of the corresponding menu.

Node Groups that are non-assets or that do not belong to a category will be available in the "Unassigned" sub-menu.

.. note::

   Geometry Node Groups must have the :ref:`Modifier <bpy.types.GeometryNodeTree.is_modifier>`
   property enabled for the node group to show up in the Add Modifier menu.


.. _bpy.types.Modifier.show:

Interface
=========

Each modifier's interface shares the same basic components, see Fig. :ref:`fig-modifiers-panel-layout`.

.. _fig-modifiers-panel-layout:

.. figure:: /images/modeling_modifiers_introduction_panel-layout.png
   :align: center

   Panel layout (Subdivision Surface as an example).

At the top is the panel header.
The icons each represent different settings for the modifier (left to right):

Expand (down/right arrow icon)
   Collapse modifier to show only the header and not its options.

Type
   An icon as a quick visual reference of the modifier's type.

.. _bpy.types.Modifier.name:

Name
   Every modifier has a unique name per object. Two modifiers on one object must have unique names,
   but two modifiers on different objects can have the same name. The default name is based on the modifier type.

.. _bpy.types.Modifier.show_on_cage:

Show on Cage (vertices triangle icon) -- Meshes only
   Depends on the previous setting, if enabled, the modified geometry can also be edited directly,
   instead of the original one.

   .. warning::

      While it shows edited items in their final, modified positions, you are still actually editing original data.
      This can lead to strong and unpredictable effects with some tools,
      and should be disabled whenever you need to perform complex or precise editing on the mesh.

.. _bpy.types.Modifier.show_in_editmode:

Show in Edit Mode (vertices square icon)
   Display the modified geometry in Edit Mode, as well as the original geometry which you can edit.

.. _bpy.types.Modifier.show_viewport:

Show in Viewport (screen icon)
   Toggle visibility of the modifier's effect in the 3D Viewport.

.. _bpy.types.Modifier.show_render:

Render (camera icon)
   Toggle visibility of the modifier's effect in the render.

   .. note::

      The *Square*, *Triangle* and *Surface* icons may not be available,
      depending on the type of object and modifier.

.. _bpy.types.Modifier.use_apply_on_spline:

Apply On Spline Points (point surface icon) -- Curves, surfaces and texts only
   Apply the whole modifier stack up to and including that one on the curve or surface control points,
   instead of their tessellated geometry.

   .. note::

      By default, curves, texts and surfaces are always converted to mesh-like geometry
      before that the modifier stack is evaluated on them.

.. _bpy.ops.object.modifier_apply:

Extras
   Apply :kbd:`Ctrl-A`
      Makes the modifier "real": converts the object's geometry to match the applied modifier's results,
      and deletes the modifier.

      When applying a modifier to an object that shares Object Data between multiple objects,
      the object must first be made a :ref:`Single User <data-system-datablock-make-single-user>`
      which can be performed by confirming the pop-up message.

      .. warning::

         Applying a modifier that is not first in the stack will ignore the stack order
         (it will be applied as if it was the first one), and may produce undesired results.

   .. _bpy.ops.object.modifier_apply_as_shapekey:

   Apply as Shape Key
      Stores the result of that modifier in a new relative :doc:`shape key </animation/shape_keys/introduction>`
      and then deletes the modifier from the modifier stack.
      This is only available with modifiers that do not affect the topology (typically, *Deform* modifiers only).

      .. note::

         Even though it should work with any geometry type that supports shape keys,
         currently it will only work with meshes.

   Save as Shape Key
      Stores the result of that modifier in a new relative :doc:`shape key </animation/shape_keys/introduction>`
      and keeps the modifier in the modifier stack.
      This is only available with modifiers that do not affect the topology (typically, *Deform* modifiers only).

   .. _bpy.ops.object.modifier_copy:

   Duplicate :kbd:`Shift-D`
      Creates a duplicate of the modifier just below current one in the stack.

   .. _bpy.ops.object.modifier_copy_to_selected:

   Copy to Selected
      Copies the modifier from the :term:`Active` object to all selected objects.

   .. _bpy.ops.object.modifier_move_to_index:

   Move to First/Last
      Moves the modifier to the first or last position in the modifier stack.
   Move to Nodes
      Converts the existing :doc:`/modeling/modifiers/generate/geometry_nodes`
      node tree to a group node to be reused in other node trees.
      See :ref:`bpy.ops.object.geometry_nodes_move_to_nodes` for more information.

      This operator is only available for the Geometry Nodes Modifier.

.. _bpy.ops.object.modifier_remove:

Delete :kbd:`X`, :kbd:`Delete`
   Delete the modifier.

Move ``::::``
   Move the modifier up/down in the :ref:`stack <modifier-stack>`,
   changing the evaluation order of the modifiers.

Below this header, all of the options unique to each modifier will be displayed.


.. _modifier-stack:

The Modifier Stack
------------------

Modifiers are a series of non-destructive operations which can be applied on top of an object's geometry.
You can be apply them in almost any order.
This kind of functionality is often referred to as a "modifier stack"
and is also found in several other 3D applications.

In a modifier stack, the order in which modifiers are applied has an effect on the result.
Therefore the modifiers can be re-arranged by clicking the grab widget (``::::``) in the top right,
and moving the selected modifier up or down.
For example, the image below shows :doc:`Subdivision Surface </modeling/modifiers/generate/subdivision_surface>`
and :doc:`Mirror </modeling/modifiers/generate/mirror>` modifiers that have switched places.

.. list-table:: Modifier Stack example.

   * - .. figure:: /images/modeling_modifiers_introduction_mirror-subdiv2.png
          :width: 320px

          The Mirror modifier is the last item in the stack and
          the result looks like two surfaces.

     - .. figure:: /images/modeling_modifiers_introduction_mirror-subdiv1.png
          :width: 320px

          The Subdivision Surface modifier is the last
          item in the stack and the result is a single merged surface.

Modifiers are calculated from top to bottom in the stack.
In this example, the desired result (on right) is achieved by first mirroring the object,
and then calculating the subdivision surface.


.. _modifier-stack-active:

Active Modifier
^^^^^^^^^^^^^^^

A modifier in the stack can be selected to mark in as :term:`Active`,
the active modifier displays an outline around the modifier's panel.
To set an active modifier, select an area of the modifier's panel background,
the modifier's icon, or, select a modifier in the :doc:`/editors/outliner/index`.

The active modifier is used by the :doc:`/editors/geometry_node`
to determine which node group is being modified.


Example
=======

.. figure:: /images/modeling_modifiers_introduction_stack-example-3.png

   In this example a simple subdivided cube has been transformed into a rather complex object using
   a stack of modifiers.

`Download example file <https://archive.blender.org/wiki/2015/index.php/File:25-Manual-Modifiers-example.blend>`__.


## Armature

.. index:: Modeling Modifiers; Armature Modifier
.. _bpy.types.ArmatureModifier:

*****************
Armature Modifier
*****************

The *Armature* modifier is used for building skeletal systems (rigs) for animating
the poses of characters and anything else which needs to be posed.

By adding an armature system to an object,
that object can be deformed accurately so that geometry does not have to be animated by hand.

.. seealso::

   For more details on armatures usage, see the :doc:`armature section </animation/armatures/index>`.


Options
=======

.. figure:: /images/modeling_modifiers_deform_armature_panel.png
   :align: right
   :width: 300px

   The Armature modifier.

Object
   The name of the armature object used by this modifier.

Vertex Group
   A vertex group of the object, which weights will be used to determine the influence of this
   modifier's results when mixing it with the results from other *Armature* ones.

   Only meaningful when having at least two of these modifiers on the same object,
   with *Multi Modifier* activated.

   Invert ``<->``
      Inverts the influence set by the vertex group defined in previous setting
      (i.e. reverses the weight values of this group).

Preserve Volume
   Use quaternions for preserving volume of object during deformation. It can be better in many situations.

   Without it, rotations at joints tend to scale down the neighboring geometry,
   up to nearly zero at 180 degrees from rest position.
   With it, the geometry is no longer scaled down, but there is a "gap",
   a discontinuity when reaching 180 degrees from rest position.

.. list-table:: Example of *Preserve Volume* effects.
   Note that the icosphere is deformed using the envelopes weights.

   * - .. figure:: /images/modeling_modifiers_deform_armature_preserve-volume-1.png
          :width: 200px

          Initial state.

     - .. figure:: /images/modeling_modifiers_deform_armature_preserve-volume-2.png
          :width: 200px

          100° rotation, *Preserve Volume* disabled.

     - .. figure:: /images/modeling_modifiers_deform_armature_preserve-volume-3.png
          :width: 200px

          180° rotation, *Preserve Volume* disabled.

   * - .. figure:: /images/modeling_modifiers_deform_armature_preserve-volume-4.png
          :width: 200px

          100° rotation, *Preserve Volume* enabled.

     - .. figure:: /images/modeling_modifiers_deform_armature_preserve-volume-5.png
          :width: 200px

          179.9° rotation, *Preserve Volume* enabled.

     - .. figure:: /images/modeling_modifiers_deform_armature_preserve-volume-6.png
          :width: 200px

          180.1° rotation, *Preserve Volume* enabled.

Multi Modifier
   Use the same data as a previous modifier (usually also an *Armature* one) as input.
   This allows you to use several armatures to deform the same object, all based on the "non-deformed" data
   (i.e. this avoids having the second *Armature* modifier deform the result of the first one...).

   The results of the *Armature* modifiers are then mixed together, using the weights of
   the *Vertex Group* as "mixing guides".

   .. tip::

      *Armature* modifiers can quickly be added to objects by :ref:`parenting <bpy.ops.object.parent_set>`
      them to an armature.

Bind to
   Methods to bind the armature to the mesh.

   Vertex Groups
      Meshes and lattices only. When enabled, bones of a given name will deform vertices which belong to
      :doc:`vertex groups </modeling/meshes/properties/vertex_groups/index>` of the same name.
      E.g. a bone named "forearm", will only affect the vertices in the "forearm" vertex group.

      The influence of one bone on a given vertex is controlled by the weight of this vertex in the relevant group.
      A much more precise method than *Bone Envelopes*, but also generally longer to set up.

   Bone Envelopes
      When enabled, bones will deform vertices or control points near them,
      defined by each bone's envelope radius and distance.
      This lets :ref:`bone envelopes <armature-bones-envelope>` control the deformation
      (i.e. bones deform vertices in their neighborhood).

      .. list-table:: Example of skinning methods.

         * - .. figure:: /images/modeling_modifiers_deform_armature_vertex-groups-skinning-1.png
                :width: 320px

                The weights of the "arm" vertex group.

           - .. figure:: /images/modeling_modifiers_deform_armature_vertex-groups-skinning-2.png
                :width: 320px

                The weights of the "forearm" vertex group.

         * - .. figure:: /images/modeling_modifiers_deform_armature_vertex-groups-skinning-3.png
                :width: 320px

                The result when posing the armature.

           - .. figure:: /images/modeling_modifiers_deform_armature_vertex-groups-skinning-4.png
                :width: 320px

                The same pose, but using envelopes method rather that vertex groups.

      .. tip::

         When envelopes are disabled, Blender uses the set of existing vertex group names to
         determine which bones are actually necessary to evaluate the modifier.
         Removing empty vertex groups helps to reduce dependencies, and can be essential
         if the mesh is used during evaluation of other bones in the same armature,
         e.g. as the target of a :doc:`Shrinkwrap </animation/constraints/relationship/shrinkwrap>` constraint.


## Cast

.. index:: Modeling Modifiers; Cast Modifier
.. _bpy.types.CastModifier:

*************
Cast Modifier
*************

The *Cast* modifier shifts the shape of a mesh, curve,
surface or lattice, towards any of a few predefined shapes (sphere, cylinder, cuboid).

It is equivalent to the :ref:`To Sphere <tool-transform-to_sphere>` tool in Edit Mode,
and what other programs call "Spherify" or "Spherize", but, as written above,
it is not limited to casting to a sphere.

.. tip::

   The :doc:`Smooth Modifier </modeling/modifiers/deform/smooth>` is a good companion to *Cast*,
   since the cast shape sometimes needs smoothing to look nicer or even to fix shading artifacts.

.. note::

   For performance reasons, this modifier only works with local coordinates.
   If the modified object looks wrong, you may need to apply its
   :ref:`transformations <bpy.ops.object.transform_apply>`, especially when casting to a cylinder.


Options
=======

.. figure:: /images/modeling_modifiers_deform_cast_panel.png
   :align: right
   :width: 300px

   The Cast modifier.

Shape
   Menu to choose target shape of the projection: *Sphere*, *Cylinder* or *Cuboid*.

Axis
   Toggle buttons to enable/disable the modifier in the X, Y, Z axes directions
   (X and Y only for *Cylinder* cast type, since the Z axis remains unaffected).

Factor
   The factor to control blending between original and cast vertex positions.

   It is a linear interpolation: 0.0 gives original coordinates (i.e. modifier has no effect),
   1.0 casts to the target shape.

   Values below 0.0 or above 1.0 exaggerate the deformation, sometimes in interesting ways.

Radius
   If nonzero, this radius defines a sphere of influence.
   Vertices outside it are not affected by the modifier.

Size
   Alternative size for the projected shape. If zero,
   it is defined by the initial shape and the control object, if any.

Size from Radius
   If activated, calculate *Size* from *Radius*, for smoother results.

Vertex Group
   If set, restrict the effect to the only vertices in that vertex group.
   This allows selective, real-time casting, by painting vertex weights.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.

Object
   The name of an object to control the effect.
   The location of this object's origin defines the center of the projection.
   Also, its size and rotation transform the projected vertices.

   .. hint::

      Animating (keyframing) this control object also animates the modified object's casting deformation.


Example
=======

.. figure:: /images/modeling_modifiers_deform_cast_example.jpg
   :width: 400px

   Top: Suzanne without modifiers. Middle: Suzanne with each type of Cast Modifier (Sphere, Cylinder and Cuboid).
   Bottom: Same as above, but now only X axis is enabled.
   `Sample blend-file <https://archive.blender.org/wiki/2015/index.php/File:263-Cast-Modifier.blend>`__.


## Corrective Smooth

.. index:: Modeling Modifiers; Smooth Corrective Modifier
.. _bpy.types.CorrectiveSmoothModifier:

**************************
Smooth Corrective Modifier
**************************

The *Smooth Corrective* modifier is used to reduce highly distorted areas of a mesh by smoothing the deformations.

This is typically useful *after* an :doc:`Armature modifier </modeling/modifiers/deform/armature>`,
where distortion around joints may be hard to avoid, even with careful weight painting.

To use this modifier effectively, it is important to understand the basics of how it works.

Rest State
   Used as a reference to detect highly distorted areas.
   The original vertex locations are used by default.
Smoothing
   Many options for this modifier relate to smoothing which is used internally
   to correct the distorted regions.


Options
=======

.. figure:: /images/modeling_modifiers_deform_corrective-smooth_panel.png
   :align: right
   :width: 300px

   The Smooth Corrective modifier.

Factor
   The factor to control the smoothing amount.
   Higher values will increase the effect.

   Values outside expected range (above 1.0 or below 0.0) will distort the mesh.

Repeat
   The number of smoothing iterations,
   equivalent to executing the *Smooth* tool multiple times.

Scale
   Additional scaling factor to increase the size of the mesh.
   This is useful because sometimes the Smooth Corrective modifier
   will introduce volume loss, especially when used with a rig.

Smooth Type
   Select the smoothing method used.

   Simple
      This simply relaxes vertices to their connected edges.
   Length Weight
      Uses a method of relaxing that weights by the distance of surrounding vertices.
      This option can give higher quality smoothing in some cases,
      by better preserving the shape of the original form.

Vertex Group
   If set, restrict the effect to the only vertices in that vertex group.
   This allows for selective, real-time smoothing, by painting vertex weights.

Only Smooth
   This option is included to preview the smoothing used, before correction is applied.

Pin Boundaries
   Prevent boundary vertices from smoothing.

Rest Source
   Select the source for reference vertex positions that defines the undeformed state.

   Original Coordinates
      Use the original input vertex positions.
      This relies on the original mesh having the same number of vertices as the input, modified mesh.
   Bind Coordinates
      Optionally you may bind the modifier to a specific state.
      This is required when there are constructive modifiers such as *Subdivision Surface* or *Mirror*
      in the stack before this modifier.


Example
=======

.. list-table:: An example of a rig using bone envelopes and not weight painting.

   * - .. figure:: /images/modeling_modifiers_deform_corrective-smooth_example-pose-before.png
          :width: 350px

          Armature only.

     - .. figure:: /images/modeling_modifiers_deform_corrective-smooth_example-pose-after.png
          :width: 350px

          Armature and Corrective Smooth.


## Curve

.. index:: Modeling Modifiers; Curve Modifier
.. _bpy.types.CurveModifier:

**************
Curve Modifier
**************

The *Curve* modifier provides a simple but efficient method of deforming a mesh along a curve object.

It works on a (global) dominant axis, X, Y, or Z.
This means that when you move your mesh in the dominant direction (by default, the X axis),
the mesh will traverse along the curve, as if it was a train following and deforming along rails.
Moving the mesh perpendicularly to this axis, the object will move closer or further away from the curve.

When you move the object beyond the curve's ends, the object will continue
to deform based on the direction vector at those ends.

.. note::

   This modifier works in global space, in other words, the actual position of the geometry
   relative to the curve is determinant to get a correct result.

   Typically, you'll want your object's origin to be at the center of your geometry (not offset far away from it,
   you can e.g. :ref:`Set Origin to Geometry <bpy.ops.object.origin_set>`).

   And then you'll want to start with your object's origin at the same location as your curve object's origin
   (you may use :ref:`snap tools <bpy.ops.view3d.snap>` for that...).

If the curve is 3D, the *Tilt* value of its control points will be used to twist the deformed object.
And the *Radius* property controls the size of the object as well.
Those options are in the *Shape* panel, under :ref:`Path/Curve-Deform <curve-shape-path-curve-deform>`.


Options
=======

.. _fig-modifier-curve-panel:

.. figure:: /images/modeling_modifiers_deform_curve_panel.png
   :align: right
   :width: 300px

   The Curve modifier.

Curve Object
   The name of the curve object that will affect the deformed object.

Deformation Axis
   This is the axis that the curve deforms along.

   X/Y/Z/-X/-Y/-Z

Vertex Group
   If set, restrict the effect to the only vertices in that vertex group.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.


Example
=======

.. list-table::

   * - .. _fig-modifier-curve-edit:

       .. figure:: /images/modeling_modifiers_deform_curve_example-edit-curve.png
          :width: 300px

          Edit curve.

     - .. figure:: /images/modeling_modifiers_deform_curve_example-monkeyoncurve1.png
          :width: 300px

          Monkey on a curve.

     - .. figure:: /images/modeling_modifiers_deform_curve_example-monkeyoncurve2.png
          :width: 300px

          Monkey deformations.


## Displace

.. index:: Modeling Modifiers; Displace Modifier
.. _bpy.types.DisplaceModifier:

*****************
Displace Modifier
*****************

The *Displace* modifier displaces vertices in a mesh based on the intensity of a texture.
Either procedural or image textures can be used.

The displacement can be along a particular local axis, along the vertex normal,
or the separate RGB components of the texture can be used to displace vertices in the local X,
Y and Z directions simultaneously (sometimes referred to as *Vector Displacement*).


Options
=======

.. figure:: /images/modeling_modifiers_deform_displace_panel.png
   :align: right
   :width: 300px

   The Displace modifier.

Texture
   The name of the texture from which the displacement for each vertex is derived.
   If this field is empty, the modifier defaults to 1.0 (white).

   Coordinates
      The texture coordinate system to use when retrieving values from the texture for each vertex.

      See :ref:`common masking options <modifiers-common-options-masking>` for a complete reference.

Direction
   The direction along which to displace the vertices.
   Can be one of the following:

   X, Y, Z
      Displace along an axis.
   Normal
      Displace along the vertex normal.
   Custom Normal
      Displace along (averaged) :ref:`custom normals <modeling_meshes_normals_custom>`, instead of vertex normals.
   RGB to XYZ
      Displace along local XYZ axes individually using the RGB components of the texture
      (Red values displaced along the X axis, Green along the Y, Blue along the Z).

Space
   With a direction set to X, Y, Z, or XYZ the modifier can either displace along local or global axes.

Strength
   The strength of the displacement. After offsetting by the *Midlevel* value,
   the displacement will be multiplied by the *Strength* value to give the final vertex offset.

   :math:`vertex\_offset = displacement × Strength`

   A negative strength can be used to invert the effect of the modifier.

Midlevel
   The texture value which will be treated as no displacement by the modifier.
   Texture values below this threshold will result in negative displacement along the selected direction,
   while texture values above it will result in positive displacement.

   :math:`displacement = texture\_value - Midlevel`

   Recall that color/luminosity values are typically between (0.0 to 1.0) in Blender,
   and not between (0 to 255).

Vertex Group
   The name of a vertex group which is used to control the influence of the modifier.
   If left empty, the modifier affects all vertices equally.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.


Example
=======

.. figure:: /images/modeling_modifiers_deform_displace_example-1.jpg
   :width: 680px

   Three different objects created with the Displace modifier.
   `Sample blend-file <https://archive.blender.org/wiki/2015/uploads/9/9e/Manual-Modifier-Displace-Example01.blend>`__.

.. figure:: /images/modeling_modifiers_deform_displace_example-2.jpg
   :width: 540px

   A slime animation created with the Displace modifier.
   `Sample blend-file <https://archive.blender.org/wiki/2015/uploads/6/62/Manual-Modifier-Displace-Slime01.blend>`__.


## Hooks

.. index:: Modeling Modifiers; Hook Modifier
.. _bpy.types.HookModifier:

*************
Hook Modifier
*************

The *Hook* modifier is used to deform a mesh, curve or lattice using another object
(usually an empty or a bone but it can be any object).
As an object specified as hook moves, it pulls vertices or control points from the geometry with it.
You can think of it as animated
:doc:`Proportional Editing </editors/3dview/controls/proportional_editing>`.

While hooks do not give you the fine control over vertices movement that shape keys do,
they have the advantage that you can select vertices directly for manipulation.

To assign selected vertices (in Edit Mode) you can use the *Assign* button on the modifier panel
or use the :ref:`Add Hook <bpy.ops.object.hook_add_selob>` menu.


Options
=======

.. figure:: /images/modeling_modifiers_deform_hooks_panel.png
   :align: right
   :width: 300px

   The Hook modifier.

Object
   The name of the object to hook vertices to.

Vertex Group
   Allows you to define the influence per vertex.

   Useful when you want something other than a spherical field of influence.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.

Strength
   Adjust this hooks influence on the vertices, were (0.0 to 1.0) (no change to fully follows the hook).

   Since multiple hooks can work on the same vertices, you can weight the influence of a hook using this property.

The following settings are only available in Edit Mode:

Reset
   Recalculate and clear the offset transform of the hook.
Recenter
   Set the hook center to the 3D cursor position.

Select
   Select the vertices affected by this hook.
Assign
   Assigns selected vertices to this hook.

.. warning::

   The Hook Modifier stores vertex indices from the original mesh to determine what to affect.
   This means that modifiers that generate geometry, like *Subdivision Surface*,
   should always be put **after** the *Hook* one in the stack.
   Otherwise, the generated geometry will be left out of the hook's influence.


Falloff
-------

Type
   This can be used to adjust the kind of influence curve that the hook has on the mesh.
   You can also define a custom curve to get a much higher level of control.

Radius
   The size of the hooks influence.

Uniform Falloff
   This setting is useful when using hooks on scaled objects,
   especially in cases where non-uniform scale would stretch the result of the hook.

   This is especially useful for lattices, where it is common to use non-uniform scaling.


Example
=======

.. figure:: /images/modeling_modifiers_deform_hooks_example.png
   :width: 460px

   Empty used as Hook to deform a subdivided cube.


## Index


##########
  Deform
##########

.. toctree::
   :maxdepth: 1

   armature.rst
   cast.rst
   curve.rst
   displace.rst
   hooks.rst
   laplacian_deform.rst
   lattice.rst
   mesh_deform.rst
   shrinkwrap.rst
   simple_deform.rst
   smooth.rst
   corrective_smooth.rst
   laplacian_smooth.rst
   surface_deform.rst
   volume_displace.rst
   warp.rst
   wave.rst


## Laplacian Deform

.. index:: Modeling Modifiers; Laplacian Deform Modifier
.. _bpy.types.LaplacianDeformModifier:

*************************
Laplacian Deform Modifier
*************************

The *Laplacian Deform* modifier allows you to pose a mesh while preserving
geometric details of the surface.

The user defines a set of "anchor" vertices, and then moves some of them around.
The modifier keeps the rest of the anchor vertices in fixed positions and
calculates the optimal locations of all the remaining vertices to preserve the original geometric details.

This modifier captures the geometric details with the use of differential coordinates.
The differential coordinates capture the local geometric information, the curvature and
direction of a vertex based on its neighbors.

.. note::

   You must define an *Anchors Vertex Group*. Without it the modifier does nothing.


Options
=======

.. figure:: /images/modeling_modifiers_deform_laplacian-deform_panel.png
   :align: right
   :width: 300px

   The Laplacian Deform modifier.

Repeat
   How many iterations to do to improve the found solution.
   The objective is to find the rotation of the differential coordinates
   preserving the best possible geometric details.
   Details are retained better if more iterations are used,
   however, it will take longer to calculate.

   .. list-table:: Deform horse example
      `blend-file <https://archive.blender.org/wiki/2015/uploads/a/a2/Apinzonf_Deform_Horse_example1.blend>`__.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-deform_cactus09.png
             :width: 130px

             Original Model.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-deform_cactus-repeat1.png
             :width: 130px

             Repeat: 1.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-deform_cactus-repeat2.png
             :width: 130px

             Repeat: 2.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-deform_cactus-repeat5.png
             :width: 130px

             Repeat: 5.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-deform_horse-repeat0.jpg
             :width: 130px

             Original Model.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-deform_horse-repeat1.jpg
             :width: 130px

             Repeat: 1.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-deform_horse-repeat2.jpg
             :width: 130px

             Repeat: 2.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-deform_horse-repeat10.jpg
             :width: 130px

             Repeat: 10.

Anchor Weights
   The group of vertices that the user will use to transform the model.
   The weight of each vertex does not affect the behavior of the modifier,
   the method only takes into account vertices with weight greater than 0.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.

Bind
   The *Bind* button is what tells the *Laplacian Deform* modifier to actually capture the geometry details
   of the object, so that altering the anchor vertices actually alters the shape of the deformed object.

Unbind
   After binding the modifier, you may later decide to make changes to the *Anchors Vertex Group*.
   To do so you will first need to *Unbind* the modifier before binding it again.


Error Messages
==============

Vertex group *group_name* is not valid
   This message is displayed when a user deletes the vertex group or changes its name.
Vertices changed from X to Y
   This message is displayed when a user adds or deletes vertices to/from the mesh.
Edges changed from X to Y
   This message is displayed when a user adds or deletes edges to/from the mesh.
The system did not find a solution
   This message is displayed if the solver could not find a solution for the linear system.

.. note::

   If the mesh is dense, with a number of vertices greater than 100,000,
   then it is possible that the nonlinear optimization system will fail.


History
=======

`Laplacian Surface Editing
<https://igl.ethz.ch/projects/Laplacian-mesh-processing/Laplacian-mesh-editing/laplacian-mesh-editing.pdf>`__
is a method developed by Olga Sorkine and others in 2004.
This method preserves geometric details as much as possible while the user makes editing operations.
This method uses `differential coordinates
<https://igl.ethz.ch/projects/Laplacian-mesh-processing/Laplacian-mesh-editing/diffcoords-editing.pdf>`__
corresponding to the difference between a vector and the weighted average
of its neighbors to represent the local geometric detail of the mesh.

.. figure:: /images/modeling_modifiers_deform_laplacian-deform_diagram-differential-coordinate.png
   :width: 369px

   Differential Coordinate.

.. seealso::

   - `Laplacian Surface Editing (Original paper)
     <https://igl.ethz.ch/projects/Laplacian-mesh-processing/Laplacian-mesh-editing/laplacian-mesh-editing.pdf>`__
   - `Differential Coordinates for Interactive Mesh Editing
     <https://igl.ethz.ch/projects/Laplacian-mesh-processing/Laplacian-mesh-editing/diffcoords-editing.pdf>`__


## Laplacian Smooth

.. index:: Modeling Modifiers; Smooth Laplacian Modifier
.. _bpy.types.LaplacianSmoothModifier:

*************************
Smooth Laplacian Modifier
*************************

The *Smooth Laplacian* modifier allows you to reduce noise on a mesh's surface with minimal changes to its shape.

It can also exaggerate the shape using a negative *Factor*.

The *Smooth Laplacian* is useful for objects that have been reconstructed from
the real world and contain undesirable noise. It removes noise while still
preserving desirable geometry as well as the shape of the original model.

This modifier is based on a curvature flow *Laplace Beltrami* operator in a diffusion equation.

.. hint::

   Meshes with a great number of vertices, more than ten thousand (10,000),
   may take several minutes for processing. You can use small portions of the mesh for testing
   before executing the modifier on the entire model.


Options
=======

.. figure:: /images/modeling_modifiers_deform_laplacian-smooth_panel.png
   :align: right
   :width: 300px

   The Smooth Laplacian modifier.

Repeat
   Repetitions allow you to run the smoothing operation multiple times.
   Each repetition causes the flow curvature of the mesh to be recalculated again,
   and as a result it removes more noise with every new iteration using a small *Factor* < 1.0.

   When on 0, no smoothing is done.

   .. note::

      More repetitions will take longer to calculate.
      So beware of doing so on meshes with a large number of vertices.

   .. list-table:: With a factor of 0.5.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_repeat0.jpg
             :width: 130px

             Repeat: 0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_repeat1.jpg
             :width: 130px

             Repeat: 1.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_repeat5.jpg
             :width: 130px

             Repeat: 5.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_repeat10.jpg
             :width: 130px

             Repeat: 10.

   .. list-table:: With a factor of 2.0.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-axis.png
             :width: 130px

             Repeat: 0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-repeat1.png
             :width: 130px

             Repeat: 1.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-repeat5.png
             :width: 130px

             Repeat: 5.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-repeat10.png
             :width: 130px

             Repeat: 10.

   .. list-table:: With a factor of -0.5.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-repeat0.jpg
             :width: 130px

             Repeat: 0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-repeat1.jpg
             :width: 130px

             Repeat: 1.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-repeat5.jpg
             :width: 130px

             Repeat: 5.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-repeat10.jpg
             :width: 130px

             Repeat: 10.

Axis
   Toggle buttons to enable/disable deforming vertices in the X, Y and/or Z axes directions.

   .. list-table::

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-axis.png
             :width: 130px

             X, Y, Z: Unselected.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-axis-xyz.jpg
             :width: 130px

             X, Y, Z: Selected.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-axis-xy.jpg
             :width: 130px

             X, Z: Selected.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-axis-x.png
             :width: 130px

             X: Selected.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-axis.png
             :width: 130px

             X, Y, Z: Unselected.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-axis-xyz.jpg
             :width: 130px

             X, Y, Z: Selected.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-axis-xy.jpg
             :width: 130px

             X, Z: Selected.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-axis-x.png
             :width: 130px

             X: Selected.

Lambda Factor
   Controls the amount of displacement of every vertex along the flow curvature.

   - Using a small *Factor*, you can remove noise from the shape without affecting desirable geometry.
   - Using a large *Factor*, you get smoothed versions of the shape at the cost of fine geometry details.
   - Using a negative *Factor*, you can enhance the shape, preserving desirable geometry.
   - When the *Factor* is negative, multiple iterations can magnify the noise.

   .. list-table::

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_repeat0.jpg
             :width: 130px

             Factor: 0.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_lambda0-5.jpg
             :width: 130px

             Factor: 0.5.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_lambda.jpg
             :width: 130px

             Factor: 2.5.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_lambda5-0.jpg
             :width: 130px

             Factor: 5.0.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-lambda0-0.png
             :width: 130px

             Factor: 0.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-lambda1-0.jpg
             :width: 130px

             Factor: 1.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-lambda10-0.jpg
             :width: 130px

             Factor: 10.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-lambda50-0.jpg
             :width: 130px

             Factor: 50.0.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-repeat0.jpg
             :width: 130px

             Factor: 0.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-lambda20-0.jpg
             :width: 130px

             Factor: -20.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-lambda50-0.jpg
             :width: 130px

             Factor: -50.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-lambda300-0.jpg
             :width: 130px

             Factor: -300.0.

Lambda Border
   Since there is no way to calculate the curvature flow on border edges, they must be controlled separately.
   Border edges are smoothed using a much simpler method, using this property to control the influence.

   Positive values will smooth the vertex positions,
   while negative values will "enhance" them by transforming them in the opposite direction.

   .. list-table:: With a factor of 2.5.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_border0-0.jpg
             :width: 130px

             Border: 0.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_border1-0.jpg
             :width: 130px

             Border: 1.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_border.jpg
             :width: 130px

             Border: 2.5.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_border10-0.jpg
             :width: 130px

             Border: 10.0.

   .. list-table:: With a factor of 20.0.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-border0-0.jpg
             :width: 130px

             Border: 0.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-border1-0.jpg
             :width: 130px

             Border: 1.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-border5-0.jpg
             :width: 130px

             Border: 5.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-border20-0.jpg
             :width: 130px

             Border: 20.0.

   .. list-table:: With a factor of -30.0.

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cup-0-0.jpg
             :width: 130px

             Border: 0.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cup-20-0.jpg
             :width: 130px

             Border: -20.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cup-50-0.jpg
             :width: 130px

             Border: -50.0.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cup-200-0.jpg
             :width: 130px

             Border: -200.0.

Preserve Volume
   The smoothing process can produce shrinkage.
   That is significant for large *Factor* or large *Repeat* values.
   You can use that option to reduce that effect.

   .. list-table::

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-volume-false.png
             :width: 130px

             Off.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-volume-true.jpg
             :width: 130px

             On.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-volume2-false.jpg
             :width: 130px

             Off.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_cube-volume2-true.jpg
             :width: 130px

             On.

Normalized
   When enabled, the results will depend on face sizes. When disabled, geometry spikes may occur.

   .. list-table::

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_monkey-normalized0.jpg
             :width: 130px

             Original Geometry.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_monkey-normalized1.jpg
             :width: 130px

             On.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_monkey-normalized2.jpg
             :width: 130px

             Off.

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_monkey-normalized3.jpg
             :width: 130px

             Off, High Factor.

Vertex Group
   A vertex group name, to constrain the effect to a group of vertices only.
   Allows for selective, real-time smoothing or enhancing, by painting vertex weights.

   .. list-table::
      :header-rows: 1

      * - Original Geometry
        - No Group Chosen
        - Vertex Weights
        - Result
      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_repeat0.jpg
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_lambda.jpg
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_femme-paint.jpg
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_femme-wgroup.jpg
             :width: 130px

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-axis.png
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-axis-xyz.jpg
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-paint.jpg
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-wgroup.png
             :width: 130px

      * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-repeat0.jpg
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-vertex1.jpg
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-vertex2.jpg
             :width: 130px

        - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-vertex3.jpg
             :width: 130px

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.


Examples
========

.. list-table::

   * - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_repeat0.jpg
          :width: 200px

          Femme front view
          `blend-file <https://archive.blender.org/wiki/2015/uploads/8/8f/Apinzonf_GSOC_2012_Media_femme_front.blend>`__.

     - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_border0-0.jpg
          :width: 200px

          Femme side view
          `blend-file <https://archive.blender.org/wiki/2015/uploads/4/47/Apinzonf_GSOC_2012_Media_femme_side.blend>`__.

     - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_t-wgroup.png
          :width: 200px

          Cube smooth
          `blend-file <https://archive.blender.org/wiki/2015/uploads/5/54/Apinzonf_GSOC_2012_Media_cube_smooth.blend>`__.

     - .. figure:: /images/modeling_modifiers_deform_laplacian-smooth_camel-repeat0.jpg
          :width: 200px

          Shape enhanced
          `blend-file <https://archive.blender.org/wiki/2015/uploads/4/44/Apinzonf_Shape_Enhanced_camel.blend>`__.

.. seealso::

   :doc:`Smooth Modifier </modeling/modifiers/deform/smooth>`.


## Lattice

.. index:: Modeling Modifiers; Lattice Modifier
.. _bpy.types.LatticeModifier:

****************
Lattice Modifier
****************

The *Lattice* modifier deforms the base object according to
the shape of a :doc:`Lattice </animation/lattice>` object.
Objects to be deformed can be meshes, curves,
surfaces, text, lattices and even particles.

.. tip::

   A *Lattice* modifier can quickly be added to selected objects by
   :ref:`parenting <bpy.ops.object.parent_set>` them using the *Lattice Deform* option.


Options
=======

.. figure:: /images/modeling_modifiers_deform_lattice_panel.png
   :align: right
   :width: 300px

   The Lattice modifier.

Object
   The :doc:`Lattice </animation/lattice>` object with which to deform the base object.

Vertex Group
   An optional vertex group name which lets you limit the modifier's effect to a part of the base mesh.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.

Strength
   A factor to control blending between original and deformed vertex positions.


Hints
=====

Why would you use a lattice to deform a mesh instead of deforming the mesh itself in Edit Mode?
There are a couple of reasons for that:

- If your object has a large number of vertices, it would be difficult to edit portions of it quickly in Edit Mode.
  Using a lattice will allow you to deform large portions efficiently.
- The smooth deformation you get from a *Lattice* modifier can be hard to achieve manually.
- Multiple objects can use the same lattice, thus allowing you to edit multiple objects at once.
- Like all modifiers, it is non-destructive. Meaning all changes happen on top of the original geometry,
  which you can still go back to and edit without affecting the deformation.
- A lattice does not affect the texture coordinates of a mesh's surface.

.. note::

   When using a lattice to deform particles, order in the :ref:`modifier stack <modifier-stack>` matters.
   You need to place the *Lattice* modifier after the *Particle System* one.


## Mesh Deform

.. index:: Modeling Modifiers; Mesh Deform Modifier
.. _bpy.types.MeshDeformModifier:

********************
Mesh Deform Modifier
********************

The *Mesh Deform* modifier allows an arbitrary mesh (of any closed shape)
to act as a deformation cage around another mesh.

.. note::

   This modifier is reasonably easy to use, but it can be very slow to
   compute the binding (the mapping between the deform mesh cage to the deformed object geometry).


Options
=======

.. figure:: /images/modeling_modifiers_deform_mesh-deform_panel.png
   :align: right
   :width: 300px

   The Mesh Deform modifier.

Object
   The name of the mesh object to be used as the deforming cage.

Vertex Group
   An optional vertex group of the object's mesh to restrict the vertices that
   will be affected by this modifier.
   Vertices not in this group will not be deformed.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.

Precision
   Controls the accuracy with which the deform mesh cage alters the deformed object,
   when the points on the cage are moved.
   Raising this value higher can greatly increase the time it takes
   to complete the binding calculations,
   but it will get more accurate cage mapping to the deformed object.

   This setting becomes unavailable once a cage has been bound.

Dynamic
   When activated, other mesh altering features (such as other modifiers and shape keys)
   are taken into account when binding, increasing deformation quality.

   The setting is deactivated by default to save memory and processing time when binding.
   Like with *Precision*, this setting is unavailable once a cage has been bound.

Bind
   Links the current vertex positions of both the modified geometry and the deforming *Object* chosen together.
   An unbound *Mesh Deform* modifier has no effect,
   it must be bound so that altering the shape of the deform mesh cage
   actually alters the shape of the modified object.

   .. warning::

      Depending on the settings of the modifier and complexity of the deform mesh cage and/or
      deformed object, it can take a long time for this operation to complete.
      This can result in Blender not responding to user's actions until it has completed.

      It is also possible that Blender will run out of memory and crash.

      To be safe, save your blend-file before proceeding!

Unbind
   When a deformed object has been associated to a deform mesh cage,
   it can later be disassociated by clicking the *Unbind* button which replaced the *Bind* one.

   When *Unbind* is clicked, the *deforming mesh cage* will keep its current shape,
   it will not reset itself back to its initial shape.
   If you need this original shape, you will have to save a copy of it before you alter it.

   The deformed object will, however, reset back to its original shape that it had
   before it was bound to the deform mesh cage.

.. warning::

   Significant changes to the entire cage mesh *(such as rotating the cage upside down)*
   can cause noticeable artifacts.

   These can be reduced by binding with a higher *Precision*,
   however, it is a known limitation with this modifier and cannot be avoided entirely.


Hints
=====

- Ensure that the normals on the cage mesh point to the outside
  (they are used to determine the inside and outside of the cage).
- Besides the outer cage, more faces within the cage, either loose or forming another smaller cage,
  can be used for extra control. Such smaller cages may also overlap with the main cage.
  For example, to get extra control over eyes, two small sphere cages could be added around them.

.. seealso::

   - The :doc:`Lattice modifier </modeling/modifiers/deform/lattice>`.
   - `Original paper <https://graphics.pixar.com/library/HarmonicCoordinatesB/>`__


## Shrinkwrap

.. index:: Modeling Modifiers; Shrinkwrap Modifier
.. _bpy.types.ShrinkwrapModifier:

*******************
Shrinkwrap Modifier
*******************

The *Shrinkwrap* modifier allows an object to "shrink" to the surface of another object.
It moves each vertex of the object being modified to the closest position on
the surface of the given mesh (using one of the four methods available).

It can be applied to meshes, lattices, curves, surfaces and texts.

.. seealso::

   :doc:`Shrinkwrap Constraint </animation/constraints/relationship/shrinkwrap>`.


Options
=======

.. figure:: /images/modeling_modifiers_deform_shrinkwrap_nearest-surface-point.png
   :align: right
   :width: 300px

   The Shrinkwrap modifier in Nearest Surface Point mode.

Wrap Method
   This selector specifies the method to be used to determine the nearest
   point on the target's surface for each vertex of the modified object.
   Some options will add some extra, specific controls to the panel.
   See `Wrap Methods`_ for an explanation of each method.

Snap Mode
   Most modes support an additional setting to control how the vertex
   is moved to the target point selected by the methods described above.
   Some of the choices only differ if *Offset* is not zero.

   On Surface
      The vertex is always moved. The offset is applied along the projection line
      connecting the original vertex and selected target point towards the original position.
   Outside Surface
      Like *On Surface*, but the offset is always applied towards the outside of the target.
   Above Surface
      Like *On Surface*, but the offset is applied along the smooth normal of the target.
   Inside
      The vertex is not moved if it is already inside the target.
      Offset shrinks the allowed volume towards the inside along the projection line.
   Outside
      The vertex is not moved if it is already outside the target.
      Offset expands the exclusion volume towards the outside along the projection line.

   .. note::

      The *Inside* and *Outside* options can be used for very crude collision detection.
      The inside vs outside determination is done based on the target normal and
      is not always stable near 90 degree and sharper angles in the target mesh.

Target
   Shrink target, the mesh to shrink to/wrap around.

Offset
   The distance that must be kept from the calculated target position.

Vertex Group
   The vertex group to control whether and how much each vertex is displaced to its target position.
   If a vertex is not a member of this group, it is not displaced (same as weight 0).


Wrap Methods
============

Nearest Surface Point
---------------------

This will select the nearest point over the surface of the shrunk target.


Project
-------

.. figure:: /images/modeling_modifiers_deform_shrinkwrap_project.png
   :align: right
   :width: 300px

   Project mode.

This will project vertices along a chosen axis until they touch the shrink target.
Vertices that never touch the shrink target are left in their original position.

Limit
   This is a distance limit between original vertex and surface.
   If the distance is larger than this limit vertex would not be projected onto the surface.

Subdivision Levels
   This applies a (temporary) *Catmull-Clark* subdivision to the modified object's geometry,
   before computing the wrap.

Axis
   Along which local axis of the modified object the projection is done.
   These options can be combined with each other, yielding a "median axis" of projection.
   If none are selected, the normal direction is used.

Negative/Positive
   This allows you to select the allowed direction(s) of the shrink along the selected axis.
   If both options are enabled, both ways are evaluated and the closest hit is selected.

Face Cull
   Allows you to prevent any projection over the "front side"
   (respectively the "back side") of the target's faces. The "side" of a face is determined
   by its normal (front being the side "from where" the normal "originates").

Invert Cull
   If *Cull Faces* is enabled, and *Negative* direction along axis is allowed,
   this option can be used to invert the *Front* or *Back* cull choice
   for the *Negative* direction. This is useful when projecting in both directions.

Auxiliary Target
   An additional object to project over.


Nearest Vertex
--------------

.. figure:: /images/modeling_modifiers_deform_shrinkwrap_nearest-vertex.png
   :align: right
   :width: 300px

   Nearest Vertex mode.

This will snap vertices to the nearest vertex of the shrunk target. It adds no extra options.

This method doesn't support the *Snap Mode* setting.

.. container:: lead

   .. clear


Target Normal Project
---------------------

.. figure:: /images/modeling_modifiers_deform_shrinkwrap_normal-project.png
   :align: right
   :width: 300px

   Target Normal Project mode.

This mode is similar to *Nearest Surface Point*, but produces a much smoother
projection in return for being significantly slower.

Instead of finding the closest point, it searches for the nearest point
that has its interpolated smooth normal pointing towards or away from the original vertex position.
Non-manifold boundary edges are specially handled as infinitely thin cylinders
that emit normals in all perpendicular directions; ignores flat shading.


## Simple Deform

.. index:: Modeling Modifiers; Simple Deform Modifier
.. _bpy.types.SimpleDeformModifier:

**********************
Simple Deform Modifier
**********************

The *Simple Deform* modifier allows the application of a simple deformation to
an object. Meshes, lattices, curves, surfaces and texts are supported objects.
The deformation is either a rotation (Twist, Bend) or a scaling (Taper, Stretch).
The amount of deformation is specified by the Deform Angle (rotation) or Deform Factor (scaling).

.. figure:: /images/modeling_modifiers_deform_simple-deform_intro.png

   The Simple Deform modifier.

The deformation is calculated in the *local* coordinate space.
Be aware that the local axes of an object can differ from the global ones.
In the figure above, the global Z axis points up and the local Z axis points at 45°.
The deformation is applied along a Deform axis, which can be set by selection from a list (X, Y or Z).
By using the *Limits* field, the influence of the modifier can be restricted to a subset of the Deform axis.
All distances are measured from the origin of the object.
The vertices that are furthest away from the origin on the Deform axis
represent the upper and lower limits.
The origin of the object and the orientation of the local axes
can be defined by an external Deform object (most of the time, an empty).


Options
=======

Mode
   Defines the kind of deformation which will be applied.
   The figure below shows the four modes, applied to a text object.
   The origin of the object is at the very left of the text.

   .. list-table::

      * - .. figure:: /images/modeling_modifiers_deform_simple-deform_twist.png

             Twist around X axis (180°).

        - .. figure:: /images/modeling_modifiers_deform_simple-deform_bend.png

             Bend around Z axis (180°).

      * - .. figure:: /images/modeling_modifiers_deform_simple-deform_taper.png

             Taper along X axis (factor = 2).

        - .. figure:: /images/modeling_modifiers_deform_simple-deform_stretch.png

             Stretch along X axis (factor = 0.3).

   Twist
      Rotates the mesh around the specified *Axis*.
      Each vertex along the Deform axis is rotated around the object's origin.
      If the origin is inside the object, this results in a twisted appearance.
      Below the origin, there is a negative rotation and
      above the origin, the rotation is positive or clockwise.
      Vertices in the same plane as the origin are not rotated.

      The total amount of rotation is specified by the angle
      and the rotation at each vertex is thus weighted by the distance
      of the vertex to the origin of the object.
      Vertices that are furthest away from the object origin have max rotation,
      positive or negative.
   Bend
      Bends the mesh over the specified *Axis*.
      The Bend mode is more complex and less intuitive.
      The picture below shows the same plane but with different Deform and Bending axes.

      .. list-table::

         * - .. figure:: /images/modeling_modifiers_deform_simple-deform_bend-1.png

                Deform axis X or Y (a).

           - .. figure:: /images/modeling_modifiers_deform_simple-deform_bend-2.png

                Deform axis Z (b).

         * - .. figure:: /images/modeling_modifiers_deform_simple-deform_bend-3.png

                Deform axis X. Local axis Y points down (c).

           - .. figure:: /images/modeling_modifiers_deform_simple-deform_bend-4.png

                Deform axis X. Local axis Y points up (d).

      Using a mesh plane and setting the Deform axis to X or Y will not result in any deformation (Fig a).
      You expect that the bending should be something like Figure (c) or (d).
      In a 3D world however, selecting the X axis introduces an ambiguity because
      bending along the X axis could result in Figure (c) or (d).
      The following pairs describe the selected deform axis vs. the desired bending axis:
      X and Z, Y and Z, Z and X.

      In Fig (a), because of the Deform axis X, the Bending is along the Z.
      All vertices however have the same Z coordinate equal to the local origin.
      So, no deformation occurs. In Fig (d) the local axes are rotated around the Deform axis X,
      so that the Bending axis Z points to the left.
      So, all vertices are bend for their Z coordinate.
      The further away from the local origin, the more bending.

      This explains also the unexpected result of Fig (b).
      The Deform axis is set here to Z (pointing up).
      So, according to the pairs above, the Bending axis defaults to X.
      All vertices of the plane are bent in their X coordinate.
      The further away, the more rotation occurs.
      Negative X coordinates are rotated counterclockwise.

   Taper
      Linearly scales along the specified *Axis*.
      The scaling factor is weighted by the distance from the origin of the object in the deform axis.
      No scaling occurs in the plane of the origin of the object.
      The maximum scaling occurs at the vertices that are furthest away from the local origin.
      This can be a positive or negative scaling, depending on the location of the origin.
      If the local origin is within the object, the deformed object appears tapered.
   Stretch
      Stretches the object along the specified *Axis*.
      If the local origin is within the object, the deformed mesh
      looks stretched like pulling a rubber from both sides.
      With a positive factor, the mesh gets longer in the deformed axis,
      wider at the borders and thinner at the origin than the original mesh.
      If the factor is negative, then the mesh is squashed in the deformed axis,
      thicker at the origin and thinner at the borders.

Angle (Twist & Bend)/Factor (Taper & Stretch)
   The total amount of deformation. Can be negative to reverse the deformation.

Axis, Origin
   The name of an object that defines the origin and axis of deformation (usually an empty).
   This object can be:

   - Rotated to control the axis (its local *Axis* is now used as the deformation one).
   - Moved to control the origin of the deformation.
   - Scaled to change the deformation factor.


Restrictions
------------

Limits
   You can set the lower and upper limits of the deformation.
   The upper limit cannot be lower than the lower one. These limits are mapped on the Deform axis.

Lock (Twist, Taper and Stretch modes only)
   These controls whether the coordinates along the two other axes are allowed to change or not.
   E.g. if you *Stretch* your object along its Z axis,
   it is possible to squash along the X axis only, by locking the Y one.

Vertex Group
   The name of the vertex group that indicates whether
   and how much each vertex is influenced by the deformation.
   The amount of influence is determined by the weight in the Weight Paint map.


## Smooth

.. index:: Modeling Modifiers; Smooth Modifier
.. _bpy.types.SmoothModifier:

***************
Smooth Modifier
***************

The *Smooth* modifier smooths a mesh by flattening the angles between adjacent faces in it,
just like the :ref:`Smooth tool <bpy.ops.mesh.vertices_smooth>` in Edit Mode.
It smooths without subdividing the mesh, the number of vertices remains the same.

This modifier is not limited to smoothing, though.
Its control factor can be configured outside the (0.0 to 1.0) range
(including negative values), which can result in interesting deformations.


Options
=======

.. figure:: /images/modeling_modifiers_deform_smooth_panel.png
   :align: right
   :width: 300px

   The Smooth modifier.

Axis
   Enable/disable the modifier in the X, Y and/or Z axes directions.

Factor
   Controls the smoothing amount.
   Higher values will increase the effect.

   Values outside expected range (above 1.0 or below 0.0) will distort the mesh.

Repeat
   The number of smoothing iterations,
   equivalent to executing the *Smooth* tool multiple times.

Vertex Group
   If set, restrict the effect to the only vertices in that vertex group.
   This allows for selective, real-time smoothing, by painting vertex weights.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.


Algorithm
=========

The calculation done by the *Smooth* modifier is a simple and logical one,
and can be thought of as the geometric equivalent of blurring images.

Each new vertex position is simply moved towards the average position of all its neighbor vertices
(topologically speaking, i.e. the vertices directly connected to it by an edge).

.. (TODO) Add diagrams.


Example
=======

.. list-table::

   * - .. figure:: /images/modeling_modifiers_deform_smooth_mesh-before.png
          :width: 200px

          Mesh before smoothing.

     - .. figure:: /images/modeling_modifiers_deform_smooth_mesh-one-iteration.png
          :width: 200px

          Mesh after one smoothing iteration.

     - .. figure:: /images/modeling_modifiers_deform_smooth_mesh-ten-iterations.png
          :width: 200px

          Mesh after ten smoothing iterations.


## Surface Deform

.. index:: Modeling Modifiers; Surface Deform Modifier
.. _bpy.types.SurfaceDeformModifier:

***********************
Surface Deform Modifier
***********************

The *Surface Deform* modifier allows an arbitrary mesh surface to
control the deformation of another, essentially transferring its motion/deformation.
One great use for this is to have a proxy mesh for cloth simulation,
which will in turn drive the motion of your final and more detailed mesh,
which would otherwise not be suitable for simulation.


Options
=======

.. figure:: /images/modeling_modifiers_deform_surface-deform_panel.png
   :align: right
   :width: 300px

   The Surface Deform modifier.

Target
   The object to which to bind (this setting is unavailable after binding).

   .. warning:: Target Mesh Validity

      While there are no restrictions with regard to the modified mesh,
      the target object's mesh has a few constraints, which if not followed, will prevent a successful binding:

      - It must **not** contain edges with more than two faces.
      - It must **not** contain concave faces.
      - It must **not** contain overlapping vertices (doubles).
      - It must **not** contain faces with collinear edges.

Interpolation Falloff
   How much a vertex bound to one face of the target will be affected by the surrounding faces
   (this setting is unavailable after binding).
   This essentially controls how smooth the deformations are.

   .. note::

      While lower values result in smoother deformations,
      they may also introduce slight artifacts.

Strength
   The overall amount of influence the modifier has on deforming the mesh.

Vertex Group
   Allows you to define the influence per vertex.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.

Sparse Bind
   Only record bind data for vertices that have nonzero weights in the group at the time of bind.
   This is an optimization, but adding new vertices to the group will require a rebind.

Bind
   Bind the current state of the modified mesh to the current state of the target mesh,
   such that any later change in the target mesh will deform the modified mesh as well.
   Note that until the bind has been executed, this modifier will have no effect at all.

Unbind
   Once the mesh is bound, the *Bind* button changes to *Unbind*.
   Executing this frees the modified mesh from the target, and resets it to its original shape.

.. note::

   The meshes are bound with regard to global coordinates,
   but later transformations on the objects are ignored.
   This means that one can freely transform the target or modified object after binding,
   without affecting the modified object.
   The modified mesh will only pick up changes to the target object's mesh itself.

.. note::

   The further a mesh deviates from the target mesh surface,
   the more likely it is to get undesirable artifacts.
   This is an inherent characteristic of surface binding in general,
   so it is recommended to have reasonably well matching meshes, in order to get a good bind.


Example
=======

.. figure:: /images/modeling_modifiers_deform_surface-deform_example.png

   Cloth simulation copied to an arbitrary mesh with rings as instancing faces.


## Volume Displace

.. index:: Modeling Modifiers; Volume Displace
.. _bpy.types.VolumeDisplaceModifier:

************************
Volume Displace Modifier
************************

.. reference::

   This modifier is only available for :doc:`Volume Objects </modeling/volumes/index>`.

The *Volume Displace* modifier displaces existing volume grids based on a 3D texture.
It uses the RGB color channels of the texture to displace the volume into the X, Y and Z direction.


Options
=======

.. figure:: /images/modeling_modifiers_deform_volume-displace_panel.png
   :align: right
   :width: 300px

   The Volume Displace modifier.

Texture
   The texture that is evaluated at every voxel to determine how far and in what direction to displace.

   .. note::

      Grayscale textures lead to stretching along one axis.
      It's best to use a color texture.

Strength
   Controls how far voxels are displaced.

Sample Radius
   Smaller values result in better performance, but might cut off the volume outside.

Mid Level
   This should be modified if the texture offsets the entire volume in one direction and you want to center it again.
   For performance reasons, the displaced volume should stay close to its original position.


Example
=======

.. figure:: /images/modeling_modifiers_deform_volume-displace_example.png
   :width: 500px

   A volume displaced with various strengths.


## Warp

.. index:: Modeling Modifiers; Warp Modifier
.. _bpy.types.WarpModifier:

*************
Warp Modifier
*************

The *Warp* modifier can be used to warp parts of a mesh to a new location in
a very flexible way, by using two objects to select the "from" and "to" regions.

.. figure:: /images/modeling_modifiers_deform_warp_example.png
   :align: center

   A Warp modifier applied to a grid mesh.

This modifier is a bit tricky to understand at first.
It requires two points, specified by the two target objects' origins.
The "from" point designates a point in space that is pulled toward the "to" point.
It is akin to using
the :doc:`Proportional Editing </editors/3dview/controls/proportional_editing>` in Edit Mode.


Options
=======

.. figure:: /images/modeling_modifiers_deform_warp_panel.png
   :align: right
   :width: 300px

   The Warp modifier.

Object From
   The object defining the origin transformation of the warp.

Object To
   The object defining the destination transformation of the warp.

Preserve Volume
   Enables volume preservation when rotating one of the transforms.

Strength
   Sets how strong the effect is.

Vertex Group
   The name of a vertex group which is used to control the influence of the modifier.
   If left empty, the modifier affects all vertices equally.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.


Falloff
-------

Falloff Type
   Sets the way the strength of the warp change as it goes from the center of the transform to the *Radius* value.
   See :doc:`Proportional Editing </editors/3dview/controls/proportional_editing>`
   for descriptions of the falloff types.

Radius
   Sets the distance from the transforms that can be warped by the transform handles.


Texture
-------

Texture
   You can finely control which vertices are affected by the warp,
   and to what extent, using a texture.

See :ref:`common masking options <modifiers-common-options-masking>` for a complete reference.


Usage
=====

The *Warp* modifier can be awkward to use sometimes, and its use case is rather small,
but there are a few still. For example, it can be used to have
an interactive :doc:`Proportional Editing </editors/3dview/controls/proportional_editing>`
that can be used for animations.

Another way to use this modifier is similar to
the :doc:`Deform Modifier </modeling/modifiers/deform/mesh_deform>`.
This allows you to deform parts of the mesh without having to make a vertex group.


Examples
========

.. figure:: /images/modeling_modifiers_deform_warp_example-curve-falloff.png
   :align: center

   Warp Modifier with a custom falloff curve.


## Wave

.. index:: Modeling Modifiers; Wave Modifier
.. _bpy.types.WaveModifier:

*************
Wave Modifier
*************

The *Wave* modifier adds a ripple-like motion to an object's geometry.

This modifier is available for meshes, lattices, curves, surfaces and texts.

.. list-table::

   * - .. figure:: /images/modeling_modifiers_deform_wave_example-circular.jpg
          :width: 200px

          Circular wave front.

     - .. figure:: /images/modeling_modifiers_deform_wave_example-linear.jpg
          :width: 200px

          Linear wave front.

     - .. figure:: /images/modeling_modifiers_deform_wave_example-normals.jpg
          :width: 200px

          Motion enabled for X,
          Normals enabled for Y.


Options
=======

.. figure:: /images/modeling_modifiers_deform_wave_panel.png
   :align: right
   :width: 300px

   The Wave modifier.

Motion
   The wave effect deforms vertices/control points in the Z direction,
   originating from the given starting point and propagating along the object with circular wave fronts
   (if both X and Y are enabled),
   or with rectilinear wave fronts (if only one axis is enabled),
   then parallel to the axis corresponding to the X or Y button activated.

Cyclic
   Repeats the waves cyclically, rather than a single pulse.

Along Normals
   For meshes only. Displaces the mesh along the surface normals (instead of the object's Z axis).

   X/Y/Z
      Restrict displacement along normals to the selected local axes.

Falloff
   Controls how fast the waves fade out as they travel away from the coordinates above
   (or those of the *Start Position Object*).

Height
   The height or amplitude of the ripple.

Width
   Half of the width between the tops of two subsequent ripples (if *Cyclic* is enabled).
   This has an indirect effect on the ripple amplitude. If the pulses are too near to each other,
   the wave may not reach the zero Z position, so in this case Blender actually lowers the whole wave
   so that the minimum is zero and, consequently, the maximum is lower than the expected amplitude.
   See `Technical Details and Hints`_ for more information.

Narrowness
   The actual width of each pulse: the higher the value the narrower the pulse.
   The actual width of the area in which the single pulse is apparent is given by ``4 / Narrowness``.
   That is, if *Narrowness* is 1 the *pulse* is 4 units wide, and if *Narrowness*
   is 4 the *pulse* is 1 unit wide.

Vertex Group
   The name of a vertex group which is used to control the influence of the modifier.
   If left empty, the modifier affects all vertices equally.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.

.. important::

   All the values described above are in local object space,
   i.e. they must be multiplied with the corresponding *Scale* values of
   the object to get the real dimensions.


Start Position
--------------

Object
   Use another object as the reference for the starting position of the wave.
   Note that you then can animate this object's position, to change the wave's origin across time.

Start Position X/Y
   Coordinates of the center of the waves, in the object's local space.


Time
----

Settings to control the animation.

Offset
   Time offset in frames. The frame at which the wave begins (if *Speed* is positive),
   or ends (if *Speed* is negative). Use a negative frame number to prime and pre-start the waves.
Life
   Duration of animation in frames. When set to zero, loops the animation forever.
Damping
   An additional number of frames in which the wave slowly damps from the *Height* value
   to zero after *Life* is reached.
   The dampening occurs for all the ripples and begins in the first frame after the *Life* is over.
   Ripples disappear over *Damping* frames.
Speed
   The speed per frame, of the ripple.


Texture
-------

You can finely control which vertices are affected by the wave,
and to what extent, using a texture.

See :ref:`common masking options <modifiers-common-options-masking>` for a complete reference.


Technical Details and Hints
===========================

The relationship of the above values is described here:

.. figure:: /images/modeling_modifiers_deform_wave_front-characteristics.png
   :align: center

   Wave front characteristics.

To obtain a nice wave effect similar to sea waves and close to a sinusoidal wave,
make the distance between following ripples and the ripple width equal. That is,
the *Narrowness* value must be equal to ``2 / Width``.
E.g. for *Width* to be 1, set *Narrow* to 2.


## Array

.. index:: Modeling Modifiers; Array Modifier
.. _bpy.types.ArrayModifier:

**************
Array Modifier
**************

The *Array* modifier creates an array of copies of the base object, with each copy being offset from
the previous one in any of a number of possible ways. Vertices in adjacent copies can be merged if they are nearby,
allowing smooth :doc:`Subdivision Surface </modeling/modifiers/generate/subdivision_surface>`
frameworks to be generated.

This modifier can be useful when combined with tileable meshes for quickly developing large scenes.
It is also useful for creating complex repetitive shapes.

Multiple Array modifiers may be active for an object at the same time
(e.g. to create complex three-dimensional constructs).


Options
=======

.. figure:: /images/modeling_modifiers_generate_array_panel.png
   :align: right
   :width: 300px

   The Array modifier.

Fit Type
   Controls how the length of the array is determined. There are three choices,
   activating respectively the display of the *Curve*, *Length* or *Count* settings explained below:

   Fit Curve
      Generates enough copies to fit within the length of the curve object specified in *Curve*.
   Fit Length
      Generates enough copies to fit within the fixed length given by *Length*.
   Fixed Count
      Generates the number of copies specified in *Count*.

.. note::

   - Both *Fit Curve* and *Fit Length* use the local coordinate system size of the base object, which means that
     scaling the base object in Object Mode will not change the number of copies generated by the modifier.
   - *Fit Curve* uses the local coordinate system length of the curve, which means that scaling the curve in
     Object Mode will not change the number of copies generated by the modifier.
   - :ref:`Applying <bpy.ops.object.transform_apply>` the scale can be useful for both.


Relative Offset
---------------

Factor X/Y/Z
   Adds a translation equal to the object's bounding box size along each axis, multiplied by a scaling factor,
   to the offset. X, Y and Z scaling factors can be specified.

   .. figure:: /images/modeling_modifiers_generate_array_offset-relative.png

      Relative offset (0.5, 1.0 and 1.5) examples.


Constant Offset
---------------

Distance X/Y/Z
   Adds a constant translation component to the duplicate object's offset.
   X, Y and Z constant components can be specified.


Object Offset
-------------

Adds a transformation taken from an object (relative to the current object) to the offset.
It is good practice to use an empty object centered or near to the initial object.
E.g. by rotating this empty a circle or helix of objects can be created.

.. figure:: /images/modeling_modifiers_generate_array_offset-object.png

   Object offset example.


Merge
-----

If enabled, vertices in each copy will be merged with vertices
in the next copy that are within the given *Distance*.

First and Last Copies
   If enabled **and** *Merge* is enabled, vertices in the first copy will be merged with vertices
   in the last copy, again if they are within *Distance* range. This is useful for circular objects.

   .. list-table:: First and Last Copies merge example.

      * - .. figure:: /images/modeling_modifiers_generate_array_first-last-off.png

             Subdivision discontinuity caused by not merging vertices between first and
             last copies (*First and Last Copies* off).

        - .. figure:: /images/modeling_modifiers_generate_array_first-last-on.png

             Subdivision discontinuity eliminated by merging vertices between first and
             last copies (*First and Last Copies* on).

Distance
   Controls the merge distance for *Merge* and *First and Last Copies*.


UVs
---

Offset U/V
   Shifts UVs of each new duplicate by a settable amount.


Caps
----

Cap Start, End
   This allows either endpoints of the array to have a different mesh subsisted.

   For the *start*: as if it was in position -1, i.e. one "array step" before the first "regular" array copy.
   For the *end*: as if it was in position *n* + 1, i.e. one "array step" after the last "regular" array copy.

   When *Merge* is activated, the *cap* vertices within the *Distance* threshold will be merged.

   .. note::

      The start/end cap objects currently do not support the *First and Last Copies* option.


Hints
=====

Offset Calculation
------------------

The transformation applied from one copy to the next is calculated as the sum of the three
different components (*Relative*, *Constant* and *Object*),
each of which can be enabled/disabled independently of the others. This allows, for example,
a relative offset of (1.0, 0.0, 0.0) and a constant offset of (0.1, 0.0, 0.0),
giving an array of objects neatly spaced along the X axis with a constant 0.1
unit between them, whatever the original object's size.


Examples
========

.. figure:: /images/modeling_modifiers_generate_array_example-mechanical-chain.png

   A chain created from a single link.
   `Sample blend-file <https://archive.blender.org/wiki/2015/index.php/File:Dev-ArrayModifier-Chain01.blend>`__.

.. figure:: /images/modeling_modifiers_generate_array_example-organic-tentacle.jpg

   A tentacle created with an Array Modifier followed by a Curve Modifier.

   The segment in the foreground is the base mesh for the tentacle; the tentacle is capped by two
   specially-modeled objects deformed by the same Curve object as the main part of the tentacle.
   `Sample blend-file <https://archive.blender.org/wiki/2015/index.php/File:Manual-Modifier-Array-Tentacle01.blend>`__.


Fractal
-------

.. list-table::

   * - .. figure:: /images/modeling_modifiers_generate_array_example-fractal-1.jpg
          :width: 320px

          Multi-level array animated with motion blur.

     - .. figure:: /images/modeling_modifiers_generate_array_example-fractal-2.png
          :width: 320px

          Fractal created with multiple arrays.
          `Sample blend-file <https://archive.blender.org/wiki/2015/index.php/File:Dev-ArrayModifier-Fractal01.blend>`__.


## Bevel

.. index:: Modeling Modifiers; Bevel Modifier
.. _bpy.types.BevelModifier:

**************
Bevel Modifier
**************

.. figure:: /images/modeling_modifiers_generate_bevel_panel.png
   :align: right
   :width: 250px

   The Bevel modifier.

The *Bevel* modifier bevels the edges of the mesh it is applied to,
with some control of how and where the bevel is applied to the mesh.

It is a non-destructive alternative to
the :doc:`Bevel Operation </modeling/meshes/editing/edge/bevel>` in Edit Mode.

.. list-table:: Side views of a cube.
   :align: center

   * - .. figure:: /images/modeling_modifiers_generate_bevel_square-not.png
          :width: 250px

          Not beveled.

     - .. figure:: /images/modeling_modifiers_generate_bevel_square.png
          :width: 250px

          Beveled.

.. container:: lead

   .. clear


Options
=======

Affect
   :Vertices:
      Only the areas near vertices are beveled, the edges remain unchanged.
   :Edges:
      Bevel the edges, creating intersections at vertices.

   .. figure:: /images/modeling_modifiers_generate_bevel_cubes-vertices-only.png

      Three cubes with 0.1, 0.3 and 0.5 bevel widths, with *Vertices* option selected.

.. figure:: /images/modeling_modifiers_generate_bevel_width-methods.png
   :align: right
   :width: 250px

Width Type
   Defines how *Width* will be interpreted to determine the amount of bevel.

   :Offset:
      The distance from the new edge to the original.
   :Width:
      The distance between the two new edges formed by the bevel
      (or the edges on either side of the bevel if there is more than one segment).
   :Depth:
      Value is the perpendicular distance from the new bevel face to original edge.
   :Percent:
      The percentage of the length of adjacent edge length that the new edges slide along.
   :Absolute:
      The exact distance along edges adjacent to the beveled edge. A difference from **Offset** is visible
      when the unbeveled edges attached to beveled edges meet at an angle besides a right angle.

Width
   The size of the bevel effect. See *Width Method* below.

   .. figure:: /images/modeling_modifiers_generate_bevel_cubes.png

      Three Cubes with 0.1, 0.3 and 0.5 bevel widths.

Segments
   The number of edge loops added along the bevel's face.

Limit Method
   Used to control where a bevel is applied to the mesh.

   :None:
      No limit, all edges will be beveled.
   :Angle:
      Only bevels edges whose angle of adjacent face normals plus the defined *Angle* is less than 180 degrees.
      Intended to allow you to bevel only the sharp edges of an object without affecting its smooth surfaces.
   :Weight:
      Use each edge's bevel weight to determine the width of the bevel.
      When the bevel weight is 0.0, no bevel is applied.
      See :doc:`here </modeling/meshes/editing/edge/edge_data>` about adjusting bevel weights.
   :Vertex Group:
      Use weights from a vertex group to determine the width of the bevel.
      When the vertex weight is 0.0, no bevel is applied.
      An edge is only beveled if both of its vertices are in the vertex group.
      See :doc:`here </modeling/meshes/properties/vertex_groups/vertex_groups>` about adjusting vertex group weights.

      Invert ``<->``
         Inverts the influence of the selected vertex group, meaning that the group
         now represents vertices that will not be deformed by the modifier.

         The setting reverses the weight values of the group.


Profile
-------

Superellipse
^^^^^^^^^^^^

Creates a bevel with a uniform concave or convex curve.

Shape
   The shape of the bevel, from concave to convex. It has no effect if *Segments* is less than 2.


Custom Profile
^^^^^^^^^^^^^^

.. figure:: /images/modeling_modifiers_generate_bevel_profile-widget.png
   :align: right
   :width: 250px

   The custom profile widget.

This widget allows the creation of a user-defined profile with more complexity than
with the single profile parameter. The modal tool allows toggling the custom profile,
but the shape of the profile is only editable in the options panel after the operation is confirmed.

The profile starts at the bottom right of the widget and ends at the top left, as if it
were between two edges meeting at a right angle. Control points are created in the widget and
then the path is sampled with the number of segments from the Bevel modifier.

.. container:: lead

   .. clear

Miter Shape
   The shape of the miter patterns, from concave to convex. It has no effect if *Segments* is less than 2.

   .. note::

      The *Miter Shape* slider stays active when miters are enabled
      because it still controls the shape of the miter profiles.

Presets
   The *Support Loops* and *Steps* presets are built dynamically depending on the number of segments in the bevel.
   If the number of segments is changed, the preset will have to be re-applied.

Sampling
   Samples will first be added to each control point, then if there are enough samples,
   they will be divided evenly between the edges. The *Sample Straight Edges* option toggles whether
   the samples are added to edges with sharp control points on either side. If there aren't enough samples
   to give each edge the same number of samples, they will just be added to the most curved edges,
   so it is recommended to use at least as many segments as there are control points.


Geometry
--------

Miter Inner/Outer
   A *miter* is formed when two beveled edges meet at an angle.
   On the side where the angle is greater than 180 degrees, if any, it is called an *outer miter*.
   If it is less than 180 degrees, then it is called an *inner miter*.
   The outer and inner miters can each be set to one of these patterns:

   :Sharp:
      Edges meet at a sharp point, with no extra vertices introduced on the edges.
   :Patch:
      Edges meet at a sharp point but in addition, two extra vertices are introduced near the point
      so that the edges and faces at the vertex may be less pinched together than
      what occurs in the *Sharp* case.
      This pattern does makes no sense for inner miters, so it behaves like *Arc* for them.
   :Arc:
      Two vertices are introduced near the meeting point, and a curved arc joins them together.

      The *Spread* slider controls how far the new vertices are from the meeting point.

      The *Profile* curve widget controls the shape of the arc.

   .. list-table:: Diagrams of the miter patterns.

      * - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-2.png

             Sharp outer miter.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-3.png

             Patch outer miter.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-4.png

             Arc outer miter.

      * - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-5.png

             Sharp inner miter.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_miter-6.png

             Arc inner miter.

        - ..

Spread
   The value used to spread extra vertices apart for non-sharp miters.
   This option is available when Miter Inner is set to Arc.

Intersections
   When more than two beveled edges meet at a vertex, a mesh is created as a way to complete the intersection
   between the generated geometry. This option controls the method used to create that mesh.

   :Grid Fill:
      The default method for building intersections, useful when a smooth continuation of
      the bevel profile is desired. Without *Custom Profile* enabled, the curve of the profile continues through
      the intersection, but with a custom profile it just creates a smooth grid
      within the boundary of the intersection.
   :Cutoff:
      Creates a cutoff face at the end of each beveled edge coming into the vertex.
      This is most useful for custom profiles when the new intersection is too complex for a smooth grid fill.

      With a three way intersection, when the inner corners of the cutoff profiles faces meet at
      the same location, no center face is created.

      The direction of the cutoff faces depends on the original vertex's normal.

   .. list-table:: Intersection method options.

      * - .. figure:: /images/modeling_meshes_editing_edge_bevel_vmesh-1.png
             :width: 200px

             Grid fill intersection method.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_vmesh-2.png
             :width: 200px

             Three way cutoff intersection where the inner vertices are merged.

        - .. figure:: /images/modeling_meshes_editing_edge_bevel_vmesh-3.png
             :width: 200px

             Cutoff intersection method with a center face.

Clamp Overlap
   Limits the width of each beveled edge so that edges cannot cause
   overlapping intersections with other geometry.
Loop Slide
   If there are unbeveled edges along with beveled edges into a vertex,
   the bevel tries to slide along those edges when possible.
   Turning the option off can lead to more even bevel widths.


Shading
-------

Harden Normals
   When enabled, the per-vertex face normals of the bevel faces are adjusted to
   match the surrounding faces, and the normals of the surrounding faces are not affected.
   This will keep the surrounding faces flat (if they were before),
   with the bevel faces shading smoothly into them. For this effect to work,
   a mesh must have :ref:`custom split normals <modeling_meshes_normals_custom>`.
   As a convenience, that option will be enabled for you if it is not already when you enable Harden Normals here.

Mark
   Seam
      If a seam edge crosses a non-seam one and you bevel all of them,
      this option will maintain the expected propagation of seams.
   Sharp
      Similar to Mark Seams, but for sharp edges.

Material Index
   The index of the material slot to use for the bevel.
   When set to -1, the material of the nearest original face will be used.

Face Strength
   Set *Face Strength* on the faces involved in the bevel, according to the mode specified here.
   This can be used in conjunction with a following
   :doc:`Weighted Normals </modeling/modifiers/modify/weighted_normal>` modifier
   (with the *Face Influence* option checked).

   :None:
      Do not set face strength.
   :New:
      Set the face strength of new faces along edges to *Medium*,
      and the face strength of new faces at vertices to *Weak*.
   :Affected:
      In addition to those set for the *New* case,
      also set the faces adjacent to new faces to have strength *Strong*.
   :All:
      In addition to those set for the *Affected* case,
      also set all the rest of the faces of the model to have strength *Strong*.


## Booleans

.. index:: Modeling Modifiers; Boolean Modifier
.. _bpy.types.BooleanModifier:

****************
Boolean Modifier
****************

The *Boolean* modifier performs operations on meshes that are otherwise too complex
to achieve with as few steps by editing meshes manually. It uses one of
the three available Boolean operations to create a single mesh out of two mesh objects:

.. figure:: /images/modeling_modifiers_generate_booleans_union-intersect-difference-examples.png

   The Union, Intersection and Difference between a Cube and a UV Sphere,
   with the modifier applied to the sphere and using the cube as target.

This modifier needs a second mesh object, or collection of mesh objects,
to be the target (the second operand) of the operation.

.. warning::

   Only :term:`Manifold` meshes are guaranteed to give proper results,
   other cases (especially "opened" meshes, :term:`Non-manifold` but without any self-intersections)
   will usually work well, but might give odd glitches and artifacts in some cases.

.. tip::

   If you have marked your objects to show the edges
   (in :menuselection:`Properties --> Object Properties --> Viewport Display`, enable *Wireframe*),
   you will see the edge creation process while you are moving your objects around. Depending on your mesh topology,
   you can also enable X-Ray and Transparency and see the topology being created in real-time.


Options
=======

.. figure:: /images/modeling_modifiers_generate_booleans_panel.png
   :align: center
   :width: 300px

   The Boolean modifier.

Operation
   :Intersect:
      Everything inside both the target mesh and the modified mesh is kept.
      If the target is a collection, then only the inside of *all* meshes is kept.
   :Union:
      The target mesh or collection is added to the modified mesh,
      removing any interior faces.
   :Difference:
      The target mesh, or collection of meshes, is subtracted from the modified mesh
      (everything *outside* of the target mesh or collection is kept).

Operand Type
   Choose the type of the operand (target).

   :Object:
      The target is a mesh object.

   :Collection:
      The target is a collection.
      When the target is a collection and the Solver is Fast,
      the Intersect operation is not allowed.

Object
   The name of the target mesh object.

Collection
   The name of the target collection (may be empty if Solver is Exact,
   which can be useful in combination with the Self option).

Solver
   Algorithm used to calculate the Boolean intersections.

   :Fast:
      Uses a mathematically simple solver which offers the best performance;
      however, this solver lacks support for overlapping geometry.
   :Exact:
      Uses a mathematically complex solver which offers the best results
      and has full support for overlapping geometry;
      however, this solver is much slower than the *Fast Solver*.


Solver Options
--------------

Materials :guilabel:`Exact Solver`
   Method for setting materials on the new faces.

   :Index Based:
      Set the material on new faces based on the order of the material slot lists.
      If a material doesn't exist on the modifier object,
      the face will use the same material slot or the first if the object doesn't have enough slots.
   :Transfer:
      Transfer materials from non-empty slots to the result mesh, adding new materials as necessary.
      For empty slots, fall back to using the same material index as the operand mesh.

Self Intersection :guilabel:`Exact Solver`
   Correctly calculates cases when one or both operands have self-intersections,
   this involves more calculations making it slower.

Hole Tolerant :guilabel:`Exact Solver`
   Optimizes the Boolean output for :term:`Non-manifold` geometry
   at the cost of increased computational time.
   Because of the performance impact, this option should only be enabled
   when the *Exact* solver demonstrates errors with non-manifold geometry.

Overlap Threshold :guilabel:`Fast Solver`
   Maximum distance between two faces to consider them as overlapping.
   This helps solve the limitation of this solver,
   if the Boolean result seems unexpected try using the exact solver.


## Build

.. index:: Modeling Modifiers; Build Modifier
.. _bpy.types.BuildModifier:

**************
Build Modifier
**************

The *Build* modifier causes the faces of the mesh object to appear or disappear one after the other over time.

By default, faces appear in the order in which they are stored in memory (by default, the order of creation).
The face/vertex order can be altered in Edit Mode by using :ref:`Sort Mesh Elements <mesh-edit-sort-elements>`.


Options
=======

.. figure:: /images/modeling_modifiers_generate_build_panel.png
   :align: right
   :width: 300px

   The Build modifier.

Start Frame
   The start frame of the building process.

Length
   The number of frames over which to rebuild the object.

Reversed
   The modifier will operate in reverse, essentially allowing it to be used as a "deconstruction" effect.
   This is useful for making a set of instancing objects gradually disappear.


Randomize
---------

Randomizes the order in which the faces are built.

Seed
   The random seed.
   Changing this value gives a different "random" order when *Randomize* is checked.
   This order is always the same for a given seed/mesh set.


Example
=======

The Build modifier can be used to make a large number of items to progressively appear,
without resorting to animating the visibility of each one by one. Examples of this include
a mesh containing vertices only, which is used as
an :doc:`Instancing Vertex emitter </scene_layout/object/properties/instancing/verts>`,
and has the Build modifier on it. Such a setup is a workaround/technique for being able to art-direct
a semi-random layout of a collection of objects (e.g. leaves/balls forming a carpet).
This can be preferable to particles e.g. due to undesirable distribution of items leaving random gaps
and overlapping in other places.

.. peertube:: 2b0eadea-17ac-4c08-90ec-fc603d7effa4


## Decimate

.. index:: Modeling Modifiers; Decimate Modifier
.. _bpy.types.DecimateModifier:

*****************
Decimate Modifier
*****************

The *Decimate* modifier allows you to reduce the vertex/face count of a mesh with minimal shape changes.

This is not usually used on meshes which have been created by modeling carefully and economically
(where all vertices and faces are necessary to correctly define the shape).
But if the mesh is the result of complex modeling,
sculpting and/or applied :doc:`Subdivision Surface </modeling/modifiers/generate/subdivision_surface>`/
:doc:`Multiresolution </modeling/modifiers/generate/multiresolution>` modifiers,
the *Decimate* one can be used to reduce the polygon count for a performance increase,
or simply remove unnecessary vertices and edges.

Unlike the majority of existing modifiers, this one does not allow
you to visualize your changes in Edit Mode.

The modifier displays the number of remaining faces as a result of the *Decimate* modifier.


Options
=======

Collapse
--------

.. figure:: /images/modeling_modifiers_generate_decimate_panel-collapse.png
   :align: right
   :width: 300px

   The Decimate modifier in Collapse mode.

Merges vertices together progressively, taking the shape of the mesh into account.

Ratio
   The ratio of faces to keep after decimation.

   - On 1.0: the mesh is unchanged.
   - On 0.5: edges have been collapsed such that half the number of faces remain (see note below).
   - On 0.0: all faces have been removed.

   .. note::

      Although the *Ratio* is directly proportional to the number of remaining faces,
      triangles are used when calculating the ratio.

      This means that if your mesh contains quads or other polygons,
      the number of remaining faces will be larger than expected,
      because those will remain unchanged if their edges are not collapsed.

      This is only true if the *Triangulate* option is disabled.

Symmetry
   Maintains symmetry on a single axis.

Triangulate
   Keeps any resulting triangulated geometry from the decimation process.

Vertex Group
   A vertex group that controls what parts of the mesh are decimated.

Factor
   The amount of influence the *Vertex Group* has on the decimation.


Un-Subdivide
------------

.. figure:: /images/modeling_modifiers_generate_decimate_panel-un-subdivide.png
   :align: right
   :width: 300px

   The Decimate modifier in Un-Subdivide mode.

It can be thought of as the reverse of subdivide.
It attempts to remove edges that were the result of a subdivide operation.
It is intended for meshes with a mainly grid-based topology (without giving uneven geometry).
If additional editing has been done after the subdivide operation, the results may be unexpected.

Iterations
   The number of times to perform the un-subdivide operation.
   Two iterations is the same as one subdivide operation, so you will usually want to use even numbers.


Planar
------

.. figure:: /images/modeling_modifiers_generate_decimate_panel-planar.png
   :align: right
   :width: 300px

   The Decimate modifier in Planar mode.

It reduces details on forms comprised of mainly flat surfaces.

Angle Limit
   Dissolve geometry which form angles (between surfaces) higher than this setting.

Delimit
   Prevent dissolving geometry in certain places.

   Normal
      Does not dissolve edges on the borders of areas where the face normals are reversed.
   Material
      Does not dissolve edges on the borders of where different materials are assigned.
   Seam
      Does not dissolve edges marked as seams.
   Sharp
      Does not dissolve edges marked as sharp.
   UVs
      Does not dissolve edges that are part of a UV map.

All Boundaries
   When enabled, all vertices along the boundaries of faces are dissolved.
   This can give better results when using a high *Angle Limit*.


## Edge Split

.. index:: Modeling Modifiers; Edge Split Modifier
.. _bpy.types.EdgeSplitModifier:

*******************
Edge Split Modifier
*******************

The *Edge Split* modifier splits, duplicates edges within a mesh,
breaking 'links' between faces around those split edges.

The edges to split can be determined from the edge angle (i.e. angle between faces forming that edge),
and/or edges marked as sharp.

Splitting an edge affects vertex normal generation at that edge, making the edge appear sharp.
It can also be used for manual control of the smoothing process,
where the user defines which edges should appear smooth or sharp
(see :ref:`Mesh Smoothing <modeling-meshes-editing-normals-shading>` for other ways to do this).
If desired, both modes can be active at once.

.. note::

   This modifier is kept mostly for historical/compatibility reasons.
   Everything it can do in shading, and much more,
   can now be achieved using :ref:`custom normals <modeling_meshes_normals_custom>`.

   Unless you really need the topology changes it generates, it is not advised to use it in new projects.

.. note::

   Splitting edges can also be :ref:`performed manually <bpy.ops.mesh.edge_split>` in Edit Mode.


Options
=======

.. figure:: /images/modeling_modifiers_generate_edge-split_panel.png
   :align: right
   :width: 300px

   The Edge Split modifier.

Edge Angle
   When enabled, an edge will be split if the angle between its
   two adjacent faces is greater than the *Split Angle*.

   Split Angle
      On 0: all edges are split. On 180: no edges are split.

Sharp Edges
   When enabled, edges will be split if they were :ref:`marked as sharp <bpy.ops.mesh.mark_sharp>`.

.. note::

   :term:`Non-manifold` edges will always be split.


Examples
========

.. list-table::

   * - .. figure:: /images/modeling_modifiers_generate_edge-split_example-1.png

          Flat shading.

     - .. figure:: /images/modeling_modifiers_generate_edge-split_example-2.png

          Smooth shading.

   * - .. figure:: /images/modeling_modifiers_generate_edge-split_example-3.png

          Smooth shading with Edge Split.

     - .. figure:: /images/modeling_modifiers_generate_edge-split_example-4.png

          Smooth shading with Edge Split and Subdivision Surface.


## Geometry Nodes

.. index:: Modeling Modifiers; Geometry Nodes Modifier
.. _bpy.types.NodesModifier:

***********************
Geometry Nodes Modifier
***********************

The *Geometry Nodes* modifier creates a modifier with a node group which defines its functionality.

.. figure:: /images/modeling_modifiers_generate_geometry-nodes_panel.png

   A new Geometry Nodes modifier with a new node group.

This modifier is supported by mesh, curve, text, and volume objects.


Options
=======

Node Group
   A :doc:`Node Group </interface/controls/nodes/groups>` with the geometry input and output.
   Those are respectively what is received and passed to the previous and next modifier in the stack.
   See :doc:`Nodes </modeling/geometry_nodes/index>` for all available nodes.

Inputs
   A list of the node group's inputs which can have unique values even
   if the group is shared among multiple modifiers.

   .. _bpy.ops.object.geometry_nodes_input_attribute_toggle:

   If the input is connected to a :doc:`Field </modeling/geometry_nodes/fields>` socket,
   there will be a toggle to switch between using a single value for the input or
   using an attribute on the input geometry. Using an attribute for input means the
   value can be different for every element.

   The attribute name used by default when using the node group in a modifier for the first
   time is defined in the :doc:`node group inputs panel </interface/controls/nodes/groups>`.

   .. note::

      The :ref:`attribute domain <attribute-domains>` and the used to access the attribute is defined by the
      node the input is connected to.


Output Attributes
-----------------

By connecting a field socket to the group output node,
you can create custom :doc:`Attributes </modeling/geometry_nodes/attributes_reference>`
from a :doc:`Field </modeling/geometry_nodes/fields>` output of any node in the node tree.
The domain of the attribute must be specified in the group node's output properties.
Note, this does not work with :doc:`Instanced Data </modeling/geometry_nodes/instances>`.

The attribute name used by default when using the node group in a modifier for the first
time is defined in the :doc:`node group outputs panel </interface/controls/nodes/groups>`.

This panel is hidden unless output node has attribute sockets.


Manage
------

Bake
^^^^

.. _bpy.types.NodesModifier.simulation_bake_directory:

Bake Path
   Location on disk where the baked data for
   :doc:`Simulation Zones </modeling/geometry_nodes/simulation/simulation_zone>`
   and :doc:`Bake Nodes </modeling/geometry_nodes/geometry/operations/bake>` are stored.

.. seealso::

   :doc:`Geometry Node Baking </modeling/geometry_nodes/baking>`


.. _modifiers-geometry-nodes-named-attributes:

Named Attributes
^^^^^^^^^^^^^^^^

This panel displays information about all custom named attributes used by the node group.
More information is available in the
:ref:`geometry nodes inspection page <bpy.types.SpaceNodeOverlay.show_named_attributes>`.


.. _bpy.ops.object.geometry_nodes_move_to_nodes:

Move to Nodes Operator
======================

Creates a new geometry node tree with the name of the current node tree with ``.wrapper`` appended to the name.
This operation moves all inputs and outputs from the old modifier into a new node group.
In order for this operator to function, there **must** be a Group Input **and** a Group Output
each with a Geometry socket attached to the node group.
This action causes all *Output Attributes* to become *Internal Dependencies* utilizing the
:doc:`/modeling/geometry_nodes/attribute/store_named_attribute`.
All modifier "inputs" will then also become inputs of the newly created node group.

This operator is useful to easily allow a node tree to be reused in other trees
or to mark it as an :term:`Asset` to be reused in other projects.


## Index


############
  Generate
############

.. toctree::
   :maxdepth: 1

   array.rst
   bevel.rst
   booleans.rst
   build.rst
   decimate.rst
   edge_split.rst
   geometry_nodes.rst
   mask.rst
   mesh_to_volume.rst
   mirror.rst
   multiresolution.rst
   remesh.rst
   screw.rst
   skin.rst
   solidify.rst
   subdivision_surface.rst
   triangulate.rst
   volume_to_mesh.rst
   weld.rst
   wireframe.rst


## Mask

.. index:: Modeling Modifiers; Mask Modifier
.. _bpy.types.MaskModifier:

*************
Mask Modifier
*************

The *Mask* modifier allows vertices of an object to be hidden dynamically based on vertex groups.


Options
=======

Mode
   The Mask Modifier can hide parts of a mesh based on two different modes, selectable from this select menu.

   Vertex Group
      Hides all vertices not included in the chosen vertex group.

      .. list-table:: The Mask modifier in Vertex Group mode.

         * - .. figure:: /images/modeling_modifiers_generate_mask_vertex-group.png

           - .. figure:: /images/modeling_modifiers_generate_mask_panel-vertex-group.png

   Armature
      When in Pose Mode,
      vertices belonging to the vertex group associated with the active bone (same names) will be visible.
      Vertices not in that group will be hidden.

      .. list-table:: The Mask modifier in Armature mode.

         * - .. figure:: /images/modeling_modifiers_generate_mask_armature.png

           - .. figure:: /images/modeling_modifiers_generate_mask_panel-armature.png

Smooth
   When using Vertex Group *Mode*, use weights to cut faces at the weight contour.
   This option will result in a mask that has smoother removing the sharp edges along the mask edges.

   .. figure:: /images/modeling_modifiers_generate_mask_vertex-group_smooth.png

Invert
   Normally, vertices belonging to the selected vertex group (or group associated with the active pose bone)
   will be shown. The *Invert* toggle allows you to reverse this behavior, instead only showing vertices
   which do not belong to the vertex group.

Threshold
   Hides vertices with weights less than or equal to this value.


## Mesh To Volume

.. index:: Modeling Modifiers; Mesh to Volume
.. _bpy.types.MeshToVolumeModifier:

***********************
Mesh to Volume Modifier
***********************

.. reference::

   This modifier is only available for :doc:`Volume Objects </modeling/volumes/index>`.

The *Mesh to Volume* modifier uses a mesh to create a new volume grid.
All previously existing volume grids on the volume object are discarded.
So this modifier is usually added to an empty volume object.
The new volume grid is called "density".

.. tip::

   To copy and move the generated volume separately from the mesh object,
   use a :doc:`collection instance </scene_layout/object/properties/instancing/collection>`.


Options
=======

.. figure:: /images/modeling_modifiers_generate_mesh-to-volume_panel.png
   :align: right
   :width: 300px

   The Mesh to Volume modifier.

Object
   The mesh object that determines where the volume data will be generated.

Density
   Makes the generated volume appear denser or less dense when rendering.

Interior Band Width
   The maximum distance of the included voxels to the surface on the inside of the mesh.

Resolution Mode
   Mode for how the voxel size is specified.

   :Voxel Amount:
      This allows setting an approximate number of voxels that will be used to represent mesh along its diagonal.
      When the dimensions of the mesh changes, the voxel size will change as well.
      For final rendering of animations, it's better to specify the voxel size explicitly to avoid artifacts.
   :Voxel Size:
      This allows setting the exact voxel size that will be used.
      This is idea for rendering when the voxel size should not change between frames.


Example
=======

.. figure:: /images/modeling_modifiers_generate_mesh-to-volume_example.png
   :width: 500px

   Converting Suzanne to a volume.


## Mirror

.. index:: Modeling Modifiers; Mirror Modifier
.. _bpy.types.MirrorModifier:

***************
Mirror Modifier
***************

The *Mirror* modifier mirrors a mesh along its local X, Y and/or Z axes, across the :term:`Object Origin`.
It can also use another object as the mirror center, then use that object's local axes instead of its own.


Options
=======

.. figure:: /images/modeling_modifiers_generate_mirror_panel.png
   :align: right
   :width: 300px

   The Mirror modifier.

Axis
   The X, Y, Z axis along which to mirror, i.e. the axis perpendicular to the mirror plane of symmetry.

   To understand how the axis applies to the mirror direction, if you were to mirror on the X axis,
   the positive X values of the original mesh would become the negative X values on the mirrored side.

   You can select more than one of these axes. And will then get more mirrored copies.
   With one axis you get a single mirror, with two axes four mirrors, and with all three axes eight mirrors.

Bisect
   If the mesh is already on both sides of the mirror plane, it is cut by that plane,
   and only one side (the "positive" one by default) is kept to perform the mirror process.

Flip
   When *Bisect* is enabled on an axis, you can use this setting to switch the side kept and mirrored
   (i.e. when it is enabled, the "negative" side will be kept, instead of the "positive" one).

Mirror Object
   An :ref:`Object Selector <ui-data-id>` to select an object (usually an empty),
   which position and rotation will be used to define mirror planes
   (instead of using the ones from the modified object).

   You can animate it to move the mirror axis.

Clipping
   Prevents vertices from moving through the mirror plane(s) when you transform them in Edit Mode.

   If it is enabled but vertices are beyond the mirror plane and outside of the *Merge Distance*,
   the vertices will not be merged. But as soon as the vertices are within *Merge Distance*
   they are snapped together and cannot be moved beyond the mirror plane.

   .. note::

      Vertices on the mirror plane will be unable to move away from the mirror plane
      as long as *Clipping* is enabled.
      You must disable it to be able to move the vertices along the mirror axis again.

Merge
   Where a vertex is in the same place (within the *Merge Distance*) as its mirror
   it will be merged with the mirrored vertex.

   Merge Distance
      The maximum distance between a vertex and its mirror copy at which they are merged together
      (being snapped on the mirror plane). Needs *Merge* to be enabled.

Bisect Distance
   Distance from the bisect plane within which vertices are removed.


Data
----

Flip UV
   With this option you can mirror the UV texture coordinates across the middle of the image.

   E.g. if you have a vertex with UV coordinates of (0.3, 0.9),
   its mirror copy will have UV coordinates of (0.7, 0.1).

UV Offsets
   Amount to shift mirrored UVs on the U/V axes.

   It's useful for baking (as overlapping UVs can cause artifacts to appear in the baked map),
   so the UVs can be moved outside the image and not used for baking, but still be used for display.

Vertex Groups
   Try to mirror existing vertex groups, with the following specific prerequisites:

   - The vertex groups you want to mirror must be named following the usual left/right pattern
     (i.e. with suffixes like ".R", ".right", ".L", etc.).
   - The mirror side vertex group must already exist (it will not be created automatically).
     It must also be completely empty (no vertices assigned to it).

Flip UDIM
   Mirror the texture coordinates around each tile center.


Hints
=====

Many modeling tasks involve creating objects that are symmetrical.
This modifier offers a simple and efficient way to do this, with real-time update of the mirror as you edit it.
Once your modeling is completed you can either click *Apply* to make a real version of your mesh,
or leave it as-is for future editing.


Accurately Positioning the Mirror Plane
---------------------------------------

To apply a *Mirror* modifier, it is common to have to move the object's origin onto
the edge or face that is to be the axis for mirroring.
This can be tricky when attempted visually.

A good technique to achieve an exact position is
to select the edge, then :doc:`snap </editors/3dview/controls/snapping>` *Cursor to Selection*.
This will position the 3D Cursor in the center of the edge.
Finally, use the :ref:`Set Origin <bpy.ops.object.origin_set>` menu, and select *Origin to 3D Cursor*.
This will move the object's origin (and thus, the mirror plane) to where the 3D cursor is located,
and the mirroring will be exact.

An alternative is to use an empty as a *Mirror Object* that you move to the correct position.


## Multiresolution

.. index:: Modeling Modifiers; Multiresolution Modifier
.. _bpy.types.MultiresModifier:

************************
Multiresolution Modifier
************************

The *Multiresolution* modifier (often shortened to "Multires")
gives you the ability to subdivide a mesh similarly
to the :doc:`Subdivision Surface </modeling/modifiers/generate/subdivision_surface>` modifier,
but also allows you to edit the new subdivision levels in
:doc:`Sculpt Mode </sculpt_paint/sculpting/introduction/adaptive>`.

.. note::

   *Multiresolution* is the only modifier that cannot be repositioned in the stack after any modifier that will
   change geometry or other object data (i.e. all *Generate*, some *Modify* and some *Simulate* modifiers
   cannot come before the *Multiresolution*).

Deform modifiers will be applied onto the Multires subdivision levels instead of the base mesh,
if they come after the Multires.

.. tip::

   This is especially useful for re-projecting details from another sculpt
   with a :doc:`Shrinkwrap modifier </modeling/modifiers/deform/shrinkwrap>`. For the best result make sure to set the
   wrap method to *Project*, snap mode to *Above Surface* and enable *Negative*.


Options
=======

.. figure:: /images/modeling_modifiers_generate_multiresolution_panel.png
   :align: right
   :width: 300px

   The Multiresolution modifier.

Levels Viewport
   Set the level of subdivisions to show in the viewport.
Sculpt
   Set the level of subdivisions to use specifically in Sculpt Mode.
   While in Sculpt mode use :kbd:`Alt-1` to decrease the level or :kbd:`Alt-2` to increase.
Render
   Set the level of subdivisions to show when rendering.

Sculpt Base Mesh
   Deform the unsubdivided base mesh instead of the higher levels.
   Meanwhile the set level will be previewed. This allows you to
   make much broader changes in visual context to higher sculpted details
   without creating surface noise and artifacts.

Optimal Display
   Only display the edges of the original geometry.
   So when rendering the wireframe of this object, the wires of the subdivided edges will be skipped.


Subdivisions
------------

.. _bpy.ops.object.multires_subdivide:

Subdivide
   Creates a smooth level of subdivision
   (using the default Catmull-Clark algorithm).

Simple
   Creates a level of subdivision with un-smoothed base mesh edges
   (using a simple interpolation by subdividing edges without any smoothing).
Linear
   Creates a completely un-smoothed level of subdivision
   (using linear interpolation of the current sculpted displacement).

.. _bpy.ops.object.multires_unsubdivide:

Unsubdivide
   Rebuild a lower subdivision level of the current base mesh.

.. _bpy.ops.object.multires_higher_levels_delete:

Delete Higher
   Deletes all subdivision levels that are higher than the current one.


Shape
-----

.. _bpy.ops.object.multires_reshape:

Reshape
   Copy the shape of another object onto the multires levels by copying its vertex coordinates.

   To use it, first select a different mesh object with matching topology and vertex indices,
   then :kbd:`Shift` select the object you wish to copy vertex coordinates to, and click *Reshape*.

.. _bpy.ops.object.multires_base_apply:

Apply Base
   Modifies the original unsubdivided mesh to match the form of the subdivided mesh.


Generate
--------

.. _bpy.ops.object.multires_rebuild_subdiv:

Rebuild Subdivisions
   Rebuilds all possible subdivisions levels to generate a lower resolution base mesh.
   This is used to create an optimized multiresolution version of a preexisting sculpt.
   This option is only available when no subdivision level have been created through the modifier.

.. _bpy.ops.object.multires_external_save:

Save External
   Saves displacements to an external ``.btx`` file.


Advanced
--------

Quality
   How precisely the vertices are positioned (relatively to their theoretical position),
   can be lowered to get a better performance when working on high-poly meshes.

UV Smooth
   How to handle UVs during subdivision.

   :None: UVs remain unchanged.
   :Keep Corners: UV islands are smoothed, but their boundary remain unchanged.
   :Keep Corners, Junctions:
      UVs are smoothed, corners on discontinuous boundary and junctions of three or more regions are kept sharp.
   :Keep Corners, Junctions, Concave:
      UVs are smoothed, corners on discontinuous boundary,
      junctions of three or more regions and darts and concave corners are kept sharp.
   :Keep Boundaries: UVs are smoothed, boundaries are kept sharp.
   :All: UVs and their boundaries are smoothed.

Boundary Smooth
   Controls how open boundaries (and corners) are smoothed.

   :All: Smooth boundaries, including corners.
   :Keep Corners: Smooth boundaries, but corners are kept sharp.

Use Creases
   Use the :ref:`modifiers-generate-subsurf-creases` values stored in edges to control how smooth they are made.

Use Custom Normals
   Interpolates existing :ref:`modeling_meshes_normals_custom` of the resulting mesh.


## Remesh

.. index:: Modeling Modifiers; Remesh Modifier
.. _bpy.types.RemeshModifier:

***************
Remesh Modifier
***************

The *Remesh* modifier is a tool for generating new mesh topology.
The output follows the surface curvature of the input, but its topology contains only quads.


Options
=======

.. figure:: /images/modeling_modifiers_generate_remesh_panel.png
   :align: right
   :width: 300px

   The Remesh modifier.

Mode
   There are three basic modes available in the *Remesh* modifier.
   The output topology is almost identical between the three modes, what changes is the smoothing.

   Blocks
      There is no smoothing at all.
   Smooth
      Output a smooth surface.
   Sharp
      Similar to *Smooth*, but preserves sharp edges and corners.

      Sharpness
         Higher values produce edges more similar to the input, while lower values filter out noise.
   Voxel
      Uses an OpenVDB to generate a new manifold mesh from the current geometry
      while trying to preserve the mesh's original volume.

      Adaptivity
         Reduces the final face count by simplifying geometry where detail is not needed.
         This introduce triangulation to faces that do not need as much detail.
      Smooth Shading
         Outputs faces with :ref:`Smooth Shading <bpy.ops.object.shade_smooth>` instead of flat shading.

Octree Depth
   Sets the resolution of the output. Low values will generate larger faces relative to the input,
   higher values will generate a denser output.

Scale
   The result can be tweaked further by this, lower values effectively decrease the output resolution.

Remove Disconnected
   Filter out small disconnected pieces of the output.

   Thin parts of the input mesh can become loose, and generate small isolated bits of mesh.
   This option will remove those.

   Threshold
      Use this to control how small a disconnected component must be to be removed.

Smooth Shading
   Output faces with smooth shading rather than flat shading.
   The smooth/flat shading of the input faces is not preserved.

.. note::

   The input mesh should have some thickness to it. If the input is completely flat,
   add a :doc:`Solidify Modifier </modeling/modifiers/generate/solidify>` above the *Remesh* one.


Examples
========

.. list-table::

   * - .. figure:: /images/modeling_modifiers_generate_remesh_example-none.png
          :width: 320px

          Unmodified mesh.

     - .. figure:: /images/modeling_modifiers_generate_remesh_example-blocks-depth-3.png
          :width: 320px

          Blocks mode with Octree Depth 3.

     - .. figure:: /images/modeling_modifiers_generate_remesh_example-smooth-depth-3.png
          :width: 320px

          Smooth mode with Octree Depth 3.

   * - .. figure:: /images/modeling_modifiers_generate_remesh_example-sharp-depth-2.png
          :width: 320px

          Sharp mode with Octree Depth 2.

     - .. figure:: /images/modeling_modifiers_generate_remesh_example-sharp-depth-3.png
          :width: 320px

          Sharp mode with Octree Depth 3.

     - .. figure:: /images/modeling_modifiers_generate_remesh_example-sharp-depth-4.png
          :width: 320px

          Sharp mode with Octree Depth 4.

.. figure:: /images/modeling_modifiers_generate_remesh_example-text-topology.png
   :width: 520px

   The Remesh Modifier applied to a text to improve its topology.


`Animated Example <https://www.youtube.com/watch?v=Mh-gUnS2c0Y>`__


## Screw

.. index:: Modeling Modifiers; Screw Modifier
.. _bpy.types.ScrewModifier:

**************
Screw Modifier
**************

The *Screw* modifier is similar to the :doc:`Screw </modeling/meshes/editing/edge/screw>` tool
in the Toolbar, in that it takes a profile object, a mesh or a curve, to create a helix-like shape.

.. figure:: /images/modeling_modifiers_generate_screw_align.png
   :width: 540px

   Properly aligning the profile object is important.

The profile should be properly aligned to the cardinal direction of the object rather than to the screw axis.


Options
=======

.. figure:: /images/modeling_modifiers_generate_screw_panel.png
   :align: right
   :width: 300px

   The Screw modifier.

Angle
   Degrees for a single helix revolution.

Screw
   The height of one helix iteration.

Iterations
   Number of revolutions.

Axis
   The axis along which the helix will be built.

Axis Object
   The name of an object to define the axis direction.

   Object Screw
      Use the distance from the *Axis Object* to define the height of one helix iteration.

Steps Viewport
   Number of steps used for a single revolution displayed in the 3D Viewport.
Render
   As above, but used during render time. Increase to improve quality.

Merge
   Merge vertices that lie on the axis of rotation.
   Use this to close off end points with a triangle fan.

   Merge Distance
      Vertices under this distance to the axis are merged.

Stretch UVs
   Stretch the UV coordinates from (0.0 to 1.0) when UVs are present.


Normals
-------

Smooth Shading
   Output faces with smooth shading rather than flat shading.
   The smooth/flat shading of the input geometry is not preserved.

Calculate Order
   Order of edges is calculated to avoid problems with normals and shading. Only needed for meshes, not curves.

Flip
   Flip normals direction.


## Skin

.. index:: Modeling Modifiers; Skin Modifier
.. _bpy.types.SkinModifier:

*************
Skin Modifier
*************

The *Skin* modifier uses vertices and edges to create a skinned surface,
using a per-vertex radius to better define the shape.
The output is mostly quads, although some triangles will appear around intersections.

It is a quick way to generate base meshes for sculpting and/or smooth organic shapes with
arbitrary topology.

.. note::

   Faces in the original geometry are ignored.


Options
=======

.. figure:: /images/modeling_modifiers_generate_skin_panel.png
   :align: right
   :width: 300px

   The Skin modifier.

Branch Smoothing
   A branch point is a vertex with three or more connected edges.
   These areas tend to produce more complicated topology, some of which may overlap.
   This setting relaxes the surface around these points,
   with the side effect of shrinking it.

Symmetry
   These checkboxes are used to keep the output topology symmetrical in their respective axes.
   In other words, using it avoids merging triangles across an axis unless the triangles form a symmetric quad.

   .. note::

      They do not add geometry flipped across an axis.
      For that, the :doc:`Mirror </modeling/modifiers/generate/mirror>` modifier should be used,
      typically placed above the Skin one.

Smooth Shading
   Output faces with smooth shading rather than flat shading.
   The smooth/flat shading of the input geometry is not preserved.

Create Armature
   Create an armature on top of the object. Each edge becomes a bone.

   .. note::

      If the root vertex has more than one adjacent edge,
      an extra bone will be created to serve as the root.

   This tool does the following:

   #. A new armature object is added with bones matching the input mesh.
      The active selection is switched to the new armature.
   #. Weight groups are added to the input mesh. The Skin modifier propagates these weights to the output as well.
   #. An :doc:`Armature </modeling/modifiers/deform/armature>` modifier is added directly below the Skin one.
      Note that the Armature modifier is being applied after
      the Skin one because it should only deform the output,
      whereas if it were above, it might change the resulting topology.

Add Skin Data
   This modifier uses a :ref:`custom set of data <modeling-modifiers-generate-skin-data>` in the mesh,
   that is generated automatically when you add the modifier the first time.

   However, you may remove that data, or loose it some way or the other. That operator will generate it again.

Mark/Clear Loose
   By default, a branch vertex (vertex with three or more connected edges)
   will generate extra edge loops along adjacent edges in order to keep the output tight.
   Branches can be made loose by clicking *Mark Loose*, which will allow the output to stretch between
   all adjacent vertices. This can be disabled again by clicking *Clear Loose*.

Mark Root
   Marking a vertex as root causes that vertex to be used for calculating rotations for connected limbs.
   Root vertices also affect the armature output, they will be used as the origin for the root bones.

   .. todo
      Not true anymore:
      Roots are shown in the *3D Viewport* with a red dashed circle around the vertex.

   Each set of connected vertices should have one root node
   (one is selected by default if you do not assign any manually).
   *Mark Root* enforces the one-root per set rule, so it is not necessary to manually unmark roots.

Equalize Radii
   Makes the skin radii of selected vertices equal on each axis.


.. _modeling-modifiers-generate-skin-data:

Skin Mesh Data
==============

That modifier needs a set of specific data in the original mesh to work properly.
This data allows you to define the root vertices of each tree, which ones are loose,
and the size (radius) of the skin at each vertex. The radii of input vertices can be individually
scaled in Edit Mode with the :doc:`/modeling/meshes/editing/mesh/transform/skin_resize`.


Examples
========

.. _fig-modifier-skin-creature:

.. figure:: /images/modeling_modifiers_generate_skin_example.png

   Simple creature, made with only the Skin and Subdivision Surface modifiers.


External Links
==============

- `Skin Modifier Development at Blender Nation
  <https://www.blendernation.com/2011/03/11/skin-modifier-development/>`__ --
  An early demonstration of the Skin Modifier by Nicholas Bishop (March 2011).
- Ji, Zhongping; Liu, Ligang; Wang, Yigang (2010).
  B-Mesh: A Fast Modeling System for Base Meshes of 3D Articulated Shapes,
  Computer Graphics Forum 29(7), pp. 2169-2178. -- The work this modifier is based on
  (`DOI 10.1111/j.1467-8659.2010.01805.x <https://doi.org/10.1111/j.1467-8659.2010.01805.x>`__).
- `Related thread on Blender artists <https://blenderartists.org/t/499364>`__.


## Solidify

.. index:: Modeling Modifiers; Solidify Modifier
.. _bpy.types.SolidifyModifier:

*****************
Solidify Modifier
*****************

The *Solidify* modifier takes the surface of any mesh and adds depth, thickness to it.


Options
=======

.. list-table::

   * - .. figure:: /images/modeling_modifiers_generate_solidify_panel-simple.png

          The Solidify modifier in simple mode.

     - .. figure:: /images/modeling_modifiers_generate_solidify_panel-complex.png

          The Solidify modifier in complex mode.

Mode
   Simple
      This is the default solidify algorithm, which simply extrudes the geometry.
      This algorithm does not work on geometry where edges have more than two adjacent faces.

      .. important::

         If the normals of adjacent faces don't point into the same general direction, simple mode
         will not be able to solidify the boundary between those. This happens if the normals
         are not recalculated or for example on one-sided surfaces like a Möbius strip.

   Complex
      This is a solidify algorithm which can handle every geometric situation
      to guarantee a manifold output geometry. This algorithm is able to
      solidify shapes like Möbius strips, Klein bottles, architectural wall layouts
      and many more which the *Simple Mode* isn't able to do.
      If the special cases are not present it is recommended to choose *Simple*
      because the extra logic makes this algorithm much slower.

      .. note::

         There are no options for crease in the Modifier tab because crease is handled in a dynamic way.
         The modifier will transfer the creases of the original mesh in a smart way to the output mesh to
         work with the :doc:`Subdivision Surface </modeling/modifiers/generate/subdivision_surface>` modifier.

Thickness Mode :guilabel:`Complex Mode`
   Choose the kind of thickness handling (thickness solver).

   .. figure:: /images/modeling_modifiers_generate_solidify_thickness-mode.png

      Different thickness options on a non-manifold mesh.

   Fixed
      This is similar to *Simple Mode* without *Even Thickness*.
      The new vertices are always in a fixed distance to the old ones.
   Even
      This is similar to *Simple Mode* with *Even Thickness* and *High Quality Normals*.
      It adjusts for sharp corners, but may not always work when more than three faces come together.
   Constraints
      This is a more advanced model to try to always get the optimal thickness everywhere.
      For up to three faces it is always guaranteed to find an optimal solution.

Boundary :guilabel:`Complex Mode`
   Choose the kind of boundary that suits the model the most.

   .. figure:: /images/modeling_modifiers_generate_solidify_boundary-shape.png

      Different boundary options with a matCap.

   None
      No boundary fix is applied. Results are stable.
   Round
      Adjusts the boundary for an opening to face inwards (like a hole in an egg).
   Flat
      Adjusts the boundary of a planar opening to be a flat (like a cut sphere).

Thickness
   The depth to be solidified.

   .. important::

      The modifier thickness is calculated using local vertex coordinates.
      If the object has a non-uniform scale, the thickness will vary on different sides of the object.

      To fix this, either :ref:`Apply <bpy.ops.object.transform_apply>`
      or :ref:`Clear <bpy.ops.object.*clear>` the scale.

Offset
   A value between (-1 to 1) to locate the solidified output inside or outside the original mesh.
   The inside and outside is determined by the face normals.
   Set to 0.0, the solidified output will be centered on the original mesh.

Even Thickness :guilabel:`Simple Mode`
   Maintain thickness by adjusting for sharp corners.
   Sometimes improves quality but also increases computation time.

Merge Threshold :guilabel:`Complex Mode`
   Distance within which degenerated geometry is merged.

Rim
   Fill
      Fills the gap between the inner and outer edges.
   Only Rim
      In *Simple Mode*: Will not extrude surfaces parallel to the original one,
      but instead will only add the perpendicular rim.

      In *Complex Mode*: Will only leave the generated perpendicular rim.

   .. note::

      *Fill* and *Only Rim* only make a difference on :term:`Non-manifold` objects,
      since the rims are generated from the borders of the original geometry.

Vertex Group
   The weights of the selected vertex group are multiplied onto the *Thickness*,
   so vertices with lower weights will be less thick. The vertices which are not part
   of the vertex group will be used as if their weight was zero.

   Invert
      Reverses the vertex group weights, so that the used weight is one minus the actual weight.

   Factor
      How much the vertex weights are taken into account.

      - On 0.0 , vertices with zero weight will have no thickness at all.
      - On 0.5 , vertices with zero weight will be half as thick as those with full weight.
      - On 1.0 , the weights are ignored and the *Thickness* value is used for every vertex.

   Flat Faces :guilabel:`Complex Mode`
      Use the minimal vertex weight assigned to the vertices of a face to make sure that
      new faces stay parallel to their original ones. This is slow, so disable it when it is not needed.

   .. note::

      If the final thickness of a vertex is zero, it will still be solidified.
      Therefore creating duplicate geometry, which sometimes needs extra care.


Normals
-------

Flip Normals
   Reverse the normals of all geometry (both the inner and outer surfaces).

High Quality Normals :guilabel:`Simple Mode`
   Normals are calculated to produce a more even thickness.
   Sometimes improves quality but also increases computation time.


Materials
---------

Material Offset
   Choose a different material slot index to use for the new geometry.
   This is applied as an offset from the original material of the face from which it was solidified.

   - A value of 0 means it will use the same material.
   - A value of 1 means it will use the material immediately below the original material.
   - A value of -2 means the material two positions above the original material will be used.

   These are clamped to the top-most and bottom-most material slots.

Rim
   Similarly, you can give another material to the rim faces.


Edge Data
---------

Inner :guilabel:`Simple Mode`
   Set a :ref:`crease <modeling-edges-crease-subdivision>` to the inner edges.
Outer :guilabel:`Simple Mode`
   Set a :ref:`crease <modeling-edges-crease-subdivision>` to the outer edges.
Rim :guilabel:`Simple Mode`
   Set a :ref:`crease <modeling-edges-crease-subdivision>` to the rim.
Bevel Convex
   Edge :ref:`bevel weight <modeling-edges-bevel-weight>` to be added to outside edges.

.. figure:: /images/modeling_modifiers_generate_solidify_rims.png
   :width: 250px

   Edges which will get creases marked.


Thickness Clamp
---------------

Clamp
   A value between (0 to 2) to clamp offsets to avoid self-intersection.
   The amount is determined by the length of the shortest adjacent edge.

   .. figure:: /images/modeling_modifiers_generate_solidify_clamp.png

      Clamp Offset.

   Angle Clamp
      If enabled clamping will also consider angles in the geometry, not only lengths.


Output Vertex Groups
--------------------

Shell
   Vertex group that the generated shell geometry will be weighted to.
   This allows you to use other modifiers to only affect the shell geometry
   by using a that modifier's vertex group influence control.

Rim
   Same as *Shell Vertex Group*, but for the generated rim geometry.


Known Limitations
=================

Even Thickness
--------------

Solidify thickness is an approximation.
While *Even Thickness* and *High Quality Normals* should yield good results,
the final wall thickness is not guaranteed and may vary depending on the mesh topology.
Especially for vertices with more than three adjacent faces.

In order to maintain a precise wall thickness in every case, we would need to add/remove faces on
the offset shell, something this modifier does not do since this would add a lot of complexity.
The best option to preserve wall thickness is complex mode with constraints thickness mode,
but it is also not guaranteed to work perfect in every case.


## Subdivision Surface

.. index:: Modeling Modifiers; Subdivision Surface Modifier
.. _bpy.types.SubsurfModifier:

****************************
Subdivision Surface Modifier
****************************

The *Subdivision Surface* modifier (often shorten to "Subdiv")
is used to split the faces of a mesh into smaller faces, giving it a smooth appearance.
It enables you to create complex smooth surfaces while modeling simple, low-vertex meshes.
It avoids the need to save and maintain huge amounts of data,
and gives a smooth "organic" look to the object.

As with any modifier, order of execution (position in the :ref:`modifier stack <modifier-stack>`)
has an important bearing on the results.

Keep in mind that this is a different operation than its companion,
:ref:`Smooth Shading <modeling-meshes-editing-normals-shading>`.
You can see the difference between the two in the grid image below.

.. figure:: /images/modeling_modifiers_generate_subdivision-surface_grid.png

   Subdivision levels 0 to 3, without and with Smooth Shading.

.. tip::

   The *Subdivision Surface* modifier does not allow you to edit the new subdivided geometry without applying it,
   but the :doc:`Multiresolution </modeling/modifiers/generate/multiresolution>` modifier does (in Sculpt Mode).

.. note::

   This modifier uses
   the `OpenSubdiv library <https://graphics.pixar.com/opensubdiv/docs/intro.html>`__ as a backend.


Options
=======

.. figure:: /images/modeling_modifiers_generate_subdivision-surface_panel.png
   :align: right
   :width: 300px

   The Subdivision Surface modifier.

Catmull-Clark
   Subdivides and smooths the surfaces to create a more pleasant looking mesh.
   According to its `Wikipedia page <https://en.wikipedia.org/wiki/Catmull%E2%80%93Clark_subdivision_surface>`__,
   the "arbitrary-looking formula was chosen by Catmull and Clark based on the aesthetic appearance of
   the resulting surfaces rather than on a mathematical derivation."
Simple
   Only subdivides the surfaces, this often does not provide any smoothing
   unless the surface is :term:`non-coplanar <Coplanar>`
   (the same as the :ref:`Subdivide <bpy.ops.mesh.subdivide>` operator, in Edit Mode).
   To work around this behavior for non-coplanar geometry,
   :doc:`triangulate </modeling/modifiers/generate/triangulate>` to ensure all geometry is coplanar.

   Simple mode can be used, for example, to increase the base mesh resolution when using displacement maps.

Levels Viewport, Render
   The number of subdivision levels shown in the 3D Viewport or the final render.

   .. warning::

      Higher levels of subdivisions results in more vertices, which means higher memory consumption
      (both system RAM, and video memory for display).
      This can cause Blender to hang or crash if not enough memory is available.

   .. tip::

      The right combination of these settings will allow you to keep a fast and lightweight approximation of
      your model when interacting with it in the 3D Viewport, but use a higher quality version when rendering.

      Be careful not to set the *Viewport* subdivisions higher than the *Render* subdivisions,
      this would mean that the quality in the 3D Viewport will be higher than the rendered.

Optimal Display
   When rendering the wireframe of this object, the wires of the new subdivided edges will be skipped
   (only displays the edges of the original geometry).


Advanced
--------

Use Limit Surface
   Places vertices at the surface that would be produced with infinite
   levels of subdivision (smoothest possible shape).

Quality
   When *Use Limit Surface* is enabled this property controls
   how precisely vertices are positioned on the limit surface
   (relatively to their theoretical position of an infinitely subdivided mesh).
   It can be lowered to get a better performance.

   Using higher values does not necessarily mean real improvement in quality,
   ideal results might be reached well before the maximum *Quality* value.

   .. note::

      This value can affect the accuracy of :ref:`Edge Creases <modifiers-generate-subsurf-creases>`;
      using a higher *Quality* value will allow for a wider range of crease values to work accurately.

UV Smooth
   Controls how subdivision smoothing is applied to UVs.

   :None: UVs remain unchanged.
   :Keep Corners: UV islands are smoothed, but their boundary remain unchanged.
   :Keep Corners, Junctions:
      UVs are smoothed, corners on discontinuous boundary and junctions of three or more regions are kept sharp.
   :Keep Corners, Junctions, Concave:
      UVs are smoothed, corners on discontinuous boundary,
      junctions of three or more regions and darts and concave corners are kept sharp.
   :Keep Boundaries: UVs are smoothed, boundaries are kept sharp.
   :All: UVs and their boundaries are smoothed.

Boundary Smooth
   Controls how open boundaries (and corners) are smoothed.

   :All: Smooth boundaries, including corners.
   :Keep Corners: Smooth boundaries, but corners are kept sharp.

Use Creases
   Use the :ref:`modifiers-generate-subsurf-creases` values stored in edges to control how smooth they are made.

Use Custom Normals
   Interpolates existing :ref:`modeling_meshes_normals_custom` of the resulting mesh.
   Otherwise, new faces will have the overall normal orientation of that original face.


Keyboard Shortcuts
==================

To quickly add a *Subdivision Surface* modifier to one or more objects, select the object(s) and press :kbd:`Ctrl-1`.
That will add a Subdivision Surface modifier with *Viewport* subdivisions set to 1.
You can use other numbers too, such as :kbd:`Ctrl-2`, :kbd:`Ctrl-3`, etc,
to add a modifier with that number of subdivisions.
Adding a *Subdivision Surface* modifier in this fashion will not modify the *Render* subdivisions.

If an object already has a *Subdivision Surface* modifier,
doing this will simply change its subdivision level instead of adding another modifier.


Control
=======

Catmull-Clark subdivision rounds off edges, and often this is not what you want.
There are several solutions that allow you to control the subdivision.


.. _modifiers-generate-subsurf-creases:

Weighted Edge Creases
---------------------

Weighted edge creases for subdivision surfaces allows you to change the way
the *Subdivision Surface* modifier subdivides the geometry to give the edges a smooth or sharp appearance.

.. figure:: /images/modeling_modifiers_generate_subdivision-surface_withcrease.png

   A subdivided cube with creased edges.

The crease weight of selected edges can be changed in the *Transform* panel, Sidebar of the 3D Viewport.
The scale-like dedicated tool :kbd:`Shift-E` can also be used to adjust the crease weight.
A higher value makes the edge "stronger" and more resistant to the smoothing effect of subdivision surfaces.


Edge Loops
----------

.. figure:: /images/modeling_modifiers_generate_subdivision-surface_cube-with-edge-loops.png

   Subdivision Level 2 cube, the same with an extra Edge Loop, and the same with six extra Edge Loops.

The *Subdivision Surface* modifier demonstrates why good, clean topology is so important.
As you can see in the figure, it has a drastic effect on a default cube.
Until you add in additional loops (with e.g. :ref:`Loop Cut and Slide <bpy.ops.mesh.loopcut_slide>`),
the shape is almost unrecognizable as a cube.

A mesh with deliberate topology has good placement of edge loops, which allow the placement of more loops
(or their removal) to control the sharpness/smoothness of the resultant mesh.


Known Limitations
=================

Non-Contiguous Normals
----------------------

Abrupt normal changes will prevent portions of the mesh from producing a smooth subdivision.
Instead, these portions with non-contiguous normals will be subdivided using the "Simple" subdivision method.

.. list-table::

   * - .. figure:: /images/modeling_modifiers_generate_subdivision-surface_normal-orientation-1.png
          :width: 320px

          Comparison of good normals and bad normals.

     - .. figure:: /images/modeling_modifiers_generate_subdivision-surface_normal-orientation-2.png
          :width: 320px

          Side view of image on the left.

A quick way to fix this is to :doc:`Recalculate Normals </modeling/meshes/editing/mesh/normals>`.
If this does not work you may have to :doc:`manually flip the normals </modeling/meshes/editing/mesh/normals>`.


## Triangulate

.. index:: Modeling Modifiers; Triangulate Modifier
.. _bpy.types.TriangulateModifier:

********************
Triangulate Modifier
********************

The *Triangulate* modifier converts all faces in a mesh (quads and n-gons) to triangular faces.
It fulfills the exact same function as the :ref:`Triangulate <bpy.ops.mesh.quads_convert_to_tris>` tool in Edit Mode.

.. list-table::

   * - .. figure:: /images/modeling_modifiers_generate_triangulate_before.png
          :width: 320px

          Mesh before Triangulate modifier.

     - .. figure:: /images/modeling_modifiers_generate_triangulate_after.png
          :width: 320px

          Mesh after Triangulate modifier.


Options
=======

.. figure:: /images/modeling_modifiers_generate_triangulate_panel.png
   :align: right
   :width: 300px

   The Triangulate modifier.

Quad Method
   Beauty
      Split the quads in nice triangles, slower method.
   Fixed
      Split the quads on their 1st and 3rd vertices.
   Fixed Alternate
      Split the quads on their 2nd and 4th vertices.
   Shortest Diagonal
      Split the quads along their shortest diagonal.
   Longest Diagonal
      Split the quads along their longest diagonal. This is the preferred mode for cloth simulations.

N-gon Method
   Beauty
      Arrange the new triangles nicely, slower method.
   Clip
      Splits n-gons using an ear-clipping algorithm
      (the same method of tessellation used for viewport display).

Minimum Vertices
   Minimum number of vertices a face must have to be triangulated.
   For example, setting this value to 5, will prevent triangulation of :term:`Quads <Quad>`
   and only triangulate :term:`N-gons <N-gon>`.

Keep Normals
   When using :ref:`custom normals <modeling_meshes_normals_custom>`,
   try to preserve the same shading as before triangulation.


## Volume To Mesh

.. index:: Modeling Modifiers; Volume to Mesh
.. _bpy.types.VolumeToMeshModifier:

***********************
Volume to Mesh Modifier
***********************

This modifier is the inverse of the *Mesh to Volume* modifier.
It takes an existing volume object and converts one of its grids to a mesh.
Only scalar grids (such as the density grid) can be converted.

.. tip::

   To copy and move the generated mesh separately from the volume object,
   use a :doc:`collection instance </scene_layout/object/properties/instancing/collection>`.


Options
=======

.. figure:: /images/modeling_modifiers_generate_volume-to-mesh_panel.png
   :align: right
   :width: 300px

   The Volume to Mesh modifier.

Object
   The source volume object.

Grid Name
   The name of the grid that will be converted.
   This has to be a scalar grid.

Resolution Mode
   Mode for how the resolution of the final mesh is controlled.

   Grid
      This makes the resolution dependent on the resolution of the grid that is converted.
      Higher resolution grids result in a higher resolution mesh.
      In many cases, that is the most efficient mode.

   Voxel Amount
      Specifies the approximate resolution of the final mesh.
      The voxel size is adapted to the size of the entire volume.

   Voxel Size
      Use a fixed resolution that does not change when the volume changes.

Threshold
   Voxels with a larger value are considered to be inside the mesh and all other voxels outside.
   The mesh will be generated on the boundary of inside and outside voxels.
   This is sometimes also called the "iso value".

Adaptivity
   This is similar to decimating the final to reduce resolution where it is not needed.

Smooth Shading
   Enables smooth shading on the generated mesh.


Example
=======

.. figure:: /images/modeling_modifiers_generate_volume-to-mesh_example.png
   :width: 500px

   Converting a cloud-shaped volume to a mesh.


## Weld

.. index:: Modeling Modifiers; Weld Modifier
.. _bpy.types.WeldModifier:

*************
Weld Modifier
*************

The *Weld* modifier looks for groups of vertices within a threshold and merges them,
collapsing the surrounding geometry.


Options
=======

.. figure:: /images/modeling_modifiers_generate_weld_panel_connected.png
   :align: center
   :width: 300px

   The Weld modifier.

Mode
   Method for choosing which vertices are merged.

   :All: Merge includes all geometry including loose parts.
   :Connected: Merge only includes attached geometry i.e. the modifier will not merge loose parts together.

Distance
   Maximum distance that the vertices must have each other to be merged.

Only Loose Edges :guilabel:`Connected Mode`
   Only collapse short edges which are not adjacent to any face.
   This is useful for example to stitch the seams used in cloth simulations.

Vertex Group
   When the *Vertex Group* option is selected, only vertices with weight above zero will be affected by the modifier.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be merged by the modifier.

      The setting reverses the weight values of the group.


## Wireframe

.. index:: Modeling Modifiers; Wireframe Modifier
.. _bpy.types.WireframeModifier:

******************
Wireframe Modifier
******************

The *Wireframe* modifier transforms a mesh into a wireframe by iterating over its
faces, collecting all edges and turning those edges into four-sided polygons.
Be aware of the fact that your mesh needs to have faces to be wireframed.
You can define the thickness, the material and several other parameters of the generated
wireframe dynamically via the given modifier options.


Options
=======

.. figure:: /images/modeling_modifiers_generate_wireframe_panel.png
   :align: right
   :width: 300px

   The Wireframe modifier.

Thickness
   The depth or size of the wireframes.

Offset
   A value between (-1 to 1) to change whether the wireframes are
   generated inside or outside of the original mesh.
   Set to zero, *Offset* will center the wireframes around the original edges.

Boundary
   Creates wireframes on mesh island boundaries.
Replace Original
   If this option is enabled, the original mesh is replaced by the generated wireframe.
   If not, the wireframe is generated on top of it.

Thickness
   Even
      Maintain thickness by adjusting for sharp corners.
      Sometimes improves quality but also increases computation time.
   Relative
      Determines the edge thickness by the length of the edge. Longer edges will be thicker.

Crease Edges
   This option is intended for usage with
   the :doc:`Subdivision </modeling/modifiers/generate/subdivision_surface>` modifier.
   Enable this option to crease edges on their junctions and prevent large curved intersections.

   Crease Weight
      Define how much crease (0 to 1, nothing to full) the junctions should receive.

Material Offset
   Uses the chosen material index as the material for the wireframe;
   this is applied as an offset from the first material.

.. warning::

   Wireframe thickness is an approximation. While *Even Thickness* should yield good results in many cases,
   skinny faces can cause ugly spikes. In this case you can either reduce the extreme angles in the geometry
   or disable the *Even Thickness* option.


Vertex Group
------------

The weights of the selected vertex group are multiplied onto the *Thickness*,
so vertices with lower weights will be less thick. The vertices which are not part
of the vertex group will be used as if their weight was zero.

Invert
   Reverses the vertex group weights, so that the used weight is one minus the actual weight.
Factor
   How much the vertex weights are taken into account.

   - On 0.0 , vertices with zero weight will have no thickness at all.
   - On 0.5 , vertices with zero weight will be half as thick as those with full weight.
   - On 1.0 , the weights are ignored and the *Thickness* value is used for every vertex.

.. note::

   If the final thickness of a vertex is zero, it will still generate a wireframe.
   Therefore creating duplicate geometry, which sometimes needs extra care.


Examples
========

.. figure:: /images/modeling_modifiers_generate_wireframe_result.jpg
   :width: 420px

   Wireframes on a displaced plane.

In this example, the wireframes carry a second (dark) material while the displaced plane uses its original one.

.. figure:: /images/modeling_modifiers_generate_wireframe_example-weights.png
   :width: 420px

   Vertex group weighting.

The weights of the vertex group gradually change from 0 to 1.

.. figure:: /images/modeling_modifiers_generate_wireframe_example-crease.png
   :width: 420px

   Wireframe and Subdivision Surface modifier.

Cube with enabled *Crease Edges* option. The *Crease Weight* is set to 0, 0.5 and 1.


## Data Transfer

.. index:: Modeling Modifiers; Data Transfer Modifier
.. _bpy.types.DataTransferModifier:

**********************
Data Transfer Modifier
**********************

The Data Transfer modifier transfers several types of data from one mesh to another.
Data types include vertex groups, UV maps, Color Attributes, custom normals...

Transfer works by generating a mapping between source mesh's elements (vertices, edges, etc.)
and destination ones, either on a one-to-one basis, or mapping several source elements
to a single destination one, using interpolation.

.. figure:: /images/modeling_modifiers_modify_data-transfer_normals-example.jpg
   :width: 680px

   Transferring normals between objects,
   `see example blend-file <https://archive.blender.org/wiki/2015/uploads/a/ad/Data_Transfer_Normal_Torus.blend>`__.

.. seealso::

   :doc:`Transfer Mesh Data Operator </scene_layout/object/editing/link_transfer/transfer_mesh_data>`


Options
=======

.. figure:: /images/modeling_modifiers_modify_data-transfer_panel.png
   :align: right
   :width: 300px

   Data Transfer Modifier.

Source
   Mesh object to copy data from.

   If the button to the right of the field is unset, both the source and the destination geometry
   is considered in global space when generating the mapping, otherwise they are evaluated
   in local space (i.e. as if both object's origins were at the same place).

Mix Mode
   Controls how destination data are affected:

   All
      Replaces everything in destination (note that *Mix Factor* is still used).
   Above Threshold
      Only replaces destination value if it's above given threshold *Mix Factor*.
      How that threshold is interpreted depends on the data type,
      note that for Boolean values this option fakes a logical AND.
   Below Threshold
      Only replaces destination value if it's below given threshold *Mix Factor*.
      How that threshold is interpreted depends on the data type,
      note that for Boolean values this option fakes a logical OR.
   Mix, Add, Subtract, Multiply
      Apply that operation, using mix factor to control how much of source or destination value to use.
      Only available for a few types (vertex groups, Color Attributes).

Mix Factor
   How much of the transferred data gets mixed into existing one (not supported by all data types).

Vertex Group
   Allows per-element fine control of the mix factor. Vertex group influence can be reverted using the small
   "arrow" button to the right.

Generate Data Layers
   This modifier cannot generate needed data layers itself. Once the set of source data to transfer is selected,
   this button shall be used to generate matching destination layers, if needed.


Selection of Data to Transfer
-----------------------------

To keep the size of the modifier reasonable, the kind of elements to be affected must be selected first
(vertices, edges, face corners and/or faces).

Mapping Type
   How is generated the mapping between those source and destination elements. Each type has its own options,
   see `Geometry Mapping`_ below for details.

Data Types
   The left column of toggle buttons, to select which data types to transfer.

Multi-layers Data Types Options
   In those cases (vertex groups, Color Attributes, UVs), one can select which source layers to transfer
   (usually, either all of them, or a single specified one), and how to affect destination
   (either by matching names, matching order/position,
   or, if a single source is selected, by specifying manually the destination layer).

Islands Handling Refinement
   This setting only affects UV transfer currently. It allows to avoid a given destination face to get
   UV coordinates from different source UV islands. Keeping it at 0.0 means no island handling at all.
   Typically, small values like 0.02 are enough to get good results, but if you are mapping from
   a very high-poly source towards a very low-poly destination, you may have to raise it quite significantly.


Usage
=====

First key thing to keep in mind when using this modifier is that it will **not** create destination data layers.
*Generate Data Layers* button shall always be used for this purpose, once the set of source data to transfer
has been selected. It should also be well understood that creating those data layers on destination mesh is **not**
part of the modifier stack, which means e.g. that they will remain even once the modifier is deleted, or
if the source data selection is modified.


Geometry Mapping
----------------

Geometry mapping is how a given destination mesh relates to a source mesh.
In this process a destination vertex/edge/...
gets a part of the source mesh assigned with functions as its data source.
It is crucial to understand this topic well to get good results with this modifier.

Topology
   The simplest option, expects both meshes to have identical number of elements, and match them by order (indices).
   Useful e.g. between meshes that were identical copies, and got deformed differently.

One-To-One Mappings
   Those always select only one source element for each destination one, often based on shortest distance.

   Vertices
      Nearest Vertex
         Uses source's nearest vertex.

      Nearest Edge Vertex
         Uses source's nearest vertex of source's nearest edge.
      Nearest Face Vertex
         Uses source's nearest vertex of source's nearest face.

   Edges
      Nearest Vertices
         Uses source's edge which vertices are nearest from destination edge's vertices.
      Nearest Edge
         Uses source's nearest edge (using edge's midpoints).
      Nearest Face Edge
         Uses source's nearest edge of source's nearest face (using edge's midpoints).

   Face Corners
      A face corner is not a real element by itself, it's some kind of split vertex attached to a specific face.
      Hence both vertex (location) and face (normal, ...) aspects are used to match them together.

      Nearest Corner and Best Matching Normal
         Uses source's corner having the most similar *split* normal with destination one,
         from those sharing the nearest source's vertex.
      Nearest Corner and Best Matching Face Normal
         Uses source's corner having the most similar *face* normal with destination one,
         from those sharing the nearest source's vertex.
      Nearest Corner of Nearest Face
         Uses source's nearest corner of source's nearest face.

   Faces
      Nearest Face
         Uses source's nearest face.
      Best Normal-Matching
         Uses source's face which normal is most similar with destination one.

Interpolated Mappings
   Those use several source elements for each destination one, interpolating their data during the transfer.

   Vertices
      Nearest Edge Interpolated
         Uses nearest point on nearest source's edge, interpolates data from both source edge's vertices.
      Nearest Face Interpolated
         Uses nearest point on nearest source's face, interpolates data from all that source face's vertices.
      Projected Face Interpolated
         Uses point of face on source hit by projection of destination vertex along its own normal,
         interpolates data from all that source face's vertices.

   Edges
      Projected Edge Interpolated
         This is a sampling process. Several rays are cast from along the destination's edge
         (interpolating both edge's vertex normals), and if enough of them hit a source's edge,
         all hit source edges' data are interpolated into destination one.

   Face Corners
      A face corner is not a real element by itself, it's some kind of split vertex attached to a specific face.
      Hence both vertex (location) and face (normal, ...) aspects are used to match them together.

      Nearest Face Interpolated
         Uses nearest point of nearest source's face, interpolates data from all that source face's corners.
      Projected Face Interpolated
         Uses point of face on source hit by projection of destination corner along its own normal,
         interpolates data from all that source face's corners.

   Faces
      Projected Face Interpolated
         This is a sampling process. Several rays are cast from the whole destination's face (along its own normal),
         and if enough of them hit a source's face, all hit source faces' data are interpolated into destination one.


Topology Mapping
----------------

Max Distance
   When the "pressure stylus" icon button to the right is enabled,
   this is the maximum distance between source and destination to get a successful mapping.
   If a destination element cannot find a source one within that range, then it will get no transferred data.

   This allows to transfer a small sub-detailed mesh onto a more complete one
   (e.g. from a "hand" mesh towards a "full body" one).

Ray Radius
   The starting ray radius to use when `Ray Casting <https://en.wikipedia.org/wiki/Ray_casting>`__
   against vertices or edges. When transferring data between meshes Blender performs a series of
   ray casts to generate mappings. Blender starts with a ray with the radius defined here,
   if that does not return a hit then the radius is progressively
   increased until a positive hit or a limit is reached.

   This property acts as an accuracy/performance control;
   using a lower ray radius will be more accurate however,
   might take longer if Blender has to progressively increase the limit.
   Lower values will work better for dense meshes with lots of detail
   while larger values are probably better suited for simple meshes.


## Index


########
  Edit
########

.. toctree::
   :maxdepth: 1

   data_transfer.rst
   mesh_cache.rst
   mesh_sequence_cache.rst
   normal_edit.rst
   uv_project.rst
   uv_warp.rst
   weight_edit.rst
   weight_mix.rst
   weight_proximity.rst
   weighted_normal.rst


## Mesh Cache

.. index:: Modeling Modifiers; Mesh Cache Modifier
.. _bpy.types.MeshCacheModifier:

*******************
Mesh Cache Modifier
*******************

The Mesh Cache modifier main use is for animated mesh data to be applied to a mesh and
played back, deforming the mesh.

This works in a similar way to :doc:`shape keys </animation/shape_keys/introduction>`,
but is aimed at playing back external files and is often used for interchange between applications.

.. tip::

   Both MDD and PC2 depend on the vertex order on the mesh remaining unchanged.
   This is a limitation of this method, so take care not to add, remove or reorder vertices
   once this modifier is used.


Options
=======

.. figure:: /images/modeling_modifiers_modify_mesh-cache_panel.png
   :align: right
   :width: 300px

   Mesh Cache Modifier.

Format
   The input file format (currently ``.mdd`` and ``.pc2`` are supported).

File Path
   Path to the cache file.

Influence
   Factor to adjust the influence of the modifier's deformation, useful for blending in/out from the cache data.

Deform Mode
   This setting defaults to *Overwrite* which will replace the vertex locations with those in the cache file.
   However, you may want to use shape keys, for example, and mix them with the mesh cache.
   In this case you can select the *Deform* option which integrates deformations with the mesh cache result.

   .. note::

      This feature is limited to making smaller, isolated edits and
      will not work for larger changes such as re-posing limbs.

Interpolation
   *None*, or *Linear*, which will blend between frames.
   Use linear when the frames in the cache file do not match up exactly with the frames in the blend-file.

Vertex Group
   If set, restrict the effect to the only vertices in that vertex group.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.


Time Remapping
--------------

Time Mode
   Select how time is calculated.

   :Frame:
      Allows you to control the frames,
      which will ignore timing data in the file but is often useful since it gives simple control.
   :Time:
      Evaluates time in seconds,
      taking into account timing information from the file (offset and frame-times).
   :Factor:
      Evaluates the entire animation as a value in the [0, 1] range.

Play Mode
   Select how playback operates.

   :Scene:
      Use the current frame from the scene to control playback.

      Frame Start
         Play the cache starting from this frame.
      Frame Scale
         Scale time by this factor (applied after the start value).

   :Custom:
      Control animation timing manually.

      Evaluation Value
         Property used for animation time,
         this gives more control of timing (typically this value will be animated).


Axis Mapping
------------

Forward/Up Axis
   The axis for forward and up used in the source file.

Flip Axis
   In rare cases you may also need to flip the coordinates on an axis.


## Mesh Sequence Cache

.. index:: Modeling Modifiers; Mesh Sequence Cache Modifier
.. _bpy.types.MeshSequenceCacheModifier:

****************************
Mesh Sequence Cache Modifier
****************************

The Mesh Sequence Cache modifier loads data from :doc:`Alembic </files/import_export/alembic>`
and :doc:`USD </files/import_export/usd>` files.
It supports static meshes, but is mostly used to load animated meshes.
Despite its name, this modifier also supports curves. It also handles file sequences,
as well as meshes and curves with varying topology (like the result of fluid simulations).

When importing an :doc:`Alembic </files/import_export/alembic>` or
:doc:`USD </files/import_export/usd>` file,
Mesh Sequence Cache modifiers are automatically added to time-varying meshes.
For time-varying object transforms (so animation of rotation, location, or scale),
the :ref:`Transform Cache Constraint <bpy.types.TransformCacheConstraint>` is used.
Files other than Alembic or USD, like MDD and PC2 files, can be loaded using
the :doc:`Mesh Cache modifier </modeling/modifiers/modify/mesh_cache>`.


Options
=======

.. figure:: /images/modeling_modifiers_modify_mesh-sequence-cache_panel.png
   :align: right
   :width: 300px

Cache File
   Data-block menu to select the Alembic or USD file.

File Path
   Path to Alembic or USD file.

Object Path
   The path to the Alembic or USD object inside the archive or stage.

Read Data
   Type of data to read for a mesh object, respectively: vertices,
   polygons, UV maps, and Color Attributes.

   Vertices, Faces, UV, Color


Time
----

Sequence
   Whether or not the cache is separated in a series of files.

Override Frame
   Whether to use a custom frame for looking up data in the cache file,
   instead of using the current scene frame.

   The *Frame* value is the time to use for looking up the data in the cache file,
   or to determine which to use in a file sequence.

Frame Offset
   Subtracted from the current frame to use for looking up the data in the cache file,
   or to determine which file to use in a file sequence.


Velocity
--------

Velocity Attribute
   The name of the Alembic attribute used for generating motion blur data;
   by default, this is ``.velocities`` which is standard for most Alembic files.

   .. note:: The *Velocity Attribute* option is currently for Alembic files only.

Velocity Unit
   Defines how the velocity vectors are interpreted with regard to time.

   :Frame:
      The velocity unit was encoded in frames and does not need to be scale by scene FPS.
   :Second:
      The velocity unit was encoded in seconds and needs to be scaled by the scene FPS (1 / FPS).

   .. note:: The *Velocity Unit* option is currently for Alembic files only.

Velocity Scale
   Multiplier used to control the magnitude of the velocity vector for time effects such as motion blur.

   .. note:: The *Velocity Scale* option is currently for Alembic files only.


## Normal Edit

.. index:: Modeling Modifiers; Normal Edit Modifier
.. _bpy.types.NormalEditModifier:

********************
Normal Edit Modifier
********************

The *Normal Edit* modifier affects (or generates) custom normals. It uses a few simple parametric methods
to compute them (quite useful in game development and architecture areas), and mixes back those generated normals
with existing ones.


Options
=======

.. figure:: /images/modeling_modifiers_modify_normal-edit_panel.png
   :align: right
   :width: 300px

   Normal Edit Modifier.

Radial
   Aligns normals with the ``(origin, vertex_coordinates)`` vector, in other words all normals seems to radiate
   from the given center point, as if they were emitted from an ellipsoid surface.
Directional
   Makes all normals point (converge) towards a given target object.

Target
   Uses this object's origin as reference point when generating normals.

   Optional in *Radial* mode, mandatory in *Directional* one.

Parallel Normals
   Makes all normals parallel to the line between both objects' origins,
   instead of converging towards target's origin.

   Only relevant in *Directional* mode.


Mix
---

Mix Mode
   How to affect existing normals with newly generated ones.

   Note that the *Multiply* option is **not** a cross product, but a faster component-by-component multiplication.

Mix Factor
   How much of the generated normals get mixed into existing ones.

Vertex Group
   Allows per-item fine control of the mix factor. The vertex group influence can be inverted by using
   the arrow button to the right.

Max Angle
   Forbids new generated normals to have an angle to the original normal above that given threshold.
   This is useful to prevent extreme changes, that can even lead to inverting the front/back sides of a face,
   and consequently to shading artifacts.

   Lock Polygon Normals (padlock icon)
      Prevents flipping (reversing front/back sides) of polygons which normal does not match anymore
      the side to which point its corners' custom normals. Can also help to avoid shading issues.


Offset
------

Gives modified object's origin an offset before using it to generate normals.

Only relevant in *Radial* mode if no *Target Object* is set,
and in *Directional* mode when *Parallel Normals* is set.


Usage
=====

This modifier can be used to quickly generate radial normals for low-poly tree foliage or
"fix" shading of toon-like rendering by partially bending default normals...

.. tip::

   More complex normal manipulations can be achieved by copying normals from one mesh to another,
   see the :doc:`Data Transfer Modifier </modeling/modifiers/modify/data_transfer>`.
   Some shading effects can also make use of
   the :doc:`Weighted Normals modifier </modeling/modifiers/modify/weighted_normal>`.


Example
=======

.. figure:: /images/modeling_modifiers_modify_normal-edit_example.jpg
   :width: 680px

   Editing custom normals to point towards a given direction
   (`blend-file <https://download.blender.org/ftp/mont29/persistent_data/sapling_CN.blend>`__).

The left tree mesh has unmodified normals, while on the right one a *Normal Edit* modifier is used to bend them
towards the camera. This shading trick is often used in games to fake scattering in trees and other vegetation.


## Uv Project

.. index:: Modeling Modifiers; UV Project Modifier
.. _bpy.types.UVProjectModifier:

*******************
UV Project Modifier
*******************

.. figure:: /images/modeling_modifiers_modify_uv-project_example.jpg
   :align: center
   :width: 350px

   Projecting the Blender logo onto Suzanne.

The *UV Project* modifier acts like a slide projector.
It emits a UV map from the negative Z axis of a controller object
(such as an :doc:`empty object </modeling/empties>`),
and applies it to the object as the "light" hits it.

`Download an example <https://archive.blender.org/wiki/2015/index.php/File:Uvproject.blend>`__.


Options
=======

.. figure:: /images/modeling_modifiers_modify_uv-project_panel.png
   :align: right
   :width: 300px

   The UV Project modifier.

UV Map
   Which UV map to modify. Defaults to the active rendering layer.

Aspect X/Y
   Changes the image's aspect ratio. Only apply when a camera is used as projector object.
Scale X/Y
   Scales the image. Only apply when a camera is used as projector object.

Projectors
   Up to ten projector objects are supported.
   Each face will choose the closest and aligned projector with its surface normal.
   Projections emit from the negative Z axis (i.e. straight down a camera or light).
   If the projector is a camera, the projection will adhere to its perspective/orthographic setting.

Object
   Specify the projector object(s).


Usage
=====

General
-------

*UV Project* is great for making spotlights more diverse, and also for creating decals to break up repetition.

Usually, an :doc:`Image Texture node </render/shader_nodes/textures/image>` mapped to the UV map
that the modifier targets is added to the object's material.


Known Limitations
=================

Vertices Behind the Camera
--------------------------

When projecting geometry in a perspective view, vertices behind the camera are not properly mapped.
You can workaround this by subdividing geometry so that faces in front of the camera have correctly mapped UVs.


## Uv Warp

.. index:: Modeling Modifiers; UV Warp Modifier
.. _bpy.types.UVWarpModifier:

****************
UV Warp Modifier
****************

The *UV Warp* modifier transforms an object's UV map based on values or two objects.
Its purpose is to give you direct control over the object's UVs in the 3D Viewport,
allowing you to directly move, rotate, and scale existing UV coordinates
using defined values or a controller object or bone.


Options
=======

.. figure:: /images/modeling_modifiers_modify_uv-warp_panel.png
   :align: right
   :width: 300px

UV Layer
   Which UV map to modify; if not set it defaults to the active rendering layer.

UV Center
   The center point of the UV map to use when applying scale or rotation.
   With (0, 0) at the bottom left and (1, 1) at the top right.

Axis U/V
   The axes to use when mapping the 3D coordinates into 2D.

Object From, To
   The two objects used to define the transformation. See `Usage`_ below.

Vertex Group
   The vertex group can be used to scale the influence of the transformation per vertex.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.


Transform
---------

Offset
   Amount to move the UV map.
Scale
   Amount to scale the UV map.
Rotate
   Amount to rotate the UV map.


Usage
=====

How the UVs are warped is determined by the difference between the transforms (location, rotation and scale)
of the *from* and *to* objects.

If the *to* object has the same transforms as the *from* object, the UVs will not be changed.

Assuming the *UV Axis* of the modifier is X/Y and the scale of the objects is (1, 1, 1), if the *to* object is
one unit away from the *from* object on the X axis, the UVs will be transformed on the U axis (horizontally)
by one full UV space (the entire width of the image).


## Weighted Normal

.. index:: Modeling Modifiers; Weighted Normal Modifier
.. _bpy.types.WeightedNormalModifier:

************************
Weighted Normal Modifier
************************

This modifier changes the :ref:`custom normals <modeling_meshes_normals_custom>`
of a mesh, using various selectable methods.
This can be useful to make some faces appear very flat during shading, among other effects.
See :doc:`Normals </modeling/meshes/editing/mesh/normals>` for a description of normals and custom normals.


Options
=======

.. figure:: /images/modeling_modifiers_modify_weighted-normal_panel.png
   :align: right
   :width: 300px

Weighting Mode
   The normals around a vertex will be combined to create a custom (per face corner) normal
   using various weights for each. The *Weighting Mode* defines how to compute the weights.

   Face Area
      Weight according to the area of the face that the normal originates.
      A larger area means that the normal from that face will get a higher weight in final result.

   Corner Angle
      Weight according to the angle each face forms at the vertex.
      This is the method Blender uses by default when combining face normals to compute a vertex one.

   Face Area and Angle
      Weights are obtained by multiplying the face area and corner angle ones.

Weight
   Determines how strongly the weights are biased according to the face areas and/or corner angles,
   a bit like a contrast setting for a picture.

   A value of 50 means all faces are weighted uniformly.
   More than 50 means faces with higher area or angles are given even more weight (more "contrast").
   Less than 50 means faces with higher area or angles are given lesser weights (less "contrast").

Threshold
   A weight-rounding threshold which means that, if two angles or areas differ by less than that threshold,
   they will get equal weights.

Keep Sharp
   Preserve :ref:`sharp edges <geometry-nodes_builtin-attributes>`,
   though smoothing will still happen if there are multiple faces between any two sharp edges.

Face Influence
   Use face weights (weak, medium, or strong) as assigned by
   the :doc:`Set Strength </modeling/meshes/editing/mesh/normals>` tool or
   by the *Set Strength* mode of a :doc:`Bevel </modeling/modifiers/generate/bevel>` modifier.

   For example, if three faces meet at a vertex and have the face weights weak, medium, and strong,
   then only the normal associated with the strong face will be used to set the final result.

Vertex Group
   If a vertex group is specified, the modifier will only affect those vertices.
   The "arrow" button to its right will invert the selection (only affect the vertices *not* in the vertex group).


## Weight Edit

.. index:: Modeling Modifiers; Vertex Weight Edit Modifier
.. _bpy.types.VertexWeightEditModifier:

***************************
Vertex Weight Edit Modifier
***************************

This modifier is intended to edit the weights of a vertex group.

The general process is the following, for each vertex:

- (Optional) It does the mapping, either through one of the predefined functions, or a custom mapping curve.
- It applies the influence factor, and optionally the vertex group or texture mask
  (0.0 means original weight, 1.0 means fully mapped weight).
- It applies back the weight to the vertex, and/or it might optionally remove the vertex
  from the group if its weight is below a given threshold, or add it if it is above a given threshold.

.. important::

   This modifier does implicit clamping of weight values in the standard (0.0 to 1.0) range.
   All values below 0.0 will be set to 0.0, and all values above 1.0 will be set to 1.0.

.. note::

   You can view the modified weights in Weight Paint Mode.
   This also implies that you will have to disable the *Vertex Weight Edit* modifier
   if you want to see the original weights of the vertex group you are editing.


Options
=======

.. figure:: /images/modeling_modifiers_modify_weight-edit_panel.png
   :align: right
   :width: 300px

   The Vertex Weight Edit modifier panel.

Vertex Group
   The vertex group to affect.

Default Weight
   The default weight to assign to all vertices not in the given vertex group.

Group Add
   Adds vertices with a final weight over *Add Threshold* to the vertex group.

Group Remove
   Removes vertices with a final weight below *Remove Threshold* from the vertex group.

Normalize Weights
   Scale the weights in the vertex group to keep the relative weight
   but the lowest and highest values follow the full 0 - 1 range.


Falloff
-------

Falloff Type
   Type of mapping.

   Linear
      No mapping.
   Custom Curve
      Allows you to manually define the mapping using a curve.
   Sharp, Smooth, Root and Sphere
      These are classical mapping functions, from spikiest to roundest.
   Random
      Uses a random value for each vertex.
   Median Step
      Creates binary weights (0.0 or 1.0), with 0.5 as cutting value.

Invert ``<-->``
   Inverts the falloff.


.. _modeling-modifiers-weight-edit-influence-mask-options:

Influence
---------

Those settings are the same for the three *Vertex Weight* modifiers.

Global Influence
   The overall influence of the modifier
   (0.0 will leave the vertex group's weights untouched, 1.0 is standard influence).

   .. important::

      Influence only affects weights, adding/removing of vertices
      to/from vertex group is not prevented by setting this value to 0.0.

In addition, a per-vertex fine control of the effect is possible using either a vertex group or a texture
(both are mutually exclusive). The per-vertex values from those will be multiplied with the *Global Influence*.

See :ref:`common masking options <modifiers-common-options-masking>` for a complete reference.


Example
=======

Here is an example of various effects achieved using *Vertex Weight Edit* modifier
(together with the :doc:`Vertex Weight Proximity </modeling/modifiers/modify/weight_proximity>` modifier)
to generate weights used by the :doc:`Displace </modeling/modifiers/deform/displace>` modifier.

.. list-table:: *Curve Map* variations.

   * - .. figure:: /images/modeling_modifiers_modify_weight-edit_mapping-concave.jpg
          :width: 400px

          Concave-type mapping curve.

   * - .. figure:: /images/modeling_modifiers_modify_weight-edit_distance-edge.jpg
          :width: 400px

          No mapping curve (linear).

   * - .. figure:: /images/modeling_modifiers_modify_weight-edit_mapping-convex.jpg
          :width: 400px

          Convex-type mapping curve.

.. figure:: /images/modeling_modifiers_modify_weight-edit_exrem-vertices.jpg
   :width: 400px

   Vertices with a computed weight below 0.1 removed from the vertex group.

.. peertube:: 5c73d2a3-d624-4c66-9adf-a9345690b843

`The blend-file <https://archive.blender.org/wiki/2015/index.php/File:ManModifiersWeightVGroupEx.blend>`__,
TEST_2 scene.


## Weight Mix

.. index:: Modeling Modifiers; Vertex Weight Mix Modifier
.. _bpy.types.VertexWeightMixModifier:

**************************
Vertex Weight Mix Modifier
**************************

This modifier mixes a second vertex group (or a simple value) into the affected vertex group,
using different operations.

.. important::

   This modifier does implicit clamping of weight values in the standard (0.0 to 1.0) range.
   All values below 0.0 will be set to 0.0, and all values above 1.0 will be set to 1.0.

.. note::

   You can view the modified weights in Weight Paint Mode.
   This also implies that you will have to disable the *Vertex Weight Mix* modifier
   if you want to see the original weights of the vertex group you are editing.


Options
=======

.. figure:: /images/modeling_modifiers_modify_weight-mix_panel.png
   :align: right
   :width: 300px

   The Vertex Weight Mix modifier panel.

Vertex Group A, B
   - **A**: The vertex group to affect.
   - **B**: The second vertex group to mix into the affected one.
     Leave it empty if you only want to mix in a simple value.

   Invert Weights A/B
      Invert the influence of the vertex group.

Default Weight A, B
   - **A**: The default weight to assign to all vertices not in the given vertex group.
   - **B**: The default weight to assign to all vertices not in the given second vertex group.

.. container:: lead

   .. clear

Vertex Set
   Choose which vertices will be affected.

   :All: Affects all vertices, disregarding the vertex groups content.
   :Vertex Group A: Affects only vertices belonging to the affected vertex group.
   :Vertex Group B: Affects only vertices belonging to the second vertex group.
   :Vertex Group A or B: Affects only vertices belonging to at least one of the vertex groups.
   :Vertex Group A and B: Affects only vertices belonging to both vertex groups.

   .. important::

      When using *All vertices*, *Vertices from group B* or *Vertices from one group*,
      vertices might be added to the affected vertex group.

Mix Mode
   How the vertex group weights are affected by the other vertex group's weights.

   :Replace: Replaces affected weights with the second group's weights.
   :Add: Adds the values of *Group B* to *Group A*.
   :Subtract: Subtracts the values of *Group B* from *Group A*.
   :Multiply: Multiplies the values of *Group B* with *Group A*.
   :Divide: Divides the values of *Group A* by *Group B*.
   :Difference: Subtracts the smaller of the two values from the larger.
   :Average: Adds the values together, then divides by 2.
   :Minimum: Uses the smallest weight value of VGroup A's or VGroup B's weights.
   :Maximum: Uses the largest weight value of VGroup A's or VGroup B's weights.

Normalize Weights
   Scale the weights in the vertex group to keep the relative weight
   but the lowest and highest values follow the full 0 - 1 range.


Influence
---------

Those settings are the same for the three *Vertex Weight* modifiers,
see the :ref:`Vertex Weight Edit modifier <modeling-modifiers-weight-edit-influence-mask-options>` page.


Example
=======

Here is and example of using a texture and the mapping curve to generate weights used by
the :doc:`Wave </modeling/modifiers/deform/wave>` modifier.

.. list-table:: Texture channel variations.

   * - .. figure:: /images/modeling_modifiers_modify_weight-mix_intensity.jpg
          :width: 200px

          Using intensity.

     - .. figure:: /images/modeling_modifiers_modify_weight-mix_red.jpg
          :width: 200px

          Using Red.

     - .. figure:: /images/modeling_modifiers_modify_weight-mix_saturation.jpg
          :width: 200px

          Using Saturation.

.. _fig-modifier-vertex-weight-custom:

.. list-table:: Custom mapping curve with a Vertex Weight Edit modifier.

   * - .. figure:: /images/modeling_modifiers_modify_weight-mix_map-curve.png
          :width: 200px

          A customized mapping curve.

     - .. figure:: /images/modeling_modifiers_modify_weight-mix_red.jpg
          :width: 200px

          Custom Mapping disabled.

     - .. figure:: /images/modeling_modifiers_modify_weight-mix_red-map.jpg
          :width: 200px

          Custom Mapping enabled.

.. peertube:: 40378a39-cd90-404a-89bf-64ee9a39310a

`The blend-file <https://archive.blender.org/wiki/2015/index.php/File:ManModifiersWeightVGroupEx.blend>`__,
TEST_4 scene.


## Weight Proximity

.. index:: Modeling Modifiers; Vertex Weight Proximity Modifier
.. _bpy.types.VertexWeightProximityModifier:

********************************
Vertex Weight Proximity Modifier
********************************

This modifier sets the weights of the given vertex group,
based on the distance between the object (or its vertices),
and another target object (or its geometry).

.. warning::

   This modifier does implicit clamping of weight values in the standard (0.0 to 1.0) range.
   All values below 0.0 will be set to 0.0, and all values above 1.0 will be set to 1.0.

.. note::

   You can view the modified weights in Weight Paint Mode.
   This also implies that you will have to disable the *Vertex Weight Proximity* modifier
   if you want to see the original weights of the vertex group you are editing.


Options
=======

.. figure:: /images/modeling_modifiers_modify_weight-proximity_panel.png
   :align: right
   :width: 300px

   The Vertex Weight Proximity modifier panel.

Vertex Group
   The vertex group to affect.

Target Object
   The object from which to compute distances.

Proximity Mode
   Object Distance
      Use the distance between the modified mesh object and the target object as
      weight for all vertices in the affected vertex group.
   Geometry Distance
      Use the distance between each vertex and the target object, or its geometry.

      Vertex
         This will set each vertex's weight from its distance to the nearest vertex of the target object.
      Edge
         This will set each vertex's weight from its distance to the nearest edge of the target object.
      Face
         This will set each vertex's weight from its distance to the nearest face of the target object.

      .. note::

         If you enable more than one of them, the shortest distance will be used.
         If the target object has no geometry (e.g. an empty or camera),
         it will use the location of the object itself.

Lowest
   Distance mapping to 0.0 weight.
Highest
   Distance mapping to 1.0 weight.

.. tip::

   *Lowest* can be set above *Highest* to reverse the mapping.

Normalize Weights
   Scale the weights in the vertex group to keep the relative weight
   but the lowest and highest values follow the full 0 - 1 range.


Falloff
-------

Type
   Type of mapping.

   Linear
      No mapping.
   Custom Curve
      Allows you to manually define the mapping using a curve.
   Sharp, Smooth, Root and Sphere
      These are classical mapping functions, from spikiest to roundest.
   Random
      Uses a random value for each vertex.
   Median Step
      Creates binary weights (0.0 or 1.0), with 0.5 as cutting value.

Invert ``<-->``
   Inverts the falloff.


Influence
---------

Those settings are the same for the three *Vertex Weight* modifiers,
see the :ref:`Vertex Weight Edit modifier <modeling-modifiers-weight-edit-influence-mask-options>` page.


Example
=======

This example shows the usage of distance from a target object to dynamically control
a :doc:`Wave </modeling/modifiers/deform/wave>` modifier with a modified vertex group:

.. peertube:: 579d7bd1-3f25-4441-ad7e-2d52667845c1

`The blend-file <https://archive.blender.org/wiki/2015/index.php/File:ManModifiersWeightVGroupEx.blend>`__,
TEST_1 scene.


## Cloth

.. index:: Modeling Modifiers; Cloth Modifier

**************
Cloth Modifier
**************

The Cloth modifier is a container for a :doc:`Cloth Physics </physics/cloth/index>` simulation. It can be useful
for example, to simulate on a low-poly mesh then add a :doc:`/modeling/modifiers/generate/subdivision_surface`
after the Cloth modifier to improve the visual quality of the cloth without drastically increasing simulation times.


Options
=======

As the modifier is only a container its actual options can be configured in the *Physics Properties* tab.
See the :doc:`Cloth Physics Properties </physics/cloth/settings/index>` for more information.


Example
=======

.. list-table::

   * - .. figure:: /images/physics_cloth_introduction_example1.jpg

          Cloth example.

     - .. figure:: /images/physics_cloth_introduction_oncarved-wood.jpg

          Cloth on carved wooden men (made by motorsep).

     - .. figure:: /images/physics_cloth_introduction_example2.jpg

          Cloth example.


## Collision

.. index:: Modeling Modifiers; Collision Modifier

******************
Collision Modifier
******************

The Collision modifier is a container for a :doc:`Collision Physics </physics/collision/>`.
Collision physics provide interaction between different physics simulations.


Options
=======

As the modifier is only a container its actual options can be configured in the *Physics Properties* tab.
See the :doc:`Collision Physics Properties </physics/cloth/settings/index>` for more information.


Example
=======

.. figure:: /images/physics_collision_defected-particles.png

   Deflected particles.

Here is a *Meta* object, using Instancing Vertices to a particle system emitting downwards,
and deflected by a mesh cube.


## Dynamic Paint

.. index:: Modeling Modifiers; Dynamic Paint Modifier

**********************
Dynamic Paint Modifier
**********************

The Dynamic Paint modifier is a container for a :doc:`Dynamic Paint Physics </physics/cloth/index>` simulation.


Options
=======

As the modifier is only a container its actual options are configured in the *Physics Properties* tab.
See the :doc:`Dynamic Paint Physics Properties </physics/dynamic_paint/index>` for more information.


## Explode

.. index:: Modeling Modifiers; Explode Modifier
.. _bpy.types.ExplodeModifier:

****************
Explode Modifier
****************

The *Explode* modifier is used to alter the mesh geometry by moving/rotating its faces in a way
that roughly tracks particles emitted by that object, making it look as if the mesh is being exploded
(broken apart and pushed outward).

For this modifier to have any visible effect, there needs to be a particle system on its object.
That particle system will control how the mesh is exploded.

Both the number of emitted particles and number of faces determine how granular the *Explode* modifier is.
More of each faces and particles will mean more individual pieces.

Here is a
`demo video <https://archive.blender.org/wiki/2015/index.php/File:Manual_-_Explode_Modifier_-_Exploding_Cube_
-_2.5.ogg/>`__
showing a cube with a particle system and *Explode* modifier.
(`blend-file <https://archive.blender.org/wiki/2015/index.php/File:Manual_-_Explode_Modifier_-_Exploding_Cube_
-_2.5.blend>`__).

.. note::

   The *Explode* modifier must come after the *Particle System* one in the :ref:`modifier stack <modifier-stack>`,
   in order for the former to get required data from the later.


Options
=======

.. figure:: /images/modeling_modifiers_physics_explode_panel.png
   :align: right
   :width: 300px

   The Explode modifier, with a Particle System above it.

Particle UV
   If set, the U value of the coordinates in that :term:`UV Map` will be overwritten
   with the age of the particle attached to the matching mesh face
   (in proportion, from 0 for not yet born particles, to 1 for dead ones).

   The V value is set to a constant 0.5 value.

   You can for example vary the color of a fragment (face) during the explosion phase,
   by using a texture with a color gradient along its *U* axis.

Show
   Unborn
      Show faces when their attached particles are unborn.
   Alive
      Show faces when their attached particles are alive.
   Dead
      Show faces when their attached particles are dead.

Cut Edges
   Split the mesh in pieces based on location of emitted particles, instead of using existing faces.
   This will typically results in a splitting that appears more random.

Size
   Scale each face using the size of its attached particle, once that particle is alive.

Vertex Group
   Vertices in this group may not be affected by the *Explode* modifier.
   Vertices with full weight are not affected at all,
   while vertices with less weight have a higher chance of being affected.

   Vertices with null weight will be treated like those which do not belong to the group at all,
   and explode normally.

   Invert ``<->``
      Inverts the influence of the selected vertex group, meaning that the group
      now represents vertices that will not be deformed by the modifier.

      The setting reverses the weight values of the group.

Protect
   Clean vertex group edges. Depending on the weights assigned to that vertex group,
   either completely protect those faces from being affected by the *Explode* modifier
   (which would happen if the faces had a weight value of 1),
   or completely remove protection from those faces
   (which would happen if the faces had a weight value of 0).

Refresh
   Refresh data in the *Explode* modifier.


Known Limitations
=================

Dynamic Vertex Weights
----------------------

This modifier uses the initial vertex weights.
Modifiers that dynamically change weights will not influence the explosion as these values are only used once.

.. Ref #77654


## Fluid

.. index:: Modeling Modifiers; Fluid Modifier

**************
Fluid Modifier
**************

The Fluid modifier is a container for a :doc:`Fluid Physics </physics/fluid/index>` simulation. It can be useful
for example, to simulate on a low-poly mesh then add a :doc:`/modeling/modifiers/generate/subdivision_surface`
after the Fluid modifier to improve the visual quality of the fluid without drastically increasing simulation times.


Options
=======

As the modifier is only a container its actual options can be configured in the *Physics Properties* tab.
See the :doc:`Fluid Physics Properties </physics/fluid/index>` for more information.


Example
=======

.. figure:: /images/physics_fluid_introduction_liquid-example.png
   :align: center

   Example of a liquid simulation.


## Index


###########
  Physics
###########

.. toctree::
   :maxdepth: 1

   cloth.rst
   collision.rst
   dynamic_paint.rst
   explode.rst
   fluid.rst
   ocean.rst
   particle_instance.rst
   particle_system.rst
   soft_body.rst


## Ocean

.. index:: Modeling Modifiers; Ocean Modifier
.. _bpy.types.OceanModifier:

**************
Ocean Modifier
**************

The *Ocean* modifier is a tool to simulate and generate a deforming ocean surface,
and associated texture, used to render the simulation data.
It is intended to simulate deep ocean waves and foam.

It is a port from the open source `Houdini Ocean Toolkit
<https://code.google.com/archive/p/houdini-ocean-toolkit/>`__.


Options
=======

.. figure:: /images/modeling_modifiers_physics_ocean_panel.png
   :align: right
   :width: 300px

   The Ocean modifier.

Geometry
   Generate
      Creates a tiled mesh grid that exactly corresponds with the resolution of the simulation data.

      When generating a mesh surface, the existing mesh object is completely overridden with the ocean grid;
      this also includes any data generated from previous modifiers in the stack.
      A UV channel is also added, mapping the (0.0 to 1.0) UV space to the simulation grid.

      Repeat X, Y
         Controls the number of times the grid is tiled in X and Y directions.
         UVs for these tiled mesh areas continue outside of the (0.0 to 1.0) UV space.

   Displace
      Uses the existing geometry rather than replacing it. Vertices are displaced along the local Z axis.

Resolution Viewport, Render
   The main control of quality vs speed in the simulation engine.
   This determines the resolution of the internal 2D grids generated by the simulation for the 3D Viewport
   or the final render.

   The internal grids are powers of two of the resolution value,
   so a resolution value of ``16``, will create simulation data of size ``256×256``.
   The higher the resolution, the more details will be produced, but the slower it will be to calculate.

   .. note::

      When using the *Generate* modifier geometry option,
      this resolution value also determines the resolution of the generated mesh surface,
      equal to the resolution of the internal simulation data.

Time
   The time at which the ocean surface is being evaluated.
   To create an animated ocean, you will need to :ref:`animate <bpy.ops.anim.keyframe_insert>` this value.
   The speed that the time value is changing will determine the speed of the wave animation.

Depth
   The constant depth of the ocean floor under the simulated area.
   Lower values simulate shallower waters by producing
   higher frequency details and smaller waves.

Size
   A simple scaling factor that does not affect the height of the waves or behavior of the simulation.

Spatial Size
   The width of the ocean surface area being simulated, in meters.
   This also determines the size of the generated mesh, or the displaced area.
   Of course, you can scale the object with the *Ocean* modifier in Object Mode
   to tweak the apparent size in your scene.

Random Seed
   A different :term:`Seed` will produce a different simulation result.

Generate Normals
   Simulates extra normal map data.
   This can be used by the Ocean texture, when mapped to Normals,
   as a bump map, and enables generating normal map image sequences when baking.


Waves
-----

Scale
   An overall scale control for the amplitude of the waves.
   It approximates the height or depth of the waves above or below zero.
   Rather than just scaling the ocean object in Z, it scales all aspects of the simulation,
   displacement in X and Y, and corresponding foam and normals too.

Smallest Wave
   A minimum limit for the size of generated waves.
   Acts similarly to a low-pass filter, removing higher frequency wave detail.

Choppiness
   The choppiness of the wave peaks.
   With a choppiness of 0, the ocean surface is only displaced up and down in the Z direction,
   but with higher choppiness, the waves are also displaced laterally in X and Y, to create sharper wave peaks.

Wind Velocity
   Wind speed in meters/second. With a low velocity, waves are restricted to smaller surface waves.

Alignment
   The directionality of the wave shapes due to wind.
   At a value of 0, the wind and waves are randomly, uniformly oriented.
   With higher *Alignment* values, the wind is blowing in a more constant direction,
   making the waves appear more compressed and aligned to a single direction.

Direction
   When using *Alignment*, the direction in degrees that the waves are aligned to (using local X axis as reference).

Damping
   When using *Alignment*, this will define the amount that inter-reflected waves are damped out.
   This has the effect of making the wave motion more directional (not just the wave shape).

   With a *Damping* of 0.0, waves are reflected off each other in every direction, with a *Damping* of 1.0,
   these inter-reflected waves are damped out, leaving only waves traveling in the direction of the wind.


Foam
----

Simulates extra foam data.

This can be retrieved by the Ocean texture for use in texturing (perhaps as a mask),
and enables generating foam map image sequences when baking.

Data Layer
   Optional name for the vertex data layer,
   used by the Ocean Modifier to store foam maps as a Color Attribute.
   This is required for accessing the foam data in the renderer.

Coverage
   Tweaks the amount of foam covering the waves, negative values will reduce the amount of foam
   (leaving only the topmost peaks), positive values will add to it. Typically ranges from (-1.0 to 1.0).

.. figure:: /images/modeling_modifiers_physics_ocean_foam-layer-name.png
   :align: center

   Using foam Color Attributes with a named data layer.


Spray
^^^^^

Generate map of spray direction as a Color Attribute.
This map can be used to define the velocities for spray particles.

Spray Map
   Name of the Color Attribute used for the spray direction map.

Invert
   Inverts the spray direction map.


Spectrum
--------

Spectrum
   Used to choose the wave spectrum model to use.
   Wave spectra are used to describe how energy moves through the waves at different frequencies.
   Energy travels through waves differently depending on the depth of the water and the wind speed.

   Turbulent Ocean
      Use for turbulent seas with foam (Phillips).
   Established Ocean
      Use for a large area, established ocean where the ocean would extend for miles
      with wind blowing for days allowing the waves to reach a point of equilibrium (Pierson-Moskowitz method).
   Established Ocean (Sharp Peaks)
      Similar to regular *Established Ocean* however, waves will continue to grow with time
      creating sharper peaks (:abbr:`JONSWAP (JOint North Sea WAve Project)` and Pierson-Moskowitz method).
      An extra parameter is used to define the sharpness of these peaks.
   Shallow Water
      Use for shallow water with depths less than about 10 meters which makes it great
      for small lakes and ponds without heavy wind (JONSWAP and TMA -- Texel-Marsen-Arsloe methods).

   .. list-table:: Examples of different spectra, settings adjusted for each.

      * - .. figure:: /images/modeling_modifiers_physics_ocean_spectra-turbulent.png

             Turbulent Ocean.

        - .. figure:: /images/modeling_modifiers_physics_ocean_spectra-established.png

             Established Ocean.

      * - .. figure:: /images/modeling_modifiers_physics_ocean_spectra-established-peaks.png

             Established Ocean (Sharp Peaks).

        - .. figure:: /images/modeling_modifiers_physics_ocean_spectra-shallow-water.png

             Shallow Water.

Sharpness Peak
   An artificial factor to control how sharp the peaks of the waves are in
   the *Established Ocean (Sharp Peaks)* and *Shallow Water* spectrum models.

Fetch
   Distance from a lee shore, called the fetch, or the distance over which the wind blows with constant velocity.
   Used by *Established Ocean (Sharp Peaks)* and *Shallow Water* spectrum models.


Bake
----

Rather than simulating the ocean data live, it can be baked to files in a given directory.
When a simulation is baked, the simulator engine is completely bypassed,
and all information for the modifier or texture is retrieved from the baked files.

Baking has the following advantages:

- It is faster to use the stored data rather than recalculating it.
- It allows rendering of ocean data in external renderers.
- It enables more advanced foam maps.

Simulation data is stored as sequences of ``OpenEXR`` image maps,
one for each of displacement, normals, and foam (if enabled to be generated).
Upon loading the data from these baked files, when a frame of the bake sequence is read,
it is cached in memory. This means that accessing loaded frames subsequent times is fast,
not incurring the overhead of drive access.

Since these baked files are plain ``OpenEXR``'s,
they can also be opened and rendered in any other application or renderer that supports them.

Cache Path
   Folder to store the baked EXR files in.
   The sequences will be in the form ``disp_####.exr``, ``normal_####.exr``,
   and ``foam_####.exr``, where ``####`` is the four digit frame number.
   If the cache path folder does not exist, it will be created.

Frame Start, End
   Frames of the simulation to bake (inclusive).
   The start and end frames of the bake are repeated when accessing frames outside of the baked range.

Foam Fade
   Baking also provides improved foam capabilities. When simulating live,
   the ocean simulator retrieves data for that current frame only.
   In the case of the foam map, this represents the tips of wave crests for that given frame.
   In reality, after foam is created by wave interactions,
   it remains sitting on the top of the wave surface for a while, as it dissipates. With baking,
   it is possible to approximate that behavior, by accumulating foam from previous frames,
   leaving it remaining on the surface.


Example
=======

The following example was created and rendered in Blender,
notice how the peaks of the waves are white; an effect generated from the foam data.

.. peertube:: 509d3fe2-80f5-4a03-8496-95a51b8e6917


## Particle Instance

.. index:: Modeling Modifiers; Particle Instance Modifier
.. _bpy.types.ParticleInstanceModifier:

**************************
Particle Instance Modifier
**************************

When a Particle Instance modifier is added to an object,
the mesh of this object will be duplicated
at the location of the particles of the selected particle system from another target object.
This means that to use this modifier, you must have at least one other object
that has a :doc:`Particles System </physics/particles/index>` on it.

Because of the correlation in which the Particle Instance modifier is
influenced by the underlying particle systems on other objects, some of the apparent effects
generated by the modifier can look and act vastly different,
depending on the underlying settings of the particle systems it is associated with.
This is worth taking account of, when it seems that the Particle Instance modifier settings
do not return the expected results.


Options
=======

.. figure:: /images/modeling_modifiers_physics_particle-instance_panel.png
   :align: right
   :width: 300px

   The Particle Instance modifier.

Object
   The target object which has a particle system associated with it.

Particle System
   Which particle system from the target *Object* to apply this modifier to.

Create Instances
   Regular
      When enabled, the modifier will use the regular (parents) particles
      to duplicate the mesh of the modified object.
   Children
      When enabled, the modifier will use the :doc:`children </physics/particles/emitter/children>` particles
      to duplicate the mesh of the modified object.
   Size
      Scale the instanced copies of the mesh by the particle size attribute.
      When this is disabled, all the copies appear the same size as the origin.

      See the particle system's :doc:`Render </physics/particles/emitter/render>`
      and :doc:`Children </physics/particles/emitter/children>` panels for particle's size options.

Show
   Unborn
      When enabled, the modifier will use the unborn particles
      to duplicate the mesh of the modified object.
   Alive
      When enabled, the modifier will use the alive particles
      to duplicate the mesh of the modified object.
   Dead
      When enabled, the modifier will use the dead particles
      to duplicate the mesh of the modified object.

Amount
   The proportion of particles to be used.
   Allows you to **randomly** skip particles to adjust the amount of instances.

   .. warning::

      The random algorithm used currently only ensures that relative amount to be respected *statistically*.
      The actual amount of instances generated will differ from the theoretical one,
      depending on the *Seed* value of the target particle system (and the *Offset* value described below, too).

      That deviation is not significant with high number of particles,
      but it will be highly noticeable with low numbers
      (e.g. with 100 particles in the target system, and an *Amount* value of ``0.1``,
      it can generate either up to 15 or 5 instances, instead of the 10 expected).

Offset
   A relative offset in the range of particles used for instantiation.
   Allows you to avoid overlapping of the used particles,
   when the same particle system is used in multiple modifier instances.

   .. tip::

      If you want to fully avoid overlaps, your *Offset* value must be at least as high as your *Amount* value.

Coordinate Space
   World, Local
      Use :term:`World Space`, or :term:`Local Space` of the target object (that the particle system is assigned to).

      - World space means that the locations of the copies of the modified mesh will depend
        on the location of the modified object **and** of the target object.
      - Local space means that the locations of the copies of the modified mesh will depend
        only on the location of the modified object.

Axis
   Specify which axis of the modified object to use as pole axis to apply
   the rotation from the instantiated particles.


Create Along Paths
------------------

By default, the instances are placed depending on the particles position in the current frame.
By enabling *Create Along Paths*, the instance of the modified object follows
deforms its shape along the particle path (or the hair strand).
This allows you to select the position along the particles path regardless of the current frame.

.. tip::

   You can adjust the particles' path (using the *Path* visualization type)
   on the :doc:`Render </physics/particles/emitter/render>` panel of the *Particle System* tab.

.. note::

   The particle system must be :doc:`baked </physics/baking>`, except for *Hair* type or *Keyed* physics.

Position
   Specify what percentage of the path that the instance fills,
   or the position on the path if the *Keep Shape* option is enabled.
Random
   Adds randomness to the *Position* value of each instance.

Rotation
   Specifies the rotation around the path.
Random
   Adds randomness to the *Rotation* value of each instance.

Keep Shape
   Enabling this prevents the instance from being deformed,
   and places it on the path according to the *Position* value.


Layers
------

With these fields you can select the Color Attribute,
which will be filled with colors based on the particles information.
These Color Attributes can be used, for example, in a shader to add variance to a material.

Index
   A Color Attribute for values based on the particles index.
Value
   A Color Attribute for random per-particle values.


Examples
========

.. figure:: /images/modeling_modifiers_physics_particle-instance_split-plane.jpg
   :align: center

   Particle Instance modifier example.

The render above shows a single plane mesh object assigned to two different vertex groups
and each of those vertex groups is assigned to a separate and independent particle system,
with each particle system being assigned to a different Particle Instance modifier.
In the case shown the Particle Instance modifiers are added to a sphere and a cube.
See `example blend-file
<https://archive.blender.org/wiki/2015/uploads/4/48/Manual_-_Modifiers_-_Particle_Instance_Modifiers_-_Split_Plane.blend>`__.

.. figure:: /images/modeling_modifiers_physics_particle-instance_create-along-paths.jpg
   :align: center

   Create Along Path example.

In this example, a single *Keyed* particle travels through four points (green planes),
on an elliptical path. The Particle Instance modifier is added to a cylinder object
and then associated with that *Keyed* particle system.

When the *Create Along Paths* is activated,
instead of the cylinder location just following the position of the particle,
the cylinder mesh is fitted to the shape of the path followed by the particle.
The mesh geometry of the object which is deformed
can have an impact on how well the deformation is carried out.
In the case of the cylinder, it has many loop cuts along its length so
that it can bend at those points to deform along the particle path.

The Particle Instance modifier *Create Along Paths* option works for hair (strand) particles
as well as with keyed particles. In this case, the mesh of the modifier will follow
the length and profile of the hair strands paths.

.. note::

   Strands, when they are generated, instantly die when created, so for the *Create Along Paths* checkbox
   to be of any use, you must also have the *Dead* checkbox enabled.


## Particle System

.. index:: Modeling Modifiers; Particle System Modifier

************************
Particle System Modifier
************************

The Particle System modifier is a container for :doc:`Particle Systems </physics/particles/index>`.

.. note::

   By default the Particle System modifier does not take into account the :ref:`modifier stack <modifier-stack>`.
   Make sure to enable :ref:`Use Modifier Stack <bpy.types.ParticleSettings.use_modifier_stack>`
   in the Particle properties if you want Particle System modifier to take other modifiers into account.


Options
=======

As the modifier is only a container its actual options are configured in the *Particle Properties* tab.
See the :doc:`Particle Systems Properties </physics/particles/index>` for more information.


Converting Particle Systems
===========================

Make Instances Real
   Creates a new object of each instanced :ref:`object <particle-object>` or :ref:`collection <particle-collection>`.
   See :ref:`bpy.ops.object.duplicates_make_real` for more information.

Convert to Mesh
   Converts :ref:`path <particle-path>` particles to mesh objects.
   See :ref:`bpy.ops.object.convert` for more information.


Example
=======

.. figure:: /images/physics_particles_introduction_fur-example.jpg

   Fur made from particles.


## Soft Body

.. index:: Modeling Modifiers; Soft Body Modifier

******************
Soft Body Modifier
******************

The Soft Body modifier is a container for a :doc:`Soft Body Physics </physics/fluid/index>` simulation.


Options
=======

As the modifier is only a container its actual options are configured in the *Physics Properties* tab.
See the :doc:`Soft Body Physics Properties </physics/soft_body/settings/index>` for more information.


Example
=======

.. figure:: /images/physics_soft-body_introduction_windcone.jpg

   The wind cone is a soft body, as the suspension.


## Index

.. _modeling-surfaces-index:
.. _bpy.ops.surface:

############
  Surfaces
############

.. toctree::
   :maxdepth: 2

   introduction.rst
   toolbar/index.rst
   structure.rst
   primitives.rst
   selecting.rst
   editing/index.rst
   properties/index.rst


## Introduction


************
Introduction
************

Curves are 2D objects, and surfaces are their 3D extension.
Note however, that in Blender, you only have NURBS surfaces,
no Bézier (you have the *Bézier* knot type, though; see below),
nor polygonal (but for these, you have meshes!).
Even though curves and surfaces share the same object type (with texts also...),
they are not the same thing; for example,
you cannot have in the same object both curves and surfaces.

.. _fig-surface-intro-surface:

.. figure:: /images/modeling_surfaces_introduction_nurbs-surface.png

   NURBS surface in Edit Mode.

As surfaces are 2D, they have two interpolation axes, U (as for curves) and V.
It is important to understand that you can control the interpolation rules (knot, order, resolution)
*independently* for each of these two dimensions
(the U and V fields for all these settings, of course).

You may ask yourself "but the surface appears to be 3D, why is it only 2D?".
In order to be 3D, the object needs to have "Volume", and a surface, even when it is closed,
does not have volume; it is infinitely thin.
If it had a volume the surface would have a thickness (its third dimension). Hence,
it is only a 2D object, and has only two interpolation dimensions or axes or coordinates
(if you know a bit of math, think of non-Euclidean geometry -- well,
surfaces are just non-Euclidean 2D planes...). To take a more "real-world" example,
you can roll a sheet of paper to create a cylinder; well, even if it becomes a "volume",
the sheet itself will remain a (nearly...) 2D object!

In fact, surfaces are very similar to the results you get when
:doc:`extruding a curve </modeling/curves/properties/geometry>`.


Visualization
=============

There is nearly no difference from NURBS curves,
except that the U direction is indicated by yellow grid lines,
and the V one is materialized by pink grid lines, as you can see in
Fig. :ref:`fig-surface-intro-surface`.

You can :ref:`hide and reveal <curves-show-hide>` control points just as with curves.


Conversion
==========

As there are only NURBS surfaces, there is no "internal" conversion here.

However, there is an "external" conversion available, from surface to mesh,
that only works in Object Mode. It transforms a surface object into a mesh one,
using the surface resolutions in both directions to create faces, edges and vertices.


## Primitives

.. _bpy.ops.surface.primitive*add:

**********
Primitives
**********

.. reference::

   :Mode:      Object Mode and Edit Mode
   :Menu:      :menuselection:`Add --> Curve`
   :Shortcut:  :kbd:`Shift-A`

.. seealso::

   When adding curves there are some common options like other :ref:`Objects <object-common-options>`.

In Object/Edit Mode, the *Add Surface* menu, provides six different surface primitives:

.. list-table::

   * - .. figure:: /images/modeling_surfaces_primitives_surface.png

          NURBS surface primitives.

     - .. figure:: /images/modeling_surfaces_primitives_curve.png

          NURBS curve primitives.


NURBS Curve
===========

Adds a generic curve of four control points forming an arc.


NURBS Circle
============

Adds an a closed loop of control point forming a circle.
Note, a circle :term:`NURBS` surface is never filled, unlike its "real" curve counterpart...


NURBS Surface
=============

Adds a generic surface patch consisting of a 4×4 grid plane with the center grid slightly raised.


NURBS Cylinder
==============

Adds an open end cylinder, consisting of an extruded *NURBS Circle*.


NURBS Sphere
============

Adds a generic sphere constructed by revolving a grid of control points about an axis.


NURBS Torus
===========

Adds a doughnut-shaped primitive created by rotating a circle around an axis.


## Selecting


*********
Selecting
*********

This page discusses specific selecting tools for surface objects in Edit Mode.
The Surface Edit also uses the general select tools used which are described
in the :doc:`interface section </interface/selecting>`.

Surface selection in *Edit Mode* is very similar to
:doc:`NURBS curve selection </modeling/curves/selecting>`.
The basic tools are the same as with :doc:`meshes </modeling/meshes/selecting/index>`,
so you can select a simple control point with an :kbd:`LMB`-click,
add to current selection with :kbd:`Shift-LMB` clicks, Border Select, and so on.


Select Menu
===========

The *Select* menu (in the 3D Viewport header) is even simpler than for curves...

All these options have the same meaning and behavior as in :doc:`Object Mode </scene_layout/object/selecting>`
and mesh :doc:`Edit Mode </modeling/meshes/selecting/index>`.

All :kbd:`A`
   Select all.
None :kbd:`Alt-A`
   Select none.
Inverse :kbd:`Ctrl-I`
   Selects all the geometry that is not selected, and deselect currently selected components.

----

:ref:`Box Select <tool-select-box>` :kbd:`B`
   Interactive box selection.
:ref:`Circle Select <tool-select-circle>` :kbd:`C`
   Interactive circle selection.
:ref:`Lasso Select <tool-select-lasso>`
   Interactive free-form selection.

----

`Select Random`_
   Select random control points.

`Checker Deselect`_
   Select every Nth control point.

`Select Linked`_ :kbd:`Ctrl-L`
   Select control points that are connected to the current selection.

`Select Similar`_ :kbd:`Shift-G`
   Select control points that have similar properties to the current selection.

----

`Select Control Point Row`_
   Select a whole :ref:`row <modeling-surfaces-rows-grids>` of control points.

----

`Select More/Less`_
   Select objects based on their parent child relationships.


Select Random
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Random`

Select random control points.

Percent
   Selects the defined percentage of control points.
Random Seed
   :term:`Seed` used by the pseudo-random number generator.
Action
   Controls whether the operator *Selects* or *Deselects* control points.


Checker Deselect
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Checker Deselect`

This tool applies an alternating selected/deselected checker pattern.
This only works if you already have more than one control point selected.

It works by changing the current selection so that only every Nth
control points will remain selected, starting from the active one.

Deselected
   The number of deselected elements in each pattern repetition.
Selected
   The number of selected elements in each pattern repetition.
Offset
   Offset from the starting point.


Select Linked
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Linked`
   :Shortcut:  :kbd:`L`, :kbd:`Ctrl-L`

*Select Linked* will add to the selection the mouse cursor's nearest control point,
and all the linked ones, i.e. all points belonging to the same surface.


Select Similar
==============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Select Similar`
   :Shortcut:  :kbd:`Shift-G`

Selects control points that have certain similar properties to the active one.
The :ref:`bpy.ops.screen.redo_last` panel provides several selection options:

Type
   Type
      Selects splines that have the same spline Type i.e. Bézier, NURBS or Poly.
   Radius
      Selects control points that have a similar Radius value.
   Weight
      Selects all points that have a similar Weight value.
   Direction
      Selects control points that have a similar handles direction.

Compare
   For quantitative properties, this property selects the type of comparison to between the two numerical values.

   :Equal: Select items with the same value as the active item's chosen property.
   :Greater: Select items with a larger value as the active item's chosen property.
   :Less: Select items with a smaller value as the active item's chosen property.
Threshold
   For quantitative properties, this property controls how
   close the property's values have to be in the comparison.


.. _bpy.ops.curve.select_row:

Select Control Point Row
========================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> Control Point Row`
   :Shortcut:  :kbd:`Shift-R`

This option works a bit like
:ref:`edge loop selection <bpy.ops.mesh.loop_multi_select>` for meshes,
inasmuch it selects a whole :ref:`row <modeling-surfaces-rows-grids>` of control points,
based on the active (the last selected) one. The first time you press :kbd:`Shift-R`,
the V row passing through (containing) the active point will be added to the *current* selection.
If you use again this shortcut, you will toggle between the U and V row of this point,
removing *everything else* from the selection.


Select More/Less
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Select --> More/Less`
   :Shortcut:  :kbd:`Ctrl-NumpadPlus` / :kbd:`Ctrl-NumpadMinus`

Expand or contract the selection based on current selected control points.

More
   For each selected control point, select **all** its linked points (i.e. two, three or four).
Less
   For each selected control point, if **all** points linked to this point are selected, keep it selected.
   For all other selected control points, deselect them.

This implies two points:

#. First, when **all** control points of a surface are selected, nothing will happen
   (as for *Less*, all linked points are always selected, and of course, *More* cannot add any).
   Conversely, the same goes when no control point is selected.
#. Second, these tools will never "go outside" of a surface
   (they will never "jump" to another surface in the same object).


## Structure


*********
Structure
*********

Many of the concepts from :doc:`curves </modeling/curves/introduction>`,
especially :ref:`NURBS <curve-nurbs>` ones,
carry directly over to NURBS surfaces,
such as control points, *Order*, *Weight*, *Resolution*, etc.
Here we will just talk about the differences.

It is very important to understand the difference between NURBS curves and NURBS surfaces:
the first one has one dimension, the latter has two.
Blender internally treats NURBS surfaces and NURBS curves completely differently. There are
several attributes that separate them but the most important is that a NURBS curve has
a single interpolation axis (U) and a NURBS surface has two interpolation axes (U and V).

However, you can have "2D" surfaces made of curves
(using the :doc:`extrusion tools </modeling/curves/properties/geometry>`,
or, to a lesser extent, the filling of closed 2D curves). And you can have "1D" curves made of surfaces,
like a NURBS surface with only one row (either in U or V direction) of control points produces only a curve...

Visually you can tell which is which by entering Edit Mode and looking at the 3D Viewport header:
either the header shows *Surface* or *Curve* as one of the menu choices. Also,
you can :doc:`extrude </modeling/curves/properties/geometry>` a whole NURBS surface curve to create a surface,
but you cannot with a simple NURBS curve.


.. _modeling-surfaces-rows-grids:

Control Points, Rows and Grid
=============================

Control points for NURBS surfaces are the same as for NURBS curves. However,
their layout is quite constraining. The concept of "segment" disappears,
replaced by "rows" and the overall "grid".

A "row" is a set of control points forming one "line" in one interpolation direction
(a bit similar to :ref:`edge loops <modeling-mesh-structure-edge-loops>` for meshes).
So you have "U rows" and "V rows" in a NURBS surface.
The key point is that *all* rows of a given type (U or V) have the *same* number of control points.
Each control point belongs to exactly one U row and one V row.

All this forms a "grid", or "cage", the shape of which controls the shape of the NURBS surface.
A bit like a :doc:`lattice </animation/lattice>`...

This is very important to grasp: you cannot add a single control point to a NURBS surface;
you have to add a whole U or V row at once
(in practice, you will usually use the *Extrude* tool, or perhaps the *Duplicate* one, to add those...),
containing exactly the same number of points as the others. This also means that you will only
be able to "merge" different pieces of surfaces if at least one of their rows matches together.


.. _modeling-surfaces-weight:

Weight
======

Similar to :ref:`NURBS Splines <curve-nurbs>` NURBS Surface control points have a weight property.
This weight property controls how much influence the control point has on the surface.
This weight should not be confused with the :ref:`Goal Weight <surface-goal-weight>`,
which is used only for soft body simulations.
The NURBS control point weight can be adjusted in the *W* number field of
the :doc:`Transform panel </modeling/curves/editing/transform_panel>`.

In Fig. :ref:`fig-surface-intro-weight` a single control point, labeled "C",
has had its *Weight* set to 5.0 while all others are at their default of 1.0.
As you can see, that control point *pulls* the surface towards it.

.. _fig-surface-intro-weight:

.. figure:: /images/modeling_surfaces_structure_weight.png

   One control point with a weight of 5.

.. note::

   If all the control points have the same *Weight* then each effectively cancels each other out.
   It is the difference in the weights that cause the surface to move
   towards or away from a control point.


Preset Weights
--------------

NURBS can create pure shapes such as circles, cylinders, and spheres
(note that a Bézier circle is not a pure circle). To create pure circles, spheres,
or cylinders, you must set to specific values the weights of the control points.
This is not intuitive, and you should read more on NURBS before trying this.

To create a sphere with 2D surfaces, its the same principle as with a 2D circle.
You will note that the four different weights needed for creating a sphere
(1.0, 0.707 = sqrt(0.5), 0.354 = sqrt(2)/4, and 0.25).

.. figure:: /images/modeling_surfaces_structure_weight-sphere.png

   A sphere surface.


## Control Points


**************
Control Points
**************

Extrude Curve and Move
======================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Extrude Curve and Move`
   :Shortcut:  :kbd:`E`

Unlike meshes or curves, you cannot generally directly add new control points to a surface,
as you can only extend a surface by adding a whole U or V row at once.
The only exception is when working on a NURBS surface curve, i.e.
a surface with only one control point on each U or V row. In this special case,
all works exactly as with :ref:`curves <modeling-curves-extrude>`.

Most of the time, only extrusion is available. As usual, once the tool is activated
the extrusion happens immediately and you are placed into *select mode*,
ready to drag the new extruded surface to its destination.

There are two things very important to understand:

#. Surfaces are *2D* objects. So you cannot extrude anything *inside* a surface
   (e.g. "inner" row); it would not make any sense!
#. The control "grid" *must* remain "squarish",
   which means that you can only extrude a whole row, not parts of rows here and there...

To summarize, the *Extrude* tool will only work, when one and only one whole border
row is selected, otherwise nothing happens.

.. note::

   As for curves, you cannot create a new surface in your object out of nowhere.
   However, unlike for curves, there is no "cut" option allowing you to separate a surface into several parts,
   so you only can create a new surface by :ref:`Duplicating <modeling_surface_editing_duplicating>`
   an existing one, or adding a new one with the *Add* menu.


Examples
--------

Images Fig. :ref:`fig-surface-edit-select-point` to Fig. :ref:`fig-surface-edit-extruding`
show a typical extrusion along the side of a surface.

In Fig. :ref:`fig-surface-edit-select-point` and :ref:`fig-surface-edit-select-row`,
a border row of control points were highlighted by selecting a single control point,
and then using :ref:`bpy.ops.curve.select_row` to select the rest of the control points.

.. list-table::

   * - .. _fig-surface-edit-select-point:

       .. figure:: /images/modeling_surfaces_editing_control-points_selecting-point.png

          Selecting control point.

     - .. _fig-surface-edit-select-row:

       .. figure:: /images/modeling_surfaces_editing_control-points_selecting-row.png

          Select Control Point Row.

The edge is then extruded as shown in Fig. :ref:`fig-surface-edit-extruding`.
Notice how the mesh has bunched up next to the highlighted edge.
That is because the *new* extruded surface section is bunched up there as well.

.. _fig-surface-edit-extruding:

.. figure:: /images/modeling_surfaces_editing_control-points_extruding.png

   Extruding.

By moving the new section away from the area, the surface begins to "unbunch".

You can continue this process of extruding or adding new surface sections
until you have reached the final shape for your model.


Make Segment
============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Make Segment`
   :Shortcut:  :kbd:`F`

Just like :ref:`curves <modeling-curves-make-segment>`,
merging two surfaces requires that a single edge, a border row of control points,
from two separate surfaces is selected. This means that the surfaces must be part of the same object.
For example, you cannot join two surfaces while in *Object Mode* -- but you can of course,
as with any objects of the same type, :ref:`join <bpy.ops.object.join>`
two or more *Surface* objects -- they just will not be "linked" or merged in a single one.

This tool is equivalent to creating edges or faces for meshes (hence its shortcut).
The selection must contain only border rows of the same resolution
(with the same number of control points),
else Blender will try to do its best to guess what to merge with what,
or the merge will fail (either silently, or stating that ``Resolution does not match``
if rows with different number of points are selected, or that there is ``Too few selections to merge``
if you only selected points in one surface...). To select control points of different surfaces,
in the same object, you must use either box select or circle select; :kbd:`Ctrl-LMB` will not work.

So to avoid problems, you should always only select border rows with the same number of
points... Note that you can join a border U row of one surface with a border V row of another
one, Blender will automatically "invert" the axis of one surface for them to match correctly.

NURBS surface curves are often used to create objects like hulls,
as they define cross sections all along the object,
and you just have to "skin" them as described above to get a nice, smooth and harmonious shape.


Examples
--------

Fig. :ref:`fig-surface-edit-join-ready` is an example of two NURBS surface curves,
**not** NURBS curves, in *Edit Mode*, ready to be joined.
Fig. :ref:`fig-surface-edit-join-complete` is the result of joining the two curves.

.. list-table::

   * - .. _fig-surface-edit-join-ready:

       .. figure:: /images/modeling_surfaces_editing_control-points_joining-ready.png

          Joining ready.

     - .. _fig-surface-edit-join-complete:

       .. figure:: /images/modeling_surfaces_editing_control-points_joining-complete.png

          Joining complete.


Smooth
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Control Points --> Smooth`

Iteratively smooths the selected control points
by reducing the distance between neighboring control points.


Hooks
=====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Control Points --> Hooks`
   :Shortcut:  :kbd:`Ctrl-H`

:doc:`Hooks </modeling/modifiers/deform/hooks>` can be added to control one or more points with other objects.


Make Vertex Parent
==================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Control Points --> Make Vertex Parent`
   :Shortcut:  :kbd:`Ctrl-P`

You can make other selected objects :ref:`children <object-parenting>`
of one or three control points, as with mesh objects.

To select a mesh (that is in view) while editing a surface, :kbd:`Ctrl-P` click on it.
Select either one or three control points,
then :kbd:`Ctrl-LMB` the object and use :kbd:`Ctrl-P` to make a vertex parent.
Selecting three control points will make the child follow
the median point between the three vertices. An alternative would be to use
a :doc:`Child Of constraint </animation/constraints/relationship/child_of>`.
See also the :doc:`Curve modifier </modeling/modifiers/deform/curve>`.


## Index


###########
  Editing
###########

.. toctree::
   :maxdepth: 2

   transform_panel.rst
   surface.rst
   control_points.rst
   segments.rst


## Segments


********
Segments
********

Subdivide
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Segments --> Subdivide`

The *Subdivision* operator simply subdivides all selected segments
by adding one or more control points between the selected segments.
Selected grids will be split into four smaller ones.

If used on a 1D surface (a "surface curve"),
this tool works exactly as with :ref:`curves <bpy.ops.curve.subdivide>`.

Number of Cuts
   The number of subdivisions to perform.


.. _modeling_surfaces_editing_segments_switch-direction:

Switch Direction
================

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Segments --> Switch Direction`

This tool will "reverse" the direction of any curve with at least one selected element
(i.e. the start point will become the end one, and *vice versa*).
Mainly useful when using a curve as path, or the bevel and taper options...


## Surface


*******
Surface
*******

Surface editing has even fewer tools and options than its curve counterpart,
but has many common points with it...
So this page covers (or tries to cover) all the subjects,
from the basics of surface editing to more advanced topics, like retopology.


Transform
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Transform`

A surface can be edited by transforming the locations of the control points.

Move, Rotate, Scale
   Like other elements in Blender, control points can be
   moved, rotated, or scaled as described in
   :doc:`Basic Transformations </scene_layout/object/editing/transform/introduction>`.
To Sphere, Shear, Warp, Bend, Push/Pull, Warp, Randomize
   These transform tools are described in
   the :doc:`Transformations </modeling/meshes/editing/mesh/transform/index>` sections.
Move/Scale Texture Space
   Like other objects, surfaces have textures spaces which can be
   :ref:`edited <properties-texture-space-editing>`.


Mirror
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Mirror`
   :Shortcut:  :kbd:`Ctrl-M`

The *Mirror* tool is also available, behaving exactly as with
:doc:`mesh vertices </modeling/meshes/editing/mesh/mirror>`.


Snap
====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Snap`
   :Shortcut:  :kbd:`Shift-S`

:doc:`Mesh snapping </editors/3dview/controls/snapping>`
also works with control points, except for within itself (other components of the active spline).
Snapping works with 2D surfaces but points will be constrained to the local XY axes.


.. _bpy.ops.curve.spin:

Spin
====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Spin`

This tool is a bit similar to its :doc:`mesh counterpart </modeling/meshes/tools/spin>`
but with less control and options (in fact, there is none!).

It only works on selected "surfaces" made of *one U row* (and not with one V row),
so-called "surface curves", by "extruding" this "cross section" in a square pattern.
While automatically adjusting the weights of control points to get a perfect circular extrusion
(this also implies closing the surface along the V axis), following exactly the same principle
as for the *NURBS Tube* or *NURBS Torus* primitives.


.. _modeling_surface_editing_duplicating:

Add Duplicate
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Add Duplicate`
   :Shortcut:  :kbd:`Shift-D`

Similar as with meshes and curves, this tool duplicates the selection.
The copy is selected and placed in move mode, so you can move it to another place.

However, with surfaces there are some selections that cannot be duplicated,
in which case they will just be placed in move mode... In fact,
only selections forming a *single* valid sub-grid are copyable; let us see this in practice:

- You can copy a single control point.
  From it, you will be able to "extrude" a "surface curve" along the U axis,
  and then extrude this unique U row along the V axis to create a real new surface.
- You can copy a single continuous part of a row (or a whole row, of course).
  This will give you a new *U row*, even if you selected (part of) a V row!
- You can copy a single whole sub-grid.

.. note::

   Trying to duplicate several valid "sub-grids" (even being single points)
   at once will not work; you will have to do it one after the other...


Split
=====

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Split`
   :Shortcut:  :kbd:`Y`

The *Split* operator splits a selected segment of a surface from the rest of the surface.
This segment can then be moved or altered without affecting the other surface.
If a single control point is selected the *Split* operator will create a new singular loose control point;
leaving the previously selected control point attached to the rest of the surface.


Separate
========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Separate`
   :Shortcut:  :kbd:`P`

Surface objects that are made of multiple distinct parts can be separated into their own
objects by selecting the desired segments and using *Separate*.
Note, if there is only one surface in a surface object,
*Separate* will create a new surface object with no control points.


Toggle Cyclic
=============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Toggle Cyclic`
   :Shortcut:  :kbd:`Alt-C`

As in :ref:`curves <bpy.ops.curve.cyclic_toggle>`,
surfaces can be closed (cyclic) or open. However, as surfaces are 2D,
you can control this property independently along the U and V axes.

To toggle the cyclic property of a surface along one axis,
use *Toggle Cyclic* and choose either *Cyclic U* or *Cyclic V* from the pop-up menu.
The corresponding surface's outer edges will join together to form a "closed" surface.

.. note:: Inner and Outer

   Surfaces have an "inner" and "outer" face, the first being black whereas the latter is correctly shaded.
   When you close a surface in one or two directions, you might get an entirely black object! In this case,
   just :ref:`Switch Direction <modeling_surfaces_editing_segments_switch-direction>` of the surface.


Set Spline Type
===============

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Set Spline Type`

This feature only works for :doc:`Curves </modeling/curves/index>`.


Show/Hide
=========

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Curve --> Show/Hide`
   :Shortcut:  :kbd:`Alt-H`, :kbd:`H`, :kbd:`Shift-H`

When in *Edit Mode*, you can hide and reveal elements from the display.
You can only show or hide control points, as segments are always shown,
unless all control points of the connected surface are hidden,
in which case the surface is fully hidden.

.. seealso::

   See :ref:`object-show-hide` in *Object Mode*.


Cleanup
=======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Cleanup`

This feature only works for :doc:`Curves </modeling/curves/index>`.


Delete
======

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Surface --> Delete`
   :Shortcut:  :kbd:`X`, :kbd:`Delete`

The selection must abide by the following rules:

- Whole rows, and only whole rows must be selected.
- Only rows along the same axis must be selected (i.e. you cannot delete both U and V rows at the same time).

Also remember that NURBS order cannot be higher than its number of control points in a given axis,
so it might decrease when you delete some control points...
Of course, when only one row remains, the surface becomes a "surface curve"; when only one point remains,
there is no more visible surface; and when all points are deleted, the surface itself is deleted.

Vertices
   This will delete the selected rows, *without* breaking the surface
   (i.e. the adjacent rows will be directly linked, joined, once the intermediary ones are deleted).
   Remember that NURBS order cannot be higher than its number of control points,
   so it might decrease when you delete some control point.
   Of course, when only one point remains, there is no more visible curve,
   and when all points are deleted, the curve itself is deleted.
Segment
   Deletes the segment that connects the selected control points and disconnects them.
Dissolve Vertices :kbd:`Ctrl-X`
   This feature only works for :doc:`Curves </modeling/curves/index>`.


Example
-------

In the image below (left), a row of control points has been selected by initially selecting
the one control point and using :ref:`bpy.ops.curve.select_row` to select the remaining
control points. Then, using `Delete`_ *Vertices*,
the selected row of control points is erased, resulting in the image below (right).

.. figure:: /images/modeling_surfaces_editing_surface_deleting.png

   Before and after.


## Transform Panel


***************
Transform Panel
***************

.. reference::

   :Mode:      Edit Mode
   :Panel:     :menuselection:`Sidebar --> Transform`

When nothing is selected, the panel is empty.
When more than one control point is selected, the median values are edited
and "Median" is added in front of the labels.

Control Point, Median
   The first controls (X, Y, Z) show the coordinates of the selected point or handle (vertex).
   The last control (W), defines the :ref:`weight <modeling-surfaces-weight>`
   of the selected control point or the median weight.
Space
   The Space radio buttons let you choose if those coordinates are relative to
   the object origin (local) or the global origin (global).

   Global, Local

.. _surface-goal-weight:

Weight
   Controls the "goal weight" of selected control points,
   which is used when a surface has :doc:`Soft Body </physics/soft_body/index>` physics,
   forcing the surface to "stick" to their original positions, based on the weight.
Radius
   Surface objects do not have a *Radius* property, this value has no effect.
Tilt
   Surface objects do not have a *Radius* property, this value has no effect.


## Active Spline


*************
Active Spline
*************

.. reference::

   :Mode:      Edit Mode
   :Menu:      :menuselection:`Properties --> Curve --> Active Spline`

.. seealso::

   :doc:`Active Spline </modeling/curves/properties/active_spline>` for curves.

The *Active Spline* panel is used in Edit Mode to control properties of the currently selected spline.

.. figure:: /images/modeling_surfaces_properties_active-spline_panel.png
   :align: center

   Active Spline panel.

Cyclic U/V
   Like curves, surfaces can be closed (cyclical) or open, independently in both directions,
   allowing you to easily create a tube, torus or sphere shape,
   and they can be viewed as "solids" in *Edit Mode*.
   This can be set per interpolation axis.
Bézier U
   Makes the surface act like a Bézier curve.
   The control points act like *Free* handles of a Bézier curve.
   Depending on the *Order*, 3 or 4 control points form one spline segment.
   This can be set per interpolation axis.
Endpoint U/V
   Makes the surface contact the end control points.
   This can be set per interpolation axis.

   .. figure:: /images/modeling_surfaces_properties_active-spline_endpoint.png
      :align: center
      :width: 50%

      Endpoint U.

   In the image below, the U interpolation axis is labeled as "U"
   and the V interpolation axis is labeled as "V".
   The U's interpolation axis has been set to *Endpoint*
   and as such the surface now extends to the outer edges from
   E1 to E2 along the U interpolation axis.

   To cause the surface to extend to all edges,
   *Endpoint* would be set for the V's axis as well.
Order U/V
   This property is the same as with :ref:`NURBS Curves <modeling-curve-order>`;
   it specifies how much the control points are taken into account for calculating the curve of the surface shape.
   For high Orders 1 the surface pulls away from the control points,
   creating a smoother surface by assuming that the *Resolution U/V* is high enough.
   For lowest Orders 2 the surface follows the control points,
   creating a surface that tends to follow the grid cage.

   .. _fig-surface-intro-order:

   .. figure:: /images/modeling_surfaces_properties_active-spline_order.png
      :align: center
      :width: 50%

      Order 2 and Order 4 surface.

   For illustration purposes, in both Fig. :ref:`fig-surface-intro-order`,
   the knot vectors were set to *Endpoint*, causing the surface to extend to all edges.

   You can set independently the order for each interpolation axis,
   and like curves, it **cannot** be lower than 2,
   and higher than 6 or the number of control points on the relevant axis.
Resolution U/V
   Alters the :ref:`resolution <bpy.types.Curve.resolution_v>`
   of each segment by changing the number of subdivisions.
   This can be set per interpolation axis.
Smooth
   Use :ref:`Smooth Shading <modeling-meshes-editing-normals-shading>` for any 3D geometry.


## Index


##############
  Properties
##############

.. toctree::
   :maxdepth: 2

   shape.rst
   active_spline.rst


## Shape


*****
Shape
*****

.. figure:: /images/modeling_surfaces_properties_shape_resolution-panel.png
   :align: center

   Shape panel.

.. _bpy.types.Curve.resolution_v:

Resolution Preview U/V
   Resolution to use in the 3D Viewport.
Render U/V
   Just like :ref:`NURBS curves <curve-nurbs>`, *Resolution* controls the detail of the surface.
   The higher the *Resolution* the more detailed and smoother the surface is.
   The lower the *Resolution* the rougher the surface. However, here you have two resolution settings,
   one for each interpolation axis (U and V).

   You can adjust the resolution separately for both preview and render,
   to not slow things down in the viewport, but still get good render results.

   .. list-table::

      * - .. figure:: /images/modeling_surfaces_properties_shape_resolution-1x1-wire.png

             Resolution 1×1.

        - .. figure:: /images/modeling_surfaces_properties_shape_resolution-3x3-wire.png

             Resolution 3×3.

      * - .. figure:: /images/modeling_surfaces_properties_shape_resolution-1x1.png

             Resolution of 1 for both U and V.

        - .. figure:: /images/modeling_surfaces_properties_shape_resolution-3x3.png

             Resolution of 3 for both U and V.

.. seealso::

   The panels of the *Curve and Surface* tab are the same as for
   :doc:`curves </modeling/curves/introduction>`, just with fewer options...


## Index

.. _surface-toolbar-index:

*******
Toolbar
*******

Surface Edit Mode tools:

:ref:`Select <tool-select-tweak>`
   Select or move.

   :ref:`Select Box <tool-select-box>`
      Select objects by dragging a box.

      All objects that intersect the box will be selected.
   :ref:`Select Circle <tool-select-circle>`
      Select objects by dragging a circle. All objects that intersect the path of
      the circle will be selected.
   :ref:`Select Lasso <tool-select-lasso>`
      Select objects by drawing a lasso.

Cursor
   Change the location of the 3D Cursor.
Move
   Translation tool.
Rotate
   Rotation tool.
Scale
   Scale tool.

   :ref:`Scale Cage <tool-scale-cage>`
      Change the scale of an object by controlling its cage.

Transform
   Tool to adjust the objects translation, rotations and scale.
:ref:`Annotate <tool-annotate-freehand>`
   Draw free-hand annotation.

   :ref:`Annotate Line <tool-annotate-line>`
      Draw straight line annotation.
   :ref:`Annotate Polygon <tool-annotate-polygon>`
      Draw a polygon annotation.
   :ref:`Annotate Eraser <tool-annotate-eraser>`
      Erase previous drawn annotations.

:ref:`Measure <tool-measure>`
   Measure distances in the scene.


## Editing

.. |atilde| unicode:: U+000E3
.. |aacute| unicode:: U+000E1
.. |agrave| unicode:: U+000E0
.. |acircumflex| unicode:: U+000E2
.. |aring|  unicode:: U+000E5
.. |ash|  unicode:: U+000E6
.. |aordinal|  unicode:: U+000AA
.. |euml|   unicode:: U+000EB
.. |oslash| unicode:: U+000F8
.. |ccedilla| unicode:: U+000E7
.. |cent| unicode:: U+000A2
.. |dagger| unicode:: U+02020
.. |doubledagger| unicode:: U+02021
.. |section| unicode:: U+000A7
.. |copyright| unicode:: U+000A9
.. |registered| unicode:: U+000AE
.. |trademark| unicode:: U+02122
.. |half| unicode:: U+000BD
.. |division| unicode:: U+000F7
.. |plusminus| unicode:: U+000B1

*******
Editing
*******

Editing text is quite different from other object types in Blender, and happens mainly in two areas.
First, the 3D Viewport, where you type your text, and have a few shortcuts, e.g. for applying
styles (see :ref:`modeling-text-character`) -- note however, that most Blender shortcuts you know
in Edit Mode do not exist for texts. The second place is the Properties, especially the *Font* tab.

Editing text objects is similar to using a standard text editor but is not as
full-featured and has some differences.
The menu of the 3D Viewport header offers few options. You have no transform nor mirror tools, and so on.
To leave Edit Mode use :kbd:`Tab` as it does not insert a tab character in the text,
but rather enters and exits Edit Mode, as with other object types.


.. _bpy.ops.font.text_cut:

Cut
===

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Cut`
   :Shortcut:  :kbd:`Ctrl-X`

To cut and copy text to the buffer, use the shortcut or the matching entry in the *Edit* menu.


.. _bpy.ops.font.text_copy:

Copy
====

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Copy`
   :Shortcut:  :kbd:`Ctrl-C`

To copy text to the buffer, use the shortcut or the matching entry in the *Edit* menu.


.. _bpy.ops.font.text_paste:

Paste
=====

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Paste`
   :Shortcut:  :kbd:`Ctrl-V`

To paste text from the buffer, use the shortcut or the matching entry in the *Edit* menu.


.. _bpy.ops.font.text_paste_from_file:

Paste File
==========

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Paste File`

Inserts text from and external text file.
This will bring up a :doc:`File Browser </editors/file_browser>` for navigating to a valid UTF-8 file.
As usual, be careful that the file does not have too many characters,
as interactive response will slow down.


.. _bpy.ops.font.case_set:

To Uppercase
============

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> To Uppercase`

Changes the case of the selected text to uppercase.


To Lowercase
============

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> To Lowercase`

Changes the case of the selected text to lowercase.


.. _bpy.ops.font.text_insert_unicode:

Insert Unicode
==============

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Insert Unicode`

Opens a dialog box to input the entry of any Unicode character by entering its hexadecimal codepoint value.

See Wikipedia for a `List of Unicode characters <https://en.wikipedia.org/wiki/List_of_Unicode_characters>`__
which list there respective hexadecimal codepoint values.


.. _bpy.ops.font.text_insert:

Special Characters
==================

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Special Characters`

This is a limited character map to insert characters which aren't available from the keyboard.
Many other special characters can be "composed", see `Accent Characters`_.
If you need others, you will have to copy-paste them from an external editor or character map program.

.. note::

   The text buffer is in sync with the desktop clipboard.
   But if it is used within Blender the text formatting will be copied as well.
   For other ways of inserting a text, see `Inserting Text`_.


.. _bpy.ops.font.style_toggle:

Toggle Bold, Italics, Underline, Small Caps
===========================================

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Toggle Bold/Italics/Underline/Small Caps`

To apply the *Bold*, *Italics*, *Underline* or *Small Caps* attribute to a set of characters,
you either turn on the related setting prior to typing characters,
or select existing text, and then toggle desired style from the menu.

.. warning::

   Blender's *Bold* and *Italic* buttons do not work the same way as in other applications,
   as they also serve as placeholders for you to load up other fonts manually.


.. _bpy.ops.font.change_spacing:

Kerning
=======

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Kerning`

Font kerning is the space between individual characters.

Decrease Kerning :kbd:`Alt-Left`
   Decreases the spacing between the characters on either side of the cursor.
Increase Kerning :kbd:`Alt-Right`
   Increase the spacing between the characters on either side of the cursor.
Reset Kerning
   Sets the spacing between the characters on either side of the cursor to their initial value.


.. _bpy.ops.font.delete:

Delete
======

.. reference::

   :Editor:    3D Viewport
   :Mode:      Edit Mode
   :Menu:      :menuselection:`Header --> Text --> Delete`

Previous/Next Character
   Deletes the character before or after the cursor.
Previous/Next Word
   Deletes the word before or after the cursor.


Inserting Text
==============

You can insert text in two ways: from the internal text buffer or from a text file.

Using an existing text data-block, you can convert it to an object from the Text editor's header,
select :menuselection:`Edit --> Text to 3D Object`,
*One Object* or *One Object per Line* depending on your needs.

It is also possible to paste from the clipboard or a file, while editing 3D text.


Accent Characters
-----------------

Many special characters (such as accented chars, which are not directly available on your keyboard)
can be "composed" using a combination of two other characters. To do so,
type the main char, press :kbd:`Alt-Backspace`,
and then press the desired "modifier" to produce the special character.
Some examples are given below:

.. hlist::
   :columns: 2

   - |atilde|: ``A``, :kbd:`Alt-Backspace`, ``~``
   - |aacute|: ``A``, :kbd:`Alt-Backspace`, ``'``
   - |agrave|: ``A``, :kbd:`Alt-Backspace`, ``\``
   - |acircumflex|: ``A``, :kbd:`Alt-Backspace`, ``^``
   - |aring|: ``A``, :kbd:`Alt-Backspace`, ``O``
   - |ash|: ``A``, :kbd:`Alt-Backspace`, ``E``
   - |aordinal|: ``A``, :kbd:`Alt-Backspace`, ``-``
   - |euml|: ``E``, :kbd:`Alt-Backspace`, ``"``
   - |ccedilla|: ``C``, :kbd:`Alt-Backspace`, ``,``
   - |cent|: ``C``, :kbd:`Alt-Backspace`, ``|``
   - |oslash|: ``O``, :kbd:`Alt-Backspace`, ``/``

   - |section|: ``S``, :kbd:`Alt-Backspace`, ``S``
   - |dagger|: ``|``, :kbd:`Alt-Backspace`, ``-``
   - |doubledagger|: ``|``, :kbd:`Alt-Backspace`, ``=``
   - |copyright|: ``O``, :kbd:`Alt-Backspace`, ``C``
   - |registered|: ``O``, :kbd:`Alt-Backspace`, ``R``
   - |trademark|: ``T``, :kbd:`Alt-Backspace`, ``M``

   - |half|: ``1``, :kbd:`Alt-Backspace`, ``2``
   - |division|: ``-``, :kbd:`Alt-Backspace`, ``:``
   - |plusminus|: ``-``, :kbd:`Alt-Backspace`, ``+``


Converting to a Mesh or Curve
=============================

In Object Mode, it is possible to convert a text object to a mesh or curve one, see :ref:`object-convert-to`.

.. tip::

   The topology of the result is usually a bit messy,
   so it may be useful to use a *Limited Dissolve* deletion,
   or apply a :doc:`Remesh modifier </modeling/modifiers/generate/remesh>`
   at a low threshold, to clean up your mesh.


Assigning Materials
===================

.. reference::

   :Mode:      Edit
   :Panel:     :menuselection:`Properties --> Materials`

Each character can have a different *Material index* in order to have different materials
on different characters.

You can assign indices either as you type, or after by selecting blocks of text and
clicking on the *Assign* button in the *Materials* panel.

.. figure:: /images/modeling_texts_editing_material-index-example.png

   Red Green Blue text example.


## Index

.. _bpy.types.TextCurve:
.. _bpy.types.VectorFont:
.. _bpy.ops.font:
.. _bpy.ops.object.text:

########
  Text
########

.. toctree::
   :maxdepth: 2

   introduction.rst
   selecting.rst
   editing.rst
   properties.rst


## Introduction


************
Introduction
************

Text objects contain some text, and are in the same object type family as curves and surfaces ones,
as fonts are vector data (they are made of curves).

Blender uses a "Font System" to manage mapping letter codes to geometry representing them in the 3D Viewport.
This font system has its own *built-in* font, but it can use external fonts too,
including *PostScript Type 1*, *OpenType* and *TrueType* fonts.
And moreover, it can use any objects existing in the current blend-file as letters.

.. figure:: /images/modeling_texts_introduction_examples.jpg
   :width: 460px

   An example of an extruded text.

Text objects allow you to create and render 2D or 3D text,
with various advanced layout options, like justifying and frames.
By default, letters are just flat filled surfaces, exactly like any closed 2D curve.
But, just like curves, you can extrude them,
and apply :doc:`modifiers </modeling/modifiers/introduction>` to them
(e.g. to make them :doc:`follow a curve </modeling/modifiers/deform/curve>`).

Text in Blender can be laid out in some relatively advanced ways,
defining columns or blocks of text, using different alignments, and so on.

Those features are similar in concept to what you can find in :abbr:`DTP (DeskTop Publishing)` software
(like `Scribus <https://www.scribus.net/>`__), although at a very basic level currently.

.. tip::

   You can convert a text object, either to a curve, or directly to a mesh,
   using :ref:`object-convert-to` in Object Mode.

.. note::

   A maximum of 50,000 characters is allowed per text object. However,
   be forewarned that the more characters a single text object has,
   the slower the object will respond interactively.


## Properties


**********
Properties
**********

Shape
=====

.. reference::

   :Mode:      All Modes
   :Panel:     :menuselection:`Properties --> Text --> Shape`

Most of the settings in the *Shape* panel are shared with those of
:doc:`Curves </modeling/curves/properties/shape>`
data-blocks, please refer to those for details.

.. _bpy.types.TextCurve.use_fast_edit:

Fast Editing
   Does not fill the letters in Edit Mode, only show their outline.


Texture Space
=============

Each Object can have an automatically generated UV map, these maps can be adjusted here.

See :ref:`Generated UV Properties <properties-texture-space>` for more information.


Geometry
========

.. reference::

   :Mode:      All Modes
   :Panel:     :menuselection:`Properties --> Font --> Geometry`

Offset
   Offset the control points of the curves defining the letters, which will make them thinner or thicker.
   Use with care, it can quickly lead to artifacts...


Extrusion, Taper & Bevel
------------------------

The remaining settings of that panel, which are used to give volume to the letters,
are also shared with the :doc:`Curves </modeling/curves/properties/geometry>` data-blocks,
please refer to those for details.

.. note::

   How the Taper object effect works depends on how the curves defining the letters are built.
   The results can often look quite random...

.. note::

   :ref:`Bevel <bpy.types.Curve.bevel>` is applied to the curves defining the letters,
   which means that usually it will follow their outlines
   (there will be two parallel beveled curves, and not a single one, as one might expect).


.. _modeling-text-character:

Font
====

.. reference::

   :Mode:      All Modes
   :Panel:     :menuselection:`Properties --> Font --> Font`

Blender comes with a *built-in* font by default that is displayed in
each of the four font style data-block menus.
The *built-in* font is always present and shows in this list as "Bfont".
The data-block menu contains a list displaying the currently loaded fonts.
Select one for each font style.

To load a different *Font*, click one of the *Load* buttons
in the *Font* panel and navigate to a font file.
The :doc:`File Browser </editors/file_browser>` will give all valid fonts a capital "F" icon.

If you select a font that is unsupported by Blender, you will get the error ``Not a valid font``.

.. note:: Location of Fonts on Unix

   Fonts are typically located under ``/usr/lib/fonts``, or some variant like ``/usr/lib/X11/fonts``,
   but not always. They may be in other locations as well,
   such as ``/usr/share/local`` or ``/usr/local/share``, and possibly related sub-trees.

Remember that the same font will be applied to all chars with same style in a text,
but that a separate font is required for each style.
For example, you will need to load an *Italics* font in order to make characters or words italic.
Once the font is loaded you can apply that font "Style" to the selected characters or the whole object.
In all, you would need to load a minimum of four different types of fonts to represent each style
(Normal, Italics, Bold, Bold & Italics).

It is important to understand, that Blender does not care what font
you load for "normal", "bold", etc., styles.
This is how you can have up to four different fonts in use in the same text,
but you have to choose between different styles of a same font, or different fonts.
Blender has a number of typographic controls for changing the style and layout of text,
found in the *Font* panel.

.. _bpy.types.TextCharacterFormat.use_bold:

Bold
   With no text selected, toggles new text to be **bold**.
   With text selected, toggles the selected text to be **bold**.
   Text can also be set to bold by selecting it then using the *Bold*
   entry in the *Text* menu of the 3D Viewport.

.. _bpy.types.TextCharacterFormat.use_italic:

Italic
   With no text selected, toggles new text to be *italic*.
   With text selected, toggles the selected text to be *italic*.
   Text can also be set to italic by selecting it then using the *Bold*
   entry in the *Text* menu of the 3D Viewport.

.. _bpy.types.TextCharacterFormat.use_underline:

Underline
   With no text selected, toggles new text to be underline.
   With text selected, toggles the selected text to be underline.
   Text can also be set to underline by selecting it then using the *Underline*
   entry in the *Text* menu of the 3D Viewport.

   See also :ref:`underline settings <modeling-text-character-underline>` below.

.. _bpy.types.TextCharacterFormat.use_small_caps:

Small Caps
   With no text selected, toggles new text to be small capitals.
   With text selected, toggles the selected text to be small capitals.
   Text can also be set to small caps by selecting it then using the *Small Caps*
   entry in the *Text* menu of the 3D Viewport.

   The size of the *Small Caps* can be changed with
   the :ref:`Small Caps Scale setting <modeling-text-character-underline>`.


Transform
---------

.. _bpy.types.TextCurve.size:

Size
   Controls the size of the whole text (no way to control each char size independently).
   Note however, that chars with different fonts (different styles, see below) might have different visible sizes.

.. _bpy.types.TextCurve.shear:

Shear
   Controls the inclination of the whole text.
   As similar as it may seem, this is not the same thing as italics style.

   .. figure:: /images/modeling_texts_properties_shear-example.png
      :width: 340px

      Shear example.

.. _bpy.types.TextCurve.family:

Object Font
   Allows individual objects to be used to render fonts, you can create/model your own complex font inside Blender!
   This field is used to select the objects prefix name (object "family") to be used
   to locate the individual characters used for typing.
   This is quite a complex process, so here are detailed steps to follow:

   #. Create the font characters, each character can be any object type (mesh, curve, etc.).
      They must all have a name following the naming schema:
      "common prefix" followed by the "character name" (e.g. "ft.a", "ft.b", etc.).
   #. For the text object, enable
      :doc:`Instancing Vertices </scene_layout/object/properties/instancing/verts>`.
   #. In the *Font* tab, fill the *Object Font* field with the "common prefix" of your "font" objects.
      Now, each time a character in your text matches the *suffix part* of a "font" object's name,
      this object is duplicated on this character.

   .. note::

      The objects are duplicated so that their center is positioned at
      the *lower right corner* of the corresponding characters.

.. _bpy.types.TextCurve.follow_curve:

Text on Curve
   Select a curve object for the text object to follow.

   .. figure:: /images/modeling_texts_properties_curved-lowres-example.png
      :width: 360px

      Text on curve.

   .. tip::

      You should rather use the :doc:`Curve modifier </modeling/modifiers/deform/curve>`,
      which offers more control, and is the standard way to achieve such effects in modern Blender.

.. _modeling-text-character-underline:
.. _bpy.types.TextCurve.underline_position:

Underline Position
   This allows you to shift vertically the position of the underline.

.. _py.types.TextCurve.underline_height:

Underline Thickness
   This controls the thickness of the underline.

.. _bpy.types.TextCurve.small_caps_scale:

Small Caps Scale
   The scaling applied to capital letters to turn them into small caps.


Paragraph
=========

.. reference::

   :Mode:      All
   :Panel:     :menuselection:`Properties --> Font --> Paragraph`

The *Paragraph* Panel has settings for the alignment and spacing of text.

.. figure:: /images/modeling_texts_properties_paragraph-settings.png

   The Paragraph panel.


Alignment
---------

.. _bpy.types.TextCurve.align_x:

Horizontal
   :Left:
      Aligns text to the left of the frames when using them,
      else uses the origin of the text object as the starting point of the text (which grows to the right).
   :Center:
      Centers text in the frames when using them,
      else uses the origin of the text object as the mid-point of the text
      (which grows equally to the left and right).
   :Right:
      Aligns text to the right of the frames when using them,
      else uses the origin of the text object as the ending point of the text (which grows to the left).
   :Justify:
      Only flushes a line when it is terminated by a word wrap (**not** by a newline),
      and uses *whitespace* instead of *character spacing* (kerning) to fill lines.
   :Flush:
      Always flushes the line, even when it is still being typed-in.
      It uses character spacing (kerning) to fill lines.

   .. note:: Both *Justify* and *Flush* only work within frames.

.. _bpy.types.TextCurve.align_y:

Vertical
   :Top:
      - With text boxes, aligns the top of the text to the top of the frames.
      - With no text box, aligns the top of the text to the origin of the object, and grows to the bottom.
   :Top Baseline:
      - With text boxes, aligns the 'top' baseline of the text to the top of the frames.
      - With no text box, aligns the actual baseline of the text to the origin of the object,
        and grows to the bottom.

      .. note::

         That difference of reference point in the first line
         depending on usage of boxes or not is indeed confusing.

   :Middle:
      - With text boxes, centers the text in the frames.
      - With no text box, centers the text on the origin of the object,
        and grows in both top and bottom directions equally.
   :Bottom Baseline:
      - With text boxes, aligns the baseline of the text to the bottom of the frames.
      - With no text box, aligns the baseline of the text to the origin of the object, and grows to the top.
   :Bottom:
      - With text boxes, align the bottom of the text to the bottom of the frames.
      - With no text box, align the bottom of the text to the origin of the object, and grows to the top.


Spacing
-------

.. _bpy.types.TextCurve.space_character:

Character Spacing
   A factor by which space between each character (kerning) is scaled in width.

   In Edit Mode in the 3D Viewport, you can also control individual kerning
   at text cursor position by pressing :kbd:`Alt-Left` / :kbd:`Alt-Right` to decrease/increase it.

.. _bpy.types.TextCurve.space_word:

Word Spacing
   A factor by which whitespace between words is scaled in width.

.. _bpy.types.TextCurve.space_line:

Line Spacing
   A factor by which the vertical space between lines is scaled.

.. _bpy.types.TextCurve.offset_x:
.. _bpy.types.TextCurve.offset_y:

Offset X, Y
   These settings control the X and Y offset of the text position within the object.
   This applies relatively to the object's origin, either to the whole text or, when using text boxes, to each frame.


.. _bpy.types.TextBox:

Text Boxes
==========

.. reference::

   :Mode:      All
   :Panel:     :menuselection:`Properties --> Font --> Text Boxes`

Text boxes (or frames) allow you to distribute the text among rectangular areas within a single text object.
An arbitrary number of freely movable and re-sizable text frames are allowed per text object.

The text flows continuously from the lowest-numbered frame to the highest-numbered frame with text
inside each frame word-wrapped.
It flows between frames when a lower-numbered frame cannot fit any more text.
If the last frame is reached, text overflows out of it (by default, see options below).

.. figure:: /images/modeling_texts_properties_frame-upperpanel-area.png

   Text Boxes panel.

.. _bpy.ops.font.textbox_add:

Add Textbox
   Inserts a new frame, just after the current one (in text flow order).
   The new frame will have the same size and position as the selected one.

.._bpy.ops.font.textbox_remove:

Delete ``X``
   Delete the current frame.

.. _bpy.types.TextCurve.overflow:

Overflow
   How to handle text overflowing available space in the defined boxes.

   :Overflow:
      Just keep text running out of the last box.
   :Scale to Fit:
      Scale text to fit into the available space.
   :Truncate:
      Hide the end of the text that does not fit into the available space.

      .. note::

         It will only truncate in *Object Mode*,
         in *Edit Mode* the whole text remains visible (and overflows as needed).

.. _bpy.types.TextBox.width:

Size X, Y
   Specifies the width and height of the text box, if set to **zero** no word wrapping happens
   (it is ignored, and the whole text box system is disabled if all are set to a null size).

.. _bpy.types.TextBox.x:
.. _bpy.types.TextBox.y:

Offset X, Y
   Controls the *X* and *Y* offset of the frame, i.e. its position.

.. figure:: /images/modeling_texts_properties_frame-example4.png

   Multiple columns, text flowing between boxes.


## Selecting

.. _bpy.ops.font.move_select:
.. _bpy.ops.font.select_all:

*********
Selecting
*********

.. figure:: /images/modeling_texts_selecting_cursor.png
   :width: 340px

   Text in Edit Mode.

In Edit Mode, your text has a white cursor, and as in any text editor,
it determines where new chars will be inserted.

Select All :kbd:`Ctrl-A`
   Selects the full text.
Top/Bottom :kbd:`Shift-Ctrl-Home`/ :kbd:`Shift-Ctrl-End`
   Moves the cursor to the start or end of the text object.
Next/Previous Character :kbd:`Left`/ :kbd:`Right`
   You can move the cursor with the arrow keys.
Next/Previous Word :kbd:`Ctrl-Left`/ :kbd:`Ctrl-Right`
   To move the cursor on a word's boundary.
Line Begin/End :kbd:`Home`/ :kbd:`End`
   Move the cursor to the beginning and end of a line respectively.
Next/Previous Line :kbd:`Up`/ :kbd:`Down`
   To jump between lines.
Next/Previous Block :kbd:`PageUp`/ :kbd:`PageDown`
   To jump back/forward ten lines at a time.

Hold :kbd:`Shift` while using the arrow keys to select a part of the text.
You can use it to specify different materials, the normal/bold/italic style...


## Index


#############
  Transform
#############

.. toctree::
   :maxdepth: 2

   introduction.rst
   modal_map.rst


## Introduction

.. index:: Transform; Modeling Transform
.. index:: Modeling Transform

************
Introduction
************

Transform is the modality of operations that perform transformations in 2D and 3D elements.
Transformations can include things like moving, rotating, scaling,
and applying other operations to objects in the scene.

They work by changing the geometry which you can edit directly.


Operators
=========

There are several transformation operations included in Blender.
Here are some of the main operations available:


Move
----

This operations allows you to move elements along the X, Y, and Z axes in the scene.


Rotate
------

You can use this function to rotate elements around the X, Y, and Z axes.


Scale
-----

Scaling allows you to increase or decrease the size of an object along the X, Y, and Z axes.


Align to View
-------------

This is useful for aligning objects with the view from the camera or another specific viewpoint.


Mirror
------

Mirrors objects along one or more axes.


## Modal Map


*******************
Transform Modal Map
*******************

During a transformation, some hotkeys can change the behavior of the operation.

You can check editing the keys of these modal modifiers in
:menuselection:`Blender Preferences --> Keymap --> Transform Modal Map`
(at the bottom of the keymap).


Constraints
===========

When moving, rotating or scaling, if you only want certain axes to be affected,
you can restrict the transformation to those axes.

By default the constraint keys are :kbd:`X`, :kbd:`Y` and :kbd:`Z`.
This constraint can be restricted to plane if :kbd`Shift`
is pressed or automatically detected if :kbd:`MMB` is pressed.

It is worth noting that if you press the same contraint hotkey a second time,
you change the orientation from Local to Global or vice versa. Pressing a third time disables the constraint.


Snapping
========

Transform operations use the :doc:`snapping settings </editors/3dview/controls/snapping>` set in the scene.
However, some options can be changed during the transformation.


Snap Invert
-----------

Even if the magnetic icon is disabled, you can still enable snapping during a transformation.
The default hotkey in this case is :kbd:`Ctrl`.


Set Snap Base
-------------

The Snap Base is automatically determined based on the :ref:`Snap Base <bpy.types.ToolSettings.snap_target>` options.
However, this automatic snap detection point of origin may not always align with the user's intentions.
Therefore, transform operations include a utility to set a new snap origin point during the transformation.
The new Snap Base will correspond to the snap point whose target is defined by the
:ref:`Snap Target <bpy.types.ToolSettings.snap_elements_base>`.

By default the hotkey is :kbd:`B`.


.. note::

   If only Snap to Increment is enabled as :ref:`Snap Target <bpy.types.ToolSettings.snap_elements_base>`,
   the targets **Vertex**, **Edge**, **Face** and **Edge Center** will be used instead.


Add Snap Point
--------------

While you're transforming a selection with snapping enabled,
you can press :kbd:`A` whenever there's a highlighted snap target to
mark it. With multiple such targets marked, the selection will
then be snapped to their average location.

Marking a target more than once will give it more weight.

.. figure:: /images/editors_3dview_controls_snapping_target-multiple.png

   Multiple snapping targets.


Navigating
==========

While performing a modal transformation, you can perform navigation actions such as zooming,
panning, or rotating by holding :kbd:`Alt` then perform the desired action.


## Index

.. _bpy.types.Volume:

###########
  Volumes
###########

.. toctree::
   :maxdepth: 2

   introduction.rst
   properties.rst


## Introduction


************
Introduction
************

Volume objects are containers used to represent `OpenVDB <https://www.openvdb.org/>`__ files in Blender.
OpenVDB is a library and file format for the interoperability and storage of volumetric data.
OpenVDB files may be generated by other software such as Houdini,
or from Blender's :doc:`fluid simulation cache </physics/fluid/type/domain/cache>`.

Volume objects can be created from the Add menu in the 3D Viewport,
or by dragging and dropping vdb-files into Blender.
For animations, a frame sequence of OpenVDB files can be imported.

.. figure:: /images/modeling_volumes_introduction_example.png

   :abbr:`WDAS (Walt Disney Animation Studios)` cloud data set rendered in wireframe, Workbench, and Cycles.


Rendering
=========

Rendering volumes works the same as rendering smoke simulations. By default,
the :doc:`Principled Volume shader </render/shader_nodes/shader/volume_principled>`
is used for rendering volume objects. It will use grids named ``density``,
``color`` and ``temperature`` by default. If these are not available,
another grid name must be chosen in the shader nodes.


Limitations
===========

- OpenVDB excels at representing sparse volumes, that aren't necessarily
  concentrated within a tight bounding box but may be spread out through space.
  However, in Blender, these are still rendered as dense volumes
  which is not ideal for performance and memory usage. This will be improved in future releases.

- OpenVDB files can also store level sets and points.
  While level set grids can be read, there is no current support for rendering them as surfaces.
  Importing OpenVDB points is not supported.


## Properties


**********
Properties
**********

.. _bpy.types.VolumeGrids:

Grids
=====

The :ref:`ui-list-view` shows the grids in the OpenVDB-file, listing their name and data type.
A "grid" is a set of volumetric data, which typically stores the density of each voxel
but can also contain temperatures, velocities and so on.

Click a grid to make the volume object display it.


OpenVDB File
============

.. _bpy.types.Volume.filepath:

File Path
   The VDB file to use.

.. _bpy.types.Volume.is_sequence:

Sequence
   Loads further VDB files, one for each frame in an animation. Much like with image sequences,
   all the files should have a numerical suffix in their name; so if you selected smoke-000.vdb
   in the *File Path*, there should be a smoke-001.vdb, a smoke-002.vdb and so on.

   .. _bpy.types.Volume.frame_duration:

   Frames
      How many frames of the sequence to use.

   .. _bpy.types.Volume.frame_start:

   Start
      Scene frame at which the sequence should start.

   .. _bpy.types.Volume.frame_offset:

   Offset
      How many frames of the sequence to skip at the beginning.

   .. _bpy.types.Volume.sequence_mode:

   Mode
      How the volume should behave before the sequence's first frame (*Start*) and after its
      last (*Start* + *Frames*).

      :Clip:
         Show nothing.
      :Extend:
         Keep showing the first/last frame of the sequence.
      :Repeat:
         Play the sequence again (and again, and again...).
      :Ping-Pong:
         Play the sequence forwards, then backwards, then forwards again and so on.


.. _bpy.types.VolumeDisplay:

Viewport Display
================

.. _bpy.types.VolumeDisplay.wireframe_type:

Wireframe
   Method used to represent volumes in :ref:`wireframe <3dview-shading-rendered>` shading mode.
   For heavy volume data sets, it can be useful to set the object to always display as wireframe.
   This way, the 3D Viewport remains responsive but the volume still appears in the final render.

   :None:
      The volume is not displayed in wireframe mode.
   :Bounds:
      Displays the volume as a :term:`Bounding Box` for the entire grid.
   :Boxes:
      Displays bounding boxes for nodes in the volume tree.
   :Points:
      Displays points for nodes in the volume tree.

.. _bpy.types.VolumeDisplay.wireframe_detail:

Detail
   The amount of detail to display for *Boxes* or *Points* wireframe mode.

   :Coarse:
      Display one box or point for each intermediate tree node.
   :Fine:
      Display a box or point for each leaf node containing 8×8 voxels.

.. _bpy.types.VolumeDisplay.density:

Density
   Thickness of the volume in the 3D Viewport.
   The density of the volume in the render is adjusted via
   :doc:`Volume Shading </render/shader_nodes/shader/volume_principled>`.

.. _bpy.types.VolumeDisplay.interpolation_method:

Interpolation
   Interpolation method to use for the visualization of the fluid grid.

   :Linear:
      Linear interpolation between voxels. Gives good smoothness and speed.
   :Cubic:
      Cubic interpolation between voxels. Gives smoothed high quality interpolation, but is slower.
   :Closest:
      No interpolation between voxels. Gives raw voxels.


.. _bpy.types.VolumeDisplay.use_slice:

Slice
-----

Renders only a single 2D section of the domain object.

.. _bpy.types.VolumeDisplay.slice_axis:

Axis
   :Auto:
      Adjust slice direction according to the view direction.
   :X/Y/Z:
      Slice along the X, Y, or Z axis.

.. _bpy.types.VolumeDisplay.slice_depth:

Position
   Position of the slice relative to the length of the respective domain side.


.. _bpy.types.VolumeRender:

Render
======

.. _bpy.types.VolumeRender.space:

Space
   Specifies how volume density and step size are computed.

   :Object:
      Keeps volume *Density* and *Detail* the same regardless of object scale.
   :World:
      Specify *Step Size* and *Density* in world space.

.. _bpy.types.VolumeRender.step_size:

Step Size :guilabel:`Cycles Only`
   Distance between volume samples. Lower values render more detail at the cost of performance.
   If set to zero, the step size is automatically determined based on voxel size.

.. _bpy.types.VolumeRender.clipping:

Clipping :guilabel:`Cycles Only`
   Value under which voxels are considered empty space to optimize rendering.

.. _bpy.types.VolumeRender.precision:

Precision :guilabel:`Cycles Only`
   Specifies volume data precision. Lower values reduce memory consumption at the cost of detail.

   :Full: Full float (Use 32 bit for all data).
   :Half: Half float (Use 16 bit for all data).
   :Variable: Automatically use less precision for less noticeable areas.

.. _bpy.types.VolumeRender.velocity_grid:

Velocity Grid :guilabel:`Cycles Only`
   The name of the grid that contains voxel velocities, for calculating motion blur.
   This can be the name of a single grid containing 3D vectors,
   or a prefix of three separate grids containing scalar values.
   In the latter case, the X grid should have a name suffix of ``x``, ``.x`` or ``_x``,
   with similar conventions for the Y and Z grids.

.. _bpy.types.VolumeRender.velocity_unit:

Velocity Unit :guilabel:`Cycles Only`
   Whether the velocity grid(s) specify distances per frame or per second.

.. _bpy.types.VolumeRender.velocity_scale:

Velocity Scale :guilabel:`Cycles Only`
   A custom multiplier to apply to the velocities in the VDB.


